<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://www.helloted.com/feed.xml" rel="self" type="application/atom+xml" /><link href="http://www.helloted.com/" rel="alternate" type="text/html" /><updated>2019-11-15T11:32:43+08:00</updated><id>http://www.helloted.com/feed.xml</id><title type="html">Helloted Blog</title><subtitle>曹浩之Helloted的技术博客，用于记录一些技术成长过程中的技术分享，包括客户端iOS/Android，后台Pyhon/Java，跨平台开发Flutter</subtitle><entry><title type="html">模块解耦的三种方案</title><link href="http://www.helloted.com/ios/2019/08/26/moudle/" rel="alternate" type="text/html" title="模块解耦的三种方案" /><published>2019-08-26T20:00:00+08:00</published><updated>2019-08-26T20:00:00+08:00</updated><id>http://www.helloted.com/ios/2019/08/26/moudle</id><content type="html" xml:base="http://www.helloted.com/ios/2019/08/26/moudle/">&lt;h3 id=&quot;1urlrouter&quot;&gt;1、URLRouter&lt;/h3&gt;

&lt;p&gt;URLRouter：将不同的模块定义成为不同的URL，通过URL的形式进行跨模块调用。&lt;/p&gt;

&lt;p&gt;传递一串参数URL就可以进行页面间的跳转，通过分解URL的字段来获取要跳转的页面和携带的参数，指向不同的页面，也可以支持多级页面跳转。URL的通用性也适用于跨平台实现，iOS, Android,Flutter都可以按照URL来进行路由。&lt;/p&gt;

&lt;p&gt;同时可以兼容APP间跳转URL Scheme进行进程间的通信，同App外面打开App中的某个页面。&lt;/p&gt;

&lt;p&gt;当然这种方案缺点也是很明显的，基于URL的设计只适合与UI界面，功能性的模块是不能采用这种方案的，所以这种方案只适用于视图驱动的模块。&lt;/p&gt;

&lt;p&gt;参考URL&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_6/25.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;根据URI进行拆分就能得到需要跳转的路径和参数&lt;/p&gt;

&lt;p&gt;示例代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    [URLRouter openRoute:@&quot;dnfgamehelper://MomentModule/vc/MomentDetailViewController?momentId=10018&amp;amp;show=1&quot; onVC:self handler:^(NSDictionary * _Nonnull callback) {
        
    }];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通过url可以获取要跳转的VC：MomentDetailViewController以及参数：momentId=10018&amp;amp;show=1&lt;/p&gt;

&lt;h4 id=&quot;2protocolclass&quot;&gt;2、ProtocolClass&lt;/h4&gt;

&lt;p&gt;Protocol（协议）的声明看起来类似一个类的接口，不同的是Protocol没有父类也不能定义实例变量。Protocol是一种特殊的程序设计结构，用于声明专门被别的类实现的方法。因为OC是单继承的，由于不支持多继承，所以很多时候都是用Protocol和Category来代替实现多继承。Protocol只能定义公用的一套接口，但不能提供具体的实现方法。&lt;/p&gt;

&lt;p&gt;Protocol的基本用途：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可以用来声明一大堆方法（不能直接声明成员变量，但是利用setter和getter方法可以达到相同效果）&lt;/li&gt;
  &lt;li&gt;只要某个类遵守了这个协议，就相当于拥有这个协议中的所有方法声明&lt;/li&gt;
  &lt;li&gt;只要父类遵守了某个协议，就相当于子类也遵守了&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;原理：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_6/26.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;3target-action&quot;&gt;3、Target-Action&lt;/h4&gt;

&lt;p&gt;利用OC的runtime能力，动态的调用指定Target的action.&lt;/p&gt;

&lt;p&gt;核心代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    Class cls = NSClassFromString(@&quot;TargetClassName&quot;);
    id obj = [[cls alloc]init];
    SEL aSelector = NSSelectorFromString(@&quot;doSomethingWithParam1:param2:&quot;);
    NSMethodSignature *sig  = [cls instanceMethodSignatureForSelector:aSelector];
    NSInvocation *msgInvocation = [NSInvocation invocationWithMethodSignature:sig];
    [msgInvocation setTarget:obj];
    [msgInvocation setSelector:aSelector];
    [msgInvocation setArgument:&amp;amp;para1 atIndex:2];
    [msgInvocation setArgument:&amp;amp;para2 atIndex:3];
    [msgInvocation invoke];
    [msgInvocation getReturnValue:&amp;amp;callBackValue];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;原理如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_6/27.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;4对比&quot;&gt;4、对比&lt;/h4&gt;

&lt;p&gt;URLRoute优点&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;通过URL来请求资源。不管是H5，RN，Weex，Flutter、iOS、Android界面或者组件请求资源的方式就都统一了；&lt;/li&gt;
  &lt;li&gt;服务器可以动态地控制页面跳转，对于一些业务变化比较快的应用很适合。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;URLRoute缺点&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Map规则是需要注册的，它们会在load方法里面写。写在load方法里面是会影响App启动速度的；&lt;/li&gt;
  &lt;li&gt;URL链接里面关于组件和页面的名字都是硬编码，参数也都是硬编码。 而且每个URL最好要有一个文档进行维护；&lt;/li&gt;
  &lt;li&gt;URL的参数传递是不够友好的，它最多是传递一个字典。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Target-Action优点&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;充分的利用Runtime的特性，无需注册。&lt;/li&gt;
  &lt;li&gt;每个category对应一个Target，Category中的方法对应Action场景。Target-Action方案也统一了所有组件间调用入口&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Target-Action缺点&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Runtime编译的时候无法报错，容易造成没有Selector的crash;&lt;/li&gt;
  &lt;li&gt;每个Target去写一个Category编码量大。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ProtocolClass优点&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;没有硬编码。Class的interface与Protocol类似，快速生成，对于已有项目的改造比较方便。&lt;/li&gt;
  &lt;li&gt;传递参数类型无限制,调用方法就跟普通对象调用方法一样&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ProtocolClass缺点&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Protocol要在当前类向Manager进行注册（如果通过NSProtocolFromString硬编码维护不友好，且有一个固定内存来进行map），注册分散不好管理。没法做组件不存在时或者出现错误时的统一处理。&lt;/li&gt;
  &lt;li&gt;与Protocol的原始定义不符合，从代码编程规范来看不友好。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Ted</name></author><category term="iOS" /><summary type="html">1、URLRouter</summary></entry><entry><title type="html">无源调试</title><link href="http://www.helloted.com/ios/2019/08/07/crash_debug/" rel="alternate" type="text/html" title="无源调试" /><published>2019-08-07T20:00:00+08:00</published><updated>2019-08-07T20:00:00+08:00</updated><id>http://www.helloted.com/ios/2019/08/07/crash_debug</id><content type="html" xml:base="http://www.helloted.com/ios/2019/08/07/crash_debug/">&lt;p&gt;一般App都会接入第三方的Crash报告SDK，比如友盟SDK，或者腾讯的bugly，当有crash的时候，SDK记录的crash记录的堆栈一般情况下可以很清晰地定位到源码的具体某一行，根据代码处理即可。但是有小部分情况下，crash记录的堆栈是系统堆栈，没有开发者的源码。&lt;/p&gt;

&lt;h4 id=&quot;1objc_msgsend16的crash&quot;&gt;1、objc_msgSend+16的crash&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_7/62.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_7/63.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上面的crash堆栈中，唯一跟App源码相关的就是main函数，其他的都是系统堆栈，显然没有办法直接定位到源码。&lt;/p&gt;

&lt;p&gt;objc_msgSend函数是runtime中核心的函数，为什么会崩溃在这，怎么处理这种crash？&lt;/p&gt;

&lt;h4 id=&quot;2objc_msgsend原理&quot;&gt;2、objc_msgSend原理&lt;/h4&gt;

&lt;p&gt;每一个OC对象有一个类，每一个OC类都有一个方法列表。每一个方法都有一个selector，一个指向方法实现的函数指针，以及一些元数据。objc_msgSend的工作就是传入对象和selector，查找相应方法的函数指针，然后跳到函数指针所指向的位置。&lt;/p&gt;

&lt;p&gt;查找方法的过程可能是非常复杂的。如果在一个类里没有找到这个方法，那么它会继续到superclass里去查找。如果在所有的superclass中都没有找到，就会调用运行时的消息转发代码。当一个类第一次收到消息时，他会去调用类的 +initialize方法。&lt;/p&gt;

&lt;p&gt;通常查找一个方法必须是迅速的，因为每次消息的调用都需要有这个过程。这就和复杂的查找过程有冲突了，复杂但是要快。&lt;/p&gt;

&lt;p&gt;OC解决这个冲突的方案是做方法缓存。每一个类有一个cache，用于存储方法的selectors和函数指针，也就是所谓的IMP。他们被组成一个哈希表，所以查找的时候是非常快的。当查找一个方法时，运行时首先询问cache。如果cache里没有这个方法，后续就会有一个缓慢而又复杂的过程，最后会把找到的结果放到cache里，这样下次查找该方法的时候就会很快了。&lt;/p&gt;

&lt;p&gt;objc_msgSend是用汇编写的。有两个原因：一是因为在C语言中不可能通过写一个函数来保留未知的参数并且跳转到一个任意的函数指针。C语言没有满足做这件事情的必要特性。另一个原因是objc_msgSend必须够快。&lt;/p&gt;

&lt;p&gt;当然，谁都不会想要用汇编写下整个复杂的消息查找过程。这没必要。消息发送的代码可以被分为两部分：objc_msgSend中有一个快速路径，是用汇编写的，还有一个慢速的路径，是用C实现的。汇编部分主要实现的是在缓存中查找方法，并且如果找到的话就跳转过去的一个过程。如果在缓存中没有找到方法的实现，就会调用C的代码来处理后续的事情。&lt;/p&gt;

&lt;p&gt;因此，objc_msgSend主要有以下几个步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;获取传入的对象的类&lt;/li&gt;
  &lt;li&gt;获取这个类的方法缓存&lt;/li&gt;
  &lt;li&gt;通过传入的selector，在缓存中查找方法&lt;/li&gt;
  &lt;li&gt;如果缓存中没有，调用C代码&lt;/li&gt;
  &lt;li&gt;跳到这个方法的IMP&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;3objc_msgsend的汇编指令&quot;&gt;3、objc_msgSend的汇编指令&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;ARM64架构下有31个通用寄存器，每个都是64位宽的。他们被标记为x0~x30。同样也有可能使用&lt;code class=&quot;highlighter-rouge&quot;&gt;w0&lt;/code&gt;到&lt;code class=&quot;highlighter-rouge&quot;&gt;w30&lt;/code&gt;来访问寄存器的低32位。寄存器x0x7被用于函数入参的前8个参数。这就表示objc_msgSend收到的self参数是保存在x0中，selector _cmd参数在x1里。&lt;/p&gt;

  &lt;p&gt;&lt;img src=&quot;/img/Simple_7/65.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

  &lt;p&gt;x0到x7用来做参数传递，以及从子函数返回结果（通常通过x0返回，如果是一个比较大的结构体则结果会存在x8的执行地址上）&lt;/p&gt;

  &lt;p&gt;LR：即x30寄存器，也叫链接寄存器，一般是保存返回上一层调用的地址&lt;/p&gt;

  &lt;p&gt;FP：即r29，栈底寄存器&lt;/p&gt;

  &lt;p&gt;外加一个栈顶寄存器SP&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;objc_msgSend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;receiver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SEL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;回顾objc_msgSend函数我们可以知道：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;x0 寄存器中的保存receiver。&lt;/li&gt;
  &lt;li&gt;x1 寄存器中保存的selector。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用符号断点，我们可以查看objc_msgSend的符号指令&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_7/64.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;libobjc.A.dylib`objc_msgSend:
    0x1931bb6a0 &amp;lt;+0&amp;gt;:   cmp    x0, #0x0                  ; // 将receiver与0进行比较
    0x1931bb6a4 &amp;lt;+4&amp;gt;:   b.le   0x1931bb714               ; // nil对象处理或者tagged pointer对象处理
    0x1931bb6a8 &amp;lt;+8&amp;gt;:   ldr    x13, [x0]    // 取出receiver的isa指针赋值给x13
    0x1931bb6ac &amp;lt;+12&amp;gt;:  and    x16, x13, #0xffffffff8 // 得到receiver的Class对象指针赋值给x16
-&amp;gt;  0x1931bb6b0 &amp;lt;+16&amp;gt;:  ldp    x10, x11, [x16, #0x10] // 取出Class对象的cache成员分别保存到x10,x11寄存器中
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;+16的地方crash，名称是SIGV_ACCERR，内存访问错误，野指针，class对象的内存应该是在整个App生命周期都是可行的，为什么会出现访问错误呢？&lt;/p&gt;

&lt;h4 id=&quot;4objc_msgsend-crash原因&quot;&gt;4、objc_msgSend crash原因&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_7/66.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上图，对象在堆内存区，在还没有被销毁之前，isa指针会指向其Class对象的内存地址，此时objc_msgSend是没有问题的，而对象被销毁之后，堆内存被回收，很有可能这部分内存就被覆盖，一个已经释放了的OC对象继续调用实例方法时，在objc_msgSend函数内部读取到obj的isa指针得到的将是一个未知或者有可能无效的指针值，指向的内存错误，出现野指针的错误。&lt;/p&gt;

&lt;p&gt;也就是在读取x16地址的时候，导致内存读取错误，导致崩溃。&lt;/p&gt;

&lt;p&gt;实际上，在前两条指令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    0x1931bb6a0 &amp;lt;+0&amp;gt;:   cmp    x0, #0x0 
    0x1931bb6a4 &amp;lt;+4&amp;gt;:   b.le   0x1931bb714  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;只是进行比较，不会crash。&lt;/p&gt;

&lt;p&gt;而第三条指令，访问receiver的isa指针赋值给x13&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0x1931bb6a8 &amp;lt;+8&amp;gt;:   ldr    x13, [x0]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NSObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;虽然，receiver已经被销毁，但是OC对象都是从堆内存区域中分配内存的，所以当某个OC对象被销毁后，其所占用的内存仍然会放回堆内存区域中进行管理，而堆内存区域的地址是可以进行任意的读写访问的，所以即使对象被销毁释放，其isa指针仍然是可以正常访问，虽然值可能被覆盖，但不会crash。&lt;/p&gt;

&lt;h4 id=&quot;5objc_msgsend-crash解决方案&quot;&gt;5、objc_msgSend crash解决方案&lt;/h4&gt;

&lt;p&gt;从上面可以知道，寄存器中的值：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;x0 寄存器中的保存的就是receiver。&lt;/li&gt;
  &lt;li&gt;x1 寄存器中保存的就是receiver的selector。&lt;/li&gt;
  &lt;li&gt;x13 寄存器中保存的就是receiver的isa指针。&lt;/li&gt;
  &lt;li&gt;x16 寄存器中保存的就是isa指向的Class指针对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因为对象已经被销毁，所以x0,x13,x16的值都是不准确的，我们不能通过这个来获取对象的信息，但是x1中存储的selector是准确的，如果可以找到selector也许也可以找到崩溃的对象的类，从而定位源码。&lt;/p&gt;

&lt;p&gt;根据地址找到对应Binary Image，如果是App的地址范围，用IDA或者命令行来解析：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;符号包位置：
XXX.app.dSYM/Contents/Resources/DWARF/XXX

首先查询UUID，判断符号文件是正确的
xcrun dwarfdump --uuid &amp;lt;SymbolAddress&amp;gt;
eg:
xcrun dwarfdump --uuid /Users/haozhicao/Downloads/dnf
UUID: 82E51E16-AA1D-39AA-BDBD-AB0AD6A13BC0 (armv7) /Users/haozhicao/Downloads/dnf
UUID: C8865298-02A3-33E4-A3F4-C68A6DC50D3A (arm64) /Users/haozhicao/Downloads/dnf

用atos命令
atos -o XXX -l &amp;lt;SymbolAddress&amp;gt; &amp;lt;Address&amp;gt;
eg:
atos -o /Users/haozhicao/Downloads/dnf -l 0x0000000102a2c000 0x0000000102f3ea48
-[GHPDnfIPUserHeaderView avatarClicked] (in dnf) (GHPDnfIPUserHeaderView.m:362)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果是系统SDK，用IDA或者命令otool解析&lt;/p&gt;

&lt;p&gt;系统符号表存储位置&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~/Library/Developer/Xcode/iOS\ DeviceSupport/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;otool -v -arch arm64e -s __TEXT __objc_methname &amp;lt;KitAddress&amp;gt; &amp;lt;Address&amp;gt;

eg:
otool -v -arch arm64e -s __TEXT __objc_methname /Users/haozhicao/Library/Developer/Xcode/iOS\ DeviceSupport/12.4\ \(16G77\)\ arm64e/Symbols/System/Library/Frameworks/UIKit.framework/UIKit 0x00000001880c17ec
-[_UIWebViewScrollViewDelegateForwarder forwardInvocation:](in UIKit)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Ted</name></author><category term="iOS" /><summary type="html">一般App都会接入第三方的Crash报告SDK，比如友盟SDK，或者腾讯的bugly，当有crash的时候，SDK记录的crash记录的堆栈一般情况下可以很清晰地定位到源码的具体某一行，根据代码处理即可。但是有小部分情况下，crash记录的堆栈是系统堆栈，没有开发者的源码。</summary></entry><entry><title type="html">Flutter UI原理</title><link href="http://www.helloted.com/flutter/2019/05/18/FlutterUI/" rel="alternate" type="text/html" title="Flutter UI原理" /><published>2019-05-18T20:00:00+08:00</published><updated>2019-05-18T20:00:00+08:00</updated><id>http://www.helloted.com/flutter/2019/05/18/FlutterUI</id><content type="html" xml:base="http://www.helloted.com/flutter/2019/05/18/FlutterUI/">&lt;h3 id=&quot;一万物皆widget&quot;&gt;一、万物皆Widget&lt;/h3&gt;

&lt;h4 id=&quot;1widget&quot;&gt;1、Widget&lt;/h4&gt;

&lt;p&gt;Widgets是Flutter App用户交互的基础构成，每个widget代表的是用户交互的一部分(不可变的)，不像其他frameworks会分开views，viewControllers，layout或者其他属性，Flutter有一个统一的对象模型：widget。&lt;/p&gt;

&lt;p&gt;Widget可以定义：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个控件元素(比如button或者menu)&lt;/li&gt;
  &lt;li&gt;一个样式元素(比如字体或者颜色)&lt;/li&gt;
  &lt;li&gt;一个布局(比如padding)&lt;/li&gt;
  &lt;li&gt;等等…&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Widgets基于组合形成层次结构。 每个wiget都嵌套在其内部，并从其父级继承属性。 没有单独的“application”对象。 取而代之的是，root widget担任此角色。&lt;/p&gt;

&lt;p&gt;您可以通过将层次结构中的widget替换为另一个widget来响应事件，例如用户交互。 然后，框架比较新旧widget并有效地更新用户界面。&lt;/p&gt;

&lt;p&gt;Widgets本身通常由许多小的，单一用途的Widget组成，这些Widgets组合起来产生强大的效果。 例如，Container是一个常用的Widget，由几个负责布局，绘制，定位和大小调整的小部件组成。 具体来说，Container由LimitedBox，ConstrainedBox，Align，Padding，DecoratedBox和Transform小部件组成。 您可以用新颖的方式组合这些以及其他简单的小部件，而不是将Container子类化以生成自定义效果。&lt;/p&gt;

&lt;p&gt;类层次结构浅而宽，以最大化可能的组合数。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_7/52.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;您还可以通过将Widget与其他Widget组合来控制Widget的布局。 例如，要将Widget居中，请将其包含在 Center Widegt中。 有填充，对齐，行，列和网格的Widget。 这些布局Widget没有自己的可视化表示。 相反，他们唯一的目的是控制另一个Widget布局的某些方面。 要了解Widget以某种方式呈现的原因，检查相邻Widget通常很有帮助。&lt;/p&gt;

&lt;h4 id=&quot;2layer层级&quot;&gt;2、Layer层级&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_7/53.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;3widget与element&quot;&gt;3、Widget与Element&lt;/h4&gt;

&lt;p&gt;在Flutter中，Widget的功能是“描述一个UI元素的配置数据”，它就是说，Widget其实并不是表示最终绘制在设备屏幕上的显示元素，而只是显示元素的一个配置数据。实际上，Flutter中真正代表屏幕上显示元素的类是&lt;code class=&quot;highlighter-rouge&quot;&gt;Element&lt;/code&gt;，也就是说Widget只是描述&lt;code class=&quot;highlighter-rouge&quot;&gt;Element&lt;/code&gt;的一个配置，有关&lt;code class=&quot;highlighter-rouge&quot;&gt;Element&lt;/code&gt;的详细介绍我们将在本书后面的高级部分深入介绍，读者现在只需要知道，Widget只是UI元素的一个配置数据，并且一个Widget可以对应多个&lt;code class=&quot;highlighter-rouge&quot;&gt;Element&lt;/code&gt;，这是因为同一个Widget对象可以被添加到UI树的不同部分，而真正渲染时，UI树的每一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Element&lt;/code&gt;节点都会对应一个Widget对象。总结一下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Widget实际上就是Element的配置数据，Widget树实际上是一个配置树，而真正的UI渲染树是由Element构成；不过，由于Element是通过Widget生成，所以它们之间有对应关系，所以在大多数场景，我们可以宽泛地认为Widget树就是指UI控件树或UI渲染树。&lt;/li&gt;
  &lt;li&gt;一个Widget对象可以对应多个Element对象。这很好理解，根据同一份配置（Widget），可以创建多个实例（Element）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;二层级&quot;&gt;二、层级&lt;/h3&gt;

&lt;p&gt;看下面这张图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_7/56.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在顶部是一些常用的Material和Cupertino风格的Widget；&lt;/li&gt;
  &lt;li&gt;接下来是一些通用的Widget层，大部分时间我们都只会使用上面的两层就足够使用；&lt;/li&gt;
  &lt;li&gt;在Widgets层下面是render渲染层，这层的主要作用是简化了布局和绘制过程，是底部的&lt;code class=&quot;highlighter-rouge&quot;&gt;dart:ui库&lt;/code&gt;的另一个抽象；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dart:ui&lt;/code&gt;是最后一个Dart层，它基本上处理与Flutter引擎的通信。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;简而言之，可以说较高级别更易于使用，而较低级别则可以为您提供更多的API，更复杂的细粒度控制。&lt;/p&gt;

&lt;h4 id=&quot;1dartui库&quot;&gt;1、dart:ui库&lt;/h4&gt;

&lt;p&gt;dart:ui库显示了Flutter框架用于引导应用的最低层级服务，例如用于驱动输入，图形文本，布局和渲染等子系统。&lt;/p&gt;

&lt;p&gt;所以基本上你可以通过利用dart:ui包中的类（例如Canvas，Paint和TextBox）来编写一个’Flutter’应用程序。但是，不仅要考虑绘画，还要考虑编排布局和对应用程序元素进行测试，这将是一个难以管理的事情。&lt;/p&gt;

&lt;p&gt;这意味着您必须手动计算布局中使用的所有坐标。然后混合一些绘画和hit test来捕捉用户输入。为每一帧做到这一点并跟踪它。如果你只是你打算构建一个简单的应用程序，它只显示一个蓝色框内的文本，那倒有可能。但如果你试图建立更复杂的布局，如购物应用程序甚至小游戏，那么这种方法就不那么好了。甚至不敢想动画，滚动或其他我们都喜欢的花哨的UI东西。&lt;/p&gt;

&lt;h4 id=&quot;2render渲染层&quot;&gt;2、render渲染层&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;Flutter Widgets库使用RenderObject层次结构来实现其布局和绘制。通常情况下，虽然可以在应用程序中使用自定义RenderBox类来实现特定效果，但大多数情况下，调试布局问题的时候才需要与RenderObject打交道。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Render渲染库是dart:ui库之上的第一个抽象层，可以为您完成所有繁重的数学运算（例如，跟踪计算的坐标等）。由RenderObjects组成的树稍后将由Flutter绘制并绘制。为了优化这个复杂的过程，Flutter使用智能算法换成繁杂的计算已优化性能。&lt;/p&gt;

&lt;p&gt;大多数情况下，你会发现Flutter使用RenderBox而不是RenderObject。一个简单的box layout协议非常适合构建高性能的UI。每个widget都被放置在它自己的box当中，这个box被计算出来，然后与其他预先布置好的box一起排列。因此，如果布局中只有一个widget发生更改（例如按钮或开关），则系统只需要重新计算这个相对较小的box。&lt;/p&gt;

&lt;h4 id=&quot;3widgts库&quot;&gt;3、Widgts库&lt;/h4&gt;

&lt;p&gt;这一层抽象提供了现成的UI组件，我们可以直接放入我们的应用中。有三种类别：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;layout布局&lt;/code&gt;： 例如。 列和行小部件使我们可以轻松地将其他小部件垂直或水平对齐。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Paiting绘画&lt;/code&gt;： 例如。 文本和图像小部件允许我们在屏幕上显示（“绘制”）一些内容。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Hit-Testing&lt;/code&gt;：例如。 GestureDetector允许我们识别不同的手势，例如点击（用于检测按下按钮）和拖动（用于滑动列表）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通常情况，我们使用许多基础基本的widget，并构建自己的widget。 例如，您可以在Container中构建一个按钮，将其包装到GestureDetector中以检测按钮被按下的动作。&lt;/p&gt;

&lt;p&gt;但是，Flutter团队不是自己构建每个UI组件，而是创建了两个库，其中包含Material和Cupertino（类似iOS）样式中常用的Widget。&lt;/p&gt;

&lt;h4 id=&quot;4material--cupertino&quot;&gt;4、Material &amp;amp; Cupertino&lt;/h4&gt;

&lt;p&gt;最上面一层包含了Material设计规范中的预构建元素(比如AlertDialog，Switch和FloatingActionButton)和一些重新创建的iOS样式的Widgets(例如CupertinoAlertDialog，CupertinoButton和CupertinoSwitch)；&lt;/p&gt;

&lt;h3 id=&quot;三渲染过程&quot;&gt;三、渲染过程&lt;/h3&gt;

&lt;p&gt;先来看一个简单的Wiget树&lt;/p&gt;

&lt;div class=&quot;language-dart highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SimpleApp&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StatelessWidget&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@override&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Widget&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BuildContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SimpleContainer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;nl&quot;&gt;color:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Colors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;white&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;nl&quot;&gt;child:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SimpleText&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'Flutter is awesome!'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;color:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Colors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;blue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;很简单的一个应用只包含三个widgets: &lt;code class=&quot;highlighter-rouge&quot;&gt;SimpleApp&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;SimpleContainer&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;SimpleText&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;当调用runApp()之后，会有下面的步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Flutter将构建包含三个statless widget的widget树。&lt;/li&gt;
  &lt;li&gt;Flutter沿着小部件树向下走，并通过在小部件上调用createElement()来创建第二个包含相应Element对象的树。&lt;/li&gt;
  &lt;li&gt;创建第三个树并使用相应的RenderObjects填充，这些RenderObject由Element调用相应小部件上的createRenderObject()方法创建。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如下图的三种树：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_7/58.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到，Flutter框架创建了三个不同的树，一个用于Widgets，一个用于Element，一个用于RenderObject。每个Element都包含对Widget和RenderObject的引用。&lt;/p&gt;

&lt;p&gt;RenderObject用来包含用于呈现对应Widget的所有逻辑，RenderObject实例化非常昂贵，它负责布局，绘画和Hit-test。最好尽可能长时间地将这些对象保存在内存中或者可以回收它们（因为实例化成本非常高）。&lt;/p&gt;

&lt;p&gt;Elements是&lt;strong&gt;不可变Widget树&lt;/strong&gt;和&lt;strong&gt;可变RenderObject树&lt;/strong&gt;之间的粘合剂。Element代表着Widget的配置和在树中的特定位置，并保留对相关Widget和RenderObject的引用。&lt;/p&gt;

&lt;p&gt;为什么要有三棵树？因为高效，每次更改Widgets树时，Flutter都使用Elements树来比较Widgets树和现有的RenderObjects。当Widget的类型与以前相同时，Flutter不需要重新创建昂贵的RenderObject，只需更新其可变配置即可。由于Widgets非常轻量级且实例化成本低廉，因此它们非常适合描述应用程序的当前状态（也称为“配置”）。 “重量级”RenderObjects（创建起来很昂贵）不会每次都重新创建而是尽可能重用。&lt;/p&gt;

&lt;p&gt;在框架中，Elements很好地“抽象出来”，因此您不必经常处理它们。在每个构建（BuildContext上下文）函数中传递的BuildContext实际上是包含在BuildContext接口中的相应Element，这就是为什么它对于每个Widget都不同。&lt;/p&gt;

&lt;h4 id=&quot;1更新同类型widget&quot;&gt;1、更新同类型Widget&lt;/h4&gt;

&lt;div class=&quot;language-dart highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SimpleApp&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StatelessWidget&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@override&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Widget&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BuildContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SimpleContainer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;nl&quot;&gt;color:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Colors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;red&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// SimpleContainer颜色变更&lt;/span&gt;
      &lt;span class=&quot;nl&quot;&gt;child:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SimpleText&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'Flutter is awesome!'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;color:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Colors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;blue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;由于Widget是不可变的，因此每次配置更改时都需要重建Widget树。 当我们将Container的颜色更改为红色时，框架将触发重建，这将重新创建整个Widget树，因为它是不可变的。 接下来，借助Elements树中Elements的帮助，Flutter将新Widgets树与旧的Widegt树进行比较。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;比较的基本规则：检查旧Widget和新Widget是否来自同一类型。 如果不是，从树中删除Widget，Element和RenderObject（包括子树）并创建新对象。 如果它们来自相同类型，则只需更新RenderObject的配置以表示Widget的新配置。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在我们的示例中，&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;SimpleApp与以前的类型相同，并且具有与相应的SimpleAppRender对象相同的配置，因此不会有任何更改。&lt;/li&gt;
  &lt;li&gt;Widget树中的下一个是SimpleContainer窗口小部件，但具有不同的颜色配置。因此更新SimpleContainerRender对象上的颜色属性并要求重绘。&lt;/li&gt;
  &lt;li&gt;其他对象将保持不变。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_7/59.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意更新之后，Element和RenderObjects仍然是相同的实例对象。这个过程很快，因为Widegt的配置很轻量级。 而重量级对象将保持不变。&lt;/p&gt;

&lt;h4 id=&quot;2不同类型的widget&quot;&gt;2、不同类型的Widget&lt;/h4&gt;

&lt;div class=&quot;language-dart highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SimpleApp&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StatelessWidget&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@override&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Widget&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BuildContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SimpleContainer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;nl&quot;&gt;color:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Colors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;red&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;  
      &lt;span class=&quot;nl&quot;&gt;child:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SimpleButton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Widget由SimpleText变更为SimpleButton&lt;/span&gt;
        &lt;span class=&quot;nl&quot;&gt;child:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SimpleText&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'Click me'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt;
        &lt;span class=&quot;nl&quot;&gt;color:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Colors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;blue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt;
      	&lt;span class=&quot;nl&quot;&gt;onPressed:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()=&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'Yay!'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;同样的，Flutter会重建Widget树并且对比之前的Element树和RenderObject树进行比较&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_7/60.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;因为SimpleButton和SimpleText类型不同，Flutter将会把SimpleText对应的Element和SimpleTextRender从树中移除，而SimpleButton没有对应的Element，所以会根据Widget树，创建对应的Element和RenderObjects&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_7/61.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这样新的渲染树就被建立然后被布局会绘制到屏幕上。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;https://medium.com/flutter-community/the-layer-cake-widgets-elements-renderobjects-7644c3142401&lt;/p&gt;

&lt;p&gt;https://www.youtube.com/watch?v=dkyY9WCGMi0&lt;/p&gt;</content><author><name>Ted</name></author><category term="Flutter" /><summary type="html">一、万物皆Widget</summary></entry><entry><title type="html">Dart内存机制</title><link href="http://www.helloted.com/flutter/2019/05/13/DartRuntime/" rel="alternate" type="text/html" title="Dart内存机制" /><published>2019-05-13T20:00:00+08:00</published><updated>2019-05-13T20:00:00+08:00</updated><id>http://www.helloted.com/flutter/2019/05/13/DartRuntime</id><content type="html" xml:base="http://www.helloted.com/flutter/2019/05/13/DartRuntime/">&lt;h3 id=&quot;一移动端的内存回收机制&quot;&gt;一、移动端的内存回收机制&lt;/h3&gt;

&lt;p&gt;GC(Garbage Collection)，垃圾回收机制，简单地说就是程序中及时处理废弃不用的内存对象的机制，防止内存中废弃对象堆积过多造成内存泄漏&lt;/p&gt;

&lt;p&gt;常见的垃圾回收算法有引用计数法（Reference Counting）、标注并清理（Mark and Sweep GC）、拷贝（Copying GC）和逐代回收（Generational GC）等算法。&lt;/p&gt;

&lt;h4 id=&quot;1ios端&quot;&gt;1、iOS端&lt;/h4&gt;

&lt;p&gt;Objective-C语言本身是支持垃圾回收机制的，但有平台局限性，仅限于Mac桌面系统开发中，而在iPhone和iPad等苹果移动终端设备中是不支持垃圾回收机制的。在移动设备开发中的内存管理是采用MRC(Manual Reference Counting)以及iOS5以后的ARC(Automatic Reference Counting)，本质都是RC引用计数，通过引用计数的方式来管理内存的分配与释放，从而防止内存泄漏。&lt;/p&gt;

&lt;p&gt;iOS采用引用计数算法回收内存，当对象引用计数为0时，对象会执行反初始化方法并被回收。如果两个对象互相引用对方，就会造成循环强引用，导致内存泄漏。&lt;/p&gt;

&lt;h4 id=&quot;2android端&quot;&gt;2、Android端&lt;/h4&gt;

&lt;p&gt;Android系统采用的是标注并删除和拷贝GC，并不是大多数JVM实现里采用的逐代回收算法，根搜索算法回收内存，该算法通过GC Roots作为起点搜索，搜索通过的路径称为引用链，当一个对象没有被GC Roots的引用链连接的时候，这个对象就会被回收。即使A和B两个对象互相引用对方，只要A和B都不在引用链上，这两个对象都会被回收。&lt;/p&gt;

&lt;p&gt;下图中的每个圆节点代表对象，箭头代表可达路径，当圆节点与 GC Roots 存在可达路径时，表示无法回收(黄色圆节点)，反之则可以回收(蓝色圆节点)。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_7/47.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h5 id=&quot;gc-root&quot;&gt;GC Root&lt;/h5&gt;

  &lt;ul&gt;
    &lt;li&gt;虚拟机栈（栈帧中的局部变量）中的引用的对象。&lt;/li&gt;
    &lt;li&gt;方法区域中的类静态属性引用的对象。&lt;/li&gt;
    &lt;li&gt;方法区域中常量引用的对象。&lt;/li&gt;
    &lt;li&gt;本地方法栈中 JNI（Native 方法）的引用的对象。&lt;/li&gt;
    &lt;li&gt;运行中线程引用的对象&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;3gc与引用计数rc的区别&quot;&gt;3、GC与引用计数RC的区别&lt;/h4&gt;

&lt;p&gt;另外引用计数RC和垃圾回收GC是有区别的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;GC垃圾回收是宏观的，对整体进行内存管理，将所有对象看做一个集合，然后在GC循环中定时检测活动对象和非活动对象，及时将用不到的非活动对象释放掉来避免内存泄漏，也就是说用不到的垃圾对象是交给GC来管理释放的，而无需开发者关心，比如Java中的垃圾回收机制；&lt;/li&gt;
  &lt;li&gt;引用计数是局部性的，开发者要管理控制每个对象的引用计数，单个对象引用计数为0后会马上被释放掉。ARC自动引用计数则是一种改进，由编译器帮助开发者自动管理控制引用计数(自动在合适的时机发送release和retain消息)。另外自动释放池autorelease pool则像是一个局部的垃圾回收，将部分垃圾对象集中释放，相对于单个释放会有一定延迟。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;二flutter的runtime&quot;&gt;二、Flutter的runtime&lt;/h3&gt;

&lt;p&gt;Flutter使用&lt;code class=&quot;highlighter-rouge&quot;&gt;dart&lt;/code&gt;语言作为其开发语言和运行环境。&lt;code class=&quot;highlighter-rouge&quot;&gt;dart&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;runtime&lt;/code&gt;是一直存在的，但是在&lt;code class=&quot;highlighter-rouge&quot;&gt;debug&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;release&lt;/code&gt;模式下有一些区别。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;debug&lt;/code&gt;模式下，&lt;code class=&quot;highlighter-rouge&quot;&gt;dart&lt;/code&gt;大部分组件都放在设备上，例如&lt;code class=&quot;highlighter-rouge&quot;&gt;runtime&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;JIT(Android)&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;interpreter(iOS)&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;debug&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;profile&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;services&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;release&lt;/code&gt;模式下，只剩下&lt;code class=&quot;highlighter-rouge&quot;&gt;runtime&lt;/code&gt;，而这也是Flutter App能够运行起来的最基本组件。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/img/Simple_7/48.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;runtime&lt;/code&gt;中，存在一个在初始化对象时为其分配内存，对象不再被使用的时候回收内存的组件，即GC。
在&lt;code class=&quot;highlighter-rouge&quot;&gt;Flutter&lt;/code&gt;中存在很多对象。以&lt;code class=&quot;highlighter-rouge&quot;&gt;Stateless&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Widget&lt;/code&gt;为例，其在&lt;code class=&quot;highlighter-rouge&quot;&gt;State&lt;/code&gt;发生变化或者&lt;code class=&quot;highlighter-rouge&quot;&gt;Widget&lt;/code&gt;不可见的时候不断地发生重建和销毁(&lt;strong&gt;注意，此处是指Widget树中的Widget，对于Element树和RenderObject树来说，element和renderObject是可变的，而且其初始化生成需要消耗很多资源。因此在大多数情况下他们是会被回收利用的&lt;/strong&gt;)。这些&lt;code class=&quot;highlighter-rouge&quot;&gt;Widget&lt;/code&gt;的生命周期都很短，对于一个UI比较复杂的APP来说，可能会有数千个&lt;code class=&quot;highlighter-rouge&quot;&gt;Widget&lt;/code&gt;需要被经常回收创建。&lt;/p&gt;

&lt;p&gt;所以有些开发者可能会采取一些措施来避免太过频繁的GC。比如为了保持一个引用的&lt;code class=&quot;highlighter-rouge&quot;&gt;Widget&lt;/code&gt;对象不会被回收，将其放在&lt;code class=&quot;highlighter-rouge&quot;&gt;state&lt;/code&gt;中(&lt;strong&gt;这样并不是说真的不会被回收，只是创建回收的频率被降低了，因为state是属于element的，而element的生命周期是比较长的&lt;/strong&gt;)。&lt;/p&gt;

&lt;p&gt;这么做是没有必要的，首先&lt;code class=&quot;highlighter-rouge&quot;&gt;Widget&lt;/code&gt;是一个很轻量级的对象，它的创建和回收并不会占用很多资源，真正占用资源的是&lt;code class=&quot;highlighter-rouge&quot;&gt;Element&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;RenderObject&lt;/code&gt;。其次&lt;code class=&quot;highlighter-rouge&quot;&gt;dart&lt;/code&gt; 的GC机制能够快速有效的进行对象回收，不用担心&lt;code class=&quot;highlighter-rouge&quot;&gt;Widget&lt;/code&gt;创建过多导致&lt;code class=&quot;highlighter-rouge&quot;&gt;OOM&lt;/code&gt;出现。&lt;/p&gt;

&lt;h3 id=&quot;三dart-garbage-collector&quot;&gt;三、Dart Garbage Collector&lt;/h3&gt;

&lt;p&gt;Dart的垃圾回收是分代的：年轻代和老年代&lt;/p&gt;

&lt;h4 id=&quot;1调度&quot;&gt;1、调度&lt;/h4&gt;

&lt;p&gt;为了最小化GC对应用程序和UI性能的影响（因为dart的GC有一种类似于JVM中stop the world的机制，导致APP对事件无响应、UI无法刷新），GC与Flutter engine建立联系，当engine检测到应用程序处于空闲状态且没有用户交互时，它会发出通知。这样就使得GC有了收集的窗口从而不影响性能。&lt;/p&gt;

&lt;p&gt;GC还可以在这些空闲的窗口期运行滑动压缩，从而通过减少内存碎片来最小化内存开销。&lt;/p&gt;

&lt;h4 id=&quot;2年轻代&quot;&gt;2、年轻代&lt;/h4&gt;

&lt;p&gt;这个阶段旨在清除寿命较短的短暂对象，例如stateless widgets。虽然它是阻塞的，但它比老年代mark-sweep快得多，并且当与调度结合使用时，几乎不会影响程序的运行。&lt;/p&gt;

&lt;p&gt;实际上，对象被分配给内存中的连续空间，并且在创建对象时，它们被分配下一个可用空间，直到分配的内存被填充完毕。 &lt;code class=&quot;highlighter-rouge&quot;&gt;dart&lt;/code&gt;使用指针碰撞的方式来给这些对象分配空间(之所以没有空闲列表的方法是因为&lt;code class=&quot;highlighter-rouge&quot;&gt;dart&lt;/code&gt;在GC之后都会采用滑动压缩的方式来把内存碎片清除掉)，这个过程非常迅速。&lt;/p&gt;

&lt;p&gt;分配给新对象的连续空间由两部分组成。任何时候只使用一半：一半处于活动状态(活动空间)，另一半处于非活动状态(非活动空间)。新生成对象在活动空间那一半中分配，一旦那一半填充完毕，不可回收对象将被从活动空间复制到非活动空间(忽略可被回收的对象)。这样，非活动空间转变变为活动状态，开始为新对象分配内存，并重复该过程。&lt;/p&gt;

&lt;p&gt;要确定哪些对象是否可被回收，收集器将以root对象（例如堆栈变量）开始，并检查它们引用的对象。然后把引用的对象移动到另一半空间。在那里它检查这些移动的对象指向的内容，并移动这些引用的对象。如此反复，直到移动所有活动对象到另一半空间。始终没有被引用的对象将被回收。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_7/50.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;3老年代并行标记和并发扫描&quot;&gt;3、老年代(并行标记和并发扫描)&lt;/h4&gt;

&lt;p&gt;当对象经历过一定次数的GC仍然存在，或者其生命周期较长(个人猜测类似于&lt;code class=&quot;highlighter-rouge&quot;&gt;element&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;RenderObject&lt;/code&gt;这种需要多次复用，可变且创建比较耗费性能)，将其放入老年代区域中。老年代采用标记整理的方法来回收对象。&lt;/p&gt;

&lt;p&gt;这种GC技术有两个阶段：首先遍历对象图，并标记仍在使用的对象。在第二阶段期间，扫描整个存储器，并且回收未标记的任何对象。然后清除所有标志。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_7/51.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在标记的时候，该线程中内存区域是处于不可修改的状态，类似于JVM中&lt;code class=&quot;highlighter-rouge&quot;&gt;stop the world&lt;/code&gt;，所以这个时候可能会导致&lt;code class=&quot;highlighter-rouge&quot;&gt;ANR&lt;/code&gt;(只是类似于&lt;code class=&quot;highlighter-rouge&quot;&gt;ANR&lt;/code&gt;的表现，其产生原因还是不一样的)，但是由于&lt;code class=&quot;highlighter-rouge&quot;&gt;dart&lt;/code&gt;优秀的&lt;code class=&quot;highlighter-rouge&quot;&gt;schedule&lt;/code&gt;机制和老年代GC频率很低的原因，基本上不会出现这个问题。&lt;/p&gt;

&lt;p&gt;需要注意的是，如果APP不支持弱年代假设(即大多数对象的生命期都很短；从年老对象到年轻对象的引用非常少)，上面的分代设计就不那么有效了，但是考虑到Flutter中的&lt;code class=&quot;highlighter-rouge&quot;&gt;Widget&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;Element&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;RenderObject&lt;/code&gt;关系，我们不需要担心这个问题。&lt;/p&gt;

&lt;h4 id=&quot;4根据ioslate特性来优化&quot;&gt;4、根据ioslate特性来优化&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_7/49.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;与JVM内存模型不同的是，&lt;code class=&quot;highlighter-rouge&quot;&gt;dart&lt;/code&gt;中每个&lt;code class=&quot;highlighter-rouge&quot;&gt;isolate&lt;/code&gt;都有自己的独立的堆栈内存空间，其各自的GC不会影响到其他&lt;code class=&quot;highlighter-rouge&quot;&gt;isolate&lt;/code&gt;的。所以我们可以通过把部分占用内存空间较大且生命周期较短的对象方法其他&lt;code class=&quot;highlighter-rouge&quot;&gt;isolate&lt;/code&gt;中，这样即使另外一个&lt;code class=&quot;highlighter-rouge&quot;&gt;isolate&lt;/code&gt; GC了，并不会对我们显示UI的&lt;code class=&quot;highlighter-rouge&quot;&gt;isolate&lt;/code&gt;造成影响。&lt;/p&gt;</content><author><name>Ted</name></author><category term="Flutter" /><summary type="html">一、移动端的内存回收机制</summary></entry><entry><title type="html">Dart异步与并发</title><link href="http://www.helloted.com/flutter/2019/03/18/DartAsync/" rel="alternate" type="text/html" title="Dart异步与并发" /><published>2019-03-18T20:00:00+08:00</published><updated>2019-03-18T20:00:00+08:00</updated><id>http://www.helloted.com/flutter/2019/03/18/DartAsync</id><content type="html" xml:base="http://www.helloted.com/flutter/2019/03/18/DartAsync/">&lt;h3 id=&quot;一异步&quot;&gt;一、异步&lt;/h3&gt;

&lt;h4 id=&quot;1单线程执行&quot;&gt;1、单线程执行&lt;/h4&gt;

&lt;p&gt;Dart是单线程执行，也就是说一旦Dart函数开始执行，就会一直持续直到结束，Dart函数不能被其他Dart代码中断。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意：Dart命令行应用程序可以通过创建isolate来并行运行代码（Dart Web应用程序目前无法创建其他ioslate，但它们可以创建web worker）。&lt;/p&gt;

  &lt;p&gt;isolate不共享内存,它们就像是通过传递消息相互通信的独立应用程序。 除了应用程序明确在其他isolate或工作程序中运行的代码之外，所有应用程序的代码都在应用程序的main isolate中运行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Html5 中的web worker&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;传统页面中（HTML5 之前）的 JavaScript 的运行都是以单线程的方式工作的，虽然有多种方式实现了对多线程的模拟（例如：JavaScript 中的 setinterval 方法，setTimeout 方法等），但是在本质上程序的运行仍然是由 JavaScript 引擎以单线程调度的方式进行的。在 HTML5 中引入的工作线程使得浏览器端的 JavaScript 引擎可以并发地执行 JavaScript 代码，从而实现了对浏览器端多线程编程的良好支持。&lt;/p&gt;

  &lt;p&gt;传统上的线程可以解释为轻量级进程，它和进程一样拥有独立的执行控制，一般情况下由操作系统负责调度。而在 HTML5 中的Web worker是这样一种机制，它允许在 Web 程序中并发执行多个 JavaScript 脚本，每个脚本执行流都称为一个线程，彼此间互相独立，并且有浏览器中的 JavaScript 引擎负责管理。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;2event-loops-and-queues&quot;&gt;2、Event loops and queues&lt;/h4&gt;

&lt;p&gt;Event loops and queues能够确保同时处理多个图形操作或者事件。event loops的工作就是从event queue内拿一个event然后处理它，一直重复这个操作直到queue里全部处理完毕。event queue内的event有可能是用户输入事件、文件I/O通知、timers等等&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_7/45.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如下图，Dart应用程序在其main isolate执行应用程序的main()函数时开始执行。 main()退出后，main isolate的线程开始逐个处理应用程序events queues的项目。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_7/44.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;3event处理步骤&quot;&gt;3、Event处理步骤&lt;/h4&gt;

&lt;p&gt;一个Dart应用程序只有一个event loop，但是有两个Queue：event queue和microtask queue:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Event queue:包含所有的外部事件，I/O、用户交互事件、绘制事件、timers、两个isolates之间的消息等等&lt;/li&gt;
  &lt;li&gt;Microtask queue:存在的必要是因为事件处理代码有时需要稍后完成任务，但在将控制权返回给event loop之前(处理下一个事件之前)。例如，当可观察对象发生更改时，它会将多个突变更改组合在一起并以异步方式报告它们。 Microtask queue允许可观察对象在DOM显示不一致状态之前报告这些突变变化。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Event queue包含来自Dart和系统中其他的事件。 目前，Microtask queue仅包含源自Dart代码的内容。&lt;/p&gt;

&lt;p&gt;如下图所示，当main()退出时，Event loop开始工作。 首先，它按FIFO顺序执行所有microtasks。 然后它出列并处理event queue中的第一项。 然后它重复循环：执行所有microtasks，然后处理event queue中的下一项。 一旦两个队列都为空并且不再需要更多事件，应用程序的embedder（例如浏览器或测试框架）就可以dispose该应用程序。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_7/46.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这就是app运行时一个isolate中的正常运行流程。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;启动app。&lt;/li&gt;
  &lt;li&gt;首先执行main方法。&lt;/li&gt;
  &lt;li&gt;在main方法执行完后，开始处理microtask queue，从中取出microtask执行，直到microtask queue为空。这里可以看到event loop在运行时是优先处理microtask queue的。&lt;/li&gt;
  &lt;li&gt;当microtask queue为空才会开始处理event queue，如果event queue不为空则从中取出一个event执行。这里要注意的是event queue并不会一直遍历完，而是一次取出一个event执行，执行完后就回到前面去重新判断microtask queue是否为空。所以这里可以看到microtask queue存在的一个重要意义是由它的运行时机决定的，当我们想要在处理当前的event之后，并且在处理下一个event之前做一些事情，或者我们想要在处理所有event之前做一些事情，这时候可以将这些事情放到microtask queue中。&lt;/li&gt;
  &lt;li&gt;当microtask queue和event queue都为空时，app可以正常退出。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;注意：当Event Looper正在处理Microtask Queue中的Event时候，Event Queue中的Event就停止了处理了，此时App不能绘制任何图形，不能处理任何鼠标点击，不能处理文件IO等等&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;虽然可以预测task执行的顺序，但您无法准确预测event loop何时将任务从队列中删除。 Dart事件处理系统基于单线程循环; 它不是基于刻度或任何其他类型的时间测量。 例如，在创建延迟任务时，event会在您指定时排队。 但是，直到处理队列中的所有内容（以及Microtask Queue中的每个task）之后，才能处理该事件。&lt;/p&gt;

&lt;h4 id=&quot;4async与await&quot;&gt;4、async与await&lt;/h4&gt;

&lt;p&gt;在Dart中我们可以通过async关键字来声明一个异步方法，异步方法会在调用后立即返回给调用者一个Future对象，而异步方法的方法体将会在后续被执行（应该也是通过协程的方式实现）。在异步方法中可以使用await表达式挂起该异步方法中的某些步骤从而实现等待某步骤完成的目的，await表达式的表达式部分通常是一个Future类型，即在await处挂起后交出代码的执行权限直到该Future完成。在Future完成后将包含在Future内部的数据类型作为整个await表达式的返回值，接着异步方法继续从await表达式挂起点后继续执行&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;async修饰的异步方法需要声明返回一个Future类型，如果方法体内没有主动的返回一个Future类型，系统会将返回值包含到一个Future中返回。&lt;/li&gt;
  &lt;li&gt;await表达式的表达式部分需要返回一个Future对象。&lt;/li&gt;
  &lt;li&gt;await表达式需要在一个async修饰的方法中使用才会生效。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-dart highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;loadData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dataURL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;https://www.test.url&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Response&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dataURL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;setState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;widgets&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;JSON&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;decode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里首先将loadData方法声明为异步方法，然后用await表达式在http.get(dataURL)处挂起等待，http是Dart提供的一个网络请求库。在请求完成时会返回一个Future&lt;http.Response&gt;对象，所以await表达式的表达式部分返回的是一个Future&lt;http.Response&gt;类型，整个await表达式返回的就是一个http.Response类型。接下来通过setState改变一个StatefulWidget的State来触发系统重新调用其build方法更新Widget。&lt;/http.Response&gt;&lt;/http.Response&gt;&lt;/p&gt;

&lt;h4 id=&quot;5调度任务&quot;&gt;5、调度任务&lt;/h4&gt;

&lt;p&gt;调度任务有两种方式&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用Future类，可以将任务加入到Event Queue的队尾&lt;/li&gt;
  &lt;li&gt;使用scheduleMicrotask函数，将任务加入到Microtask Queue队尾&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;选择合适的队列(一般选择event queue):&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;尽可能使用Future在event queue上安排任务。 使用event queue有助于缩短microtask queue的长度，从而降低微microtask queue使event queue匮乏的可能性。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果在处理event queue中的任何项之前绝对必须完成任务，那么通常应该立即执行该函数。 如果不能，则使用scheduleMicrotask()将项添加到microtask queue。 例如，在Web应用程序中使用微任务来避免过早释放js-interop代理或结束IndexedDB事务或事件处理程序。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Future案例&lt;/p&gt;

&lt;div class=&quot;language-dart highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Future&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;futureTask&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//  异步任务的函数&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;futueTask execute result:&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$m&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//   任务执行完后的子任务&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//  其中m为上个任务执行完后的返回的结果&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;printLength&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;whenComplete&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;whenTaskCompelete&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//  当所有任务完成后的回调函数&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;futureTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;21&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; 
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;printLength&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Text Length:&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$length&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;whenTaskCompelete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Task Complete&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;延迟执行&lt;/p&gt;

&lt;div class=&quot;language-dart highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;delayed&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Duration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;seconds:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;futureTask&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//延迟执行1秒，但是除非queue内部是空的，否则不止1秒&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;scheduleMicrotask案例&lt;/p&gt;

&lt;div class=&quot;language-dart highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;async&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;scheduleMicrotask&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;microtask&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;microtask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;//  doing something&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;二isolate&quot;&gt;二、isolate&lt;/h3&gt;

&lt;h4 id=&quot;1isolate&quot;&gt;1、isolate&lt;/h4&gt;

&lt;p&gt;如果要运行计算密集型任务，该怎么办？为了使您的应用程序保持响应，您应该将任务放入其自己的isolates或worker。isolate可能在单独的进程或线程中运行，具体取决于Dart实现(目前来看是在线程中运行)。&lt;/p&gt;

&lt;p&gt;isolate是Dart对actor并发模式的实现。运行中的Dart程序由一个或多个actor组成，这些actor也就是Dart概念里面的isolate。isolate是有自己的内存和单线程控制的运行实体。isolate本身的意思是“隔离”，因为isolate之间的内存在逻辑上是隔离的。isolate中的代码是按顺序执行的，任何Dart程序的并发都是运行多个isolate的结果。因为Dart没有共享内存的并发，没有竞争的可能性所以不需要锁，也就不用担心死锁的问题。&lt;/p&gt;

&lt;h4 id=&quot;2isolate特性&quot;&gt;2、isolate特性&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;isolate是类似于线程(thread)但不共享内存的独立运行的worker，是一个独立的Dart程序执行环境。其实默认环境就是一个main isolate；&lt;/li&gt;
  &lt;li&gt;我们可以看到isolate神似Thread，但实际上两者有本质的区别。操作系统内内的线程之间是可以有共享内存的而isolate没有，这是最为关键的区别。&lt;/li&gt;
  &lt;li&gt;isolate在它自己的event loop中执行代码，每个事件都可以在该isolate的微任务队列(microtask queue)中执行更小的任务。&lt;/li&gt;
  &lt;li&gt;由于isolate之间没有共享内存，所以他们之间的通信唯一方式只能是通过Port进行，而且Dart中的消息传递总是异步的。&lt;/li&gt;
  &lt;li&gt;在Dart语言中，所有的Dart代码都运行在某个isolate中，代码只能使用所属isolate的类和值。不同的isolate可以通过port发送message进行交流；&lt;/li&gt;
  &lt;li&gt;首字母大写的Isolate代表Isolate对象，小写的isolate代表一个独立的Dart代码执行环境。一个Isolate对象就是一个isolate(执行环境)的引用，通常不是当前代码所在的isolate，也就是说，当你使用Isolate对象时，你的目的应该是控制其他isolate，而不是当前的isolate。 当你要spawn(产生)一个新isolate时，如果操作成功，当前isolate会接收到一个代表新isolate的Isolate对象。&lt;/li&gt;
  &lt;li&gt;isolate对象允许其他isolate控制、监听它所代表的isolate的事件循环，例如当这个isolate发生未捕获错误时，可以暂停(pause)此isolate或获取(addErrorListener)错误信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;3使用多少个isolates&quot;&gt;3、使用多少个isolates？&lt;/h4&gt;

&lt;p&gt;对于计算密集型任务，通常应该使用尽可能多的isolate来提供可用的CPUs。如果它们纯粹是计算的话，任何额外的isolate都会被浪费掉。但是，如果isolate执行异步调用 - 例如执行I / O  - 那么它们将不会在CPU上花费太多时间，因此拥有比CPU更多的isolate是有意义的。&lt;/p&gt;

&lt;p&gt;如果这是一个适合您的应用程序的良好架构，您还可以使用比CPU更多的isolate。例如，您可以为每个功能使用单独的isolate，或者在需要确保不共享数据时使用。&lt;/p&gt;

&lt;h4 id=&quot;4jvm-vs-dart-vm&quot;&gt;4、JVM vs Dart VM&lt;/h4&gt;

&lt;p&gt;与JVM内存模型不同的是，&lt;code class=&quot;highlighter-rouge&quot;&gt;dart&lt;/code&gt;中每个&lt;code class=&quot;highlighter-rouge&quot;&gt;isolate&lt;/code&gt;都有自己的独立的堆栈内存空间，其各自的GC不会影响到其他&lt;code class=&quot;highlighter-rouge&quot;&gt;isolate&lt;/code&gt;的。所以我们可以通过把部分占用内存空间较大且生命周期较短的对象方法其他&lt;code class=&quot;highlighter-rouge&quot;&gt;isolate&lt;/code&gt;中，这样即使另外一个&lt;code class=&quot;highlighter-rouge&quot;&gt;isolate&lt;/code&gt; GC了，并不会对我们显示UI的&lt;code class=&quot;highlighter-rouge&quot;&gt;isolate&lt;/code&gt;造成影响。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_7/49.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;5isolate代码示例&quot;&gt;5、isolate代码示例&lt;/h4&gt;

&lt;div class=&quot;language-dart highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'dart:async'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'dart:isolate'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;receivePort&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ReceivePort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Isolate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;spawn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;echo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;receivePort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sendPort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 'echo'发送的第一个message，是它的SendPort&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sendPort&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;receivePort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sendReceive&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sendPort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;foo&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'received &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$msg&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sendReceive&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sendPort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;bar&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'received &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$msg&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;/// 新isolate的入口函数&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;echo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SendPort&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sendPort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 实例化一个ReceivePort 以接收消息&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ReceivePort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 把它的sendPort发送给宿主isolate，以便宿主可以给它发送消息&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;sendPort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sendPort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 监听消息&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;SendPort&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;replyTo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;replyTo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;bar&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;/// 对某个port发送消息，并接收结果&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Future&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sendReceive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SendPort&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;ReceivePort&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ReceivePort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sendPort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;三总结&quot;&gt;三、总结&lt;/h3&gt;

&lt;p&gt;关于event loop:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Dart事件循环执行两个队列里的事件：event队列和microtask队列。&lt;/li&gt;
  &lt;li&gt;event队列的事件来自dart（future，timer，isolate message等）和系统（用户输入，I/O等）。&lt;/li&gt;
  &lt;li&gt;目前为止，microtask队列的事件只来自dart。&lt;/li&gt;
  &lt;li&gt;事件循环会优先清空microtask队列，然后才会去处理event队列。&lt;/li&gt;
  &lt;li&gt;当两个队列都清空后，dart就会退出。&lt;/li&gt;
  &lt;li&gt;main方法，来自event队列和microtask队列的所有事件都运行在Dart的main isolate中。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当你要安排一个task时，请遵守以下规则：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果可以，尽量将任务放入event队列中。&lt;/li&gt;
  &lt;li&gt;使用Future的then方法或whenComplete方法来指定任务顺序。&lt;/li&gt;
  &lt;li&gt;为了保持你app的可响应性，尽量不要将大计算量的任务放入这两个队列。&lt;/li&gt;
  &lt;li&gt;大计算量的任务放入额外的isolate中。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Ted</name></author><category term="Flutter" /><summary type="html">一、异步</summary></entry><entry><title type="html">Flutter基础(三)</title><link href="http://www.helloted.com/flutter/2019/03/11/Flutter_3/" rel="alternate" type="text/html" title="Flutter基础(三)" /><published>2019-03-11T20:00:00+08:00</published><updated>2019-03-11T20:00:00+08:00</updated><id>http://www.helloted.com/flutter/2019/03/11/Flutter_3</id><content type="html" xml:base="http://www.helloted.com/flutter/2019/03/11/Flutter_3/">&lt;h4 id=&quot;1自定义控件&quot;&gt;1、自定义控件&lt;/h4&gt;

&lt;div class=&quot;language-dart highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CustomComponent&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StatefulWidget&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IconData&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;icons&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MaterialColor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;btnName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GestureTapCallback&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;onTap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;CustomComponent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@required&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;icons&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;nd&quot;&gt;@required&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;btnName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;color&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Colors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;grey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;onTap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;

  &lt;span class=&quot;nd&quot;&gt;@override&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;State&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CustomComponent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;createState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CustomComponentState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CustomComponentState&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;State&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CustomComponent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@override&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Widget&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BuildContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GestureDetector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;nl&quot;&gt;child:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;nl&quot;&gt;mainAxisAlignment:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MainAxisAlignment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;center&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;nl&quot;&gt;children:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Widget&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;[&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;Icon&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;widget&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;icons&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;color:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;widget&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;Text&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;widget&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;btnName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;style:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TextStyle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;color:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;widget&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;],&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;),&lt;/span&gt;
      &lt;span class=&quot;nl&quot;&gt;onTap:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;widget&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;onTap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用的时候&lt;/p&gt;

&lt;div class=&quot;language-dart highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;CustomComponent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;icons:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Icons&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;comment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;btnName:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'评论'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;或者换一种定义方式&lt;/p&gt;

&lt;div class=&quot;language-dart highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;CustomComponent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;icons&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;btnName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Colors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;grey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;onTap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用的方式&lt;/p&gt;

&lt;div class=&quot;language-dart highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;CustomComponent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Icons&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;favorite_border&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;'喜欢'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Ted</name></author><category term="Flutter" /><summary type="html">1、自定义控件</summary></entry><entry><title type="html">项目管理PMP考试备考经验</title><link href="http://www.helloted.com/others/2019/01/10/PMP/" rel="alternate" type="text/html" title="项目管理PMP考试备考经验" /><published>2019-01-10T20:00:00+08:00</published><updated>2019-01-10T20:00:00+08:00</updated><id>http://www.helloted.com/others/2019/01/10/PMP</id><content type="html" xml:base="http://www.helloted.com/others/2019/01/10/PMP/">&lt;p&gt;作为一名程序员客户端开发，之所以报考PMP是因为在上家公司从事了项目管理的工作，接触了一些项目管理的知识，感觉项目管理的一些理论对于管理水平提升很有用，所以打算系统的学习一下项目管理并且考取证书。&lt;/p&gt;

&lt;h4 id=&quot;1pmp简介&quot;&gt;1、PMP简介&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;PMP（Project Management Professional）指&lt;a href=&quot;https://baike.baidu.com/item/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E4%B8%93%E4%B8%9A&quot;&gt;项目管理专业&lt;/a&gt;人士（人事）&lt;a href=&quot;https://baike.baidu.com/item/%E8%B5%84%E6%A0%BC%E8%AE%A4%E8%AF%81&quot;&gt;资格认证&lt;/a&gt;。&lt;a href=&quot;https://baike.baidu.com/item/%E7%BE%8E%E5%9B%BD%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%8D%8F%E4%BC%9A&quot;&gt;美国项目管理协会&lt;/a&gt;（PMI）举办的项目管理专业人员（PMP）认证考试在全球190多个国家和地区推广，是目前项目管理领域含金量最高的认证。获取PMP证书，不仅提升项目经理的项目管理水平，也直接体现项目经理的个人竞争力，是项目管理专业人士身份的象征。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;以上来自百度百科，简单来说PMP就是项目管理的一个资质认证。&lt;/p&gt;

&lt;h4 id=&quot;2考试简介&quot;&gt;2、考试简介&lt;/h4&gt;

&lt;p&gt;报名条件：报名考生必须具备35小时以上项目管理&lt;a href=&quot;https://baike.baidu.com/item/PMBOK&quot;&gt;PMBOK&lt;/a&gt;学习或培训经历。就跟驾照考试一样，是要有一个培训机构来帮忙。&lt;/p&gt;

&lt;p&gt;PMP考试报名：要在PMI的官方网站上，填写之前工作的一些项目管理经验，全英文的，有点麻烦，另外有10%的几率会被抽中审查，据说抽中审查之后要邮寄资料到美国去审核。。。祝好运&lt;/p&gt;

&lt;p&gt;考试安排：PMP考试在国内一年开展四次，分别在每年的3月、6月、9月和12月，一般会选择一个周六的上午来考试。由国家外国专家局培训中心负责组织实施。&lt;/p&gt;

&lt;p&gt;考点：深圳有罗湖和龙岗考点，报名满即截止，建议在开放报名的凌晨0点之后就抓紧在网上选考场，我就是在早上9点之后才选考场，结果罗湖以及没有名额，只好选择龙岗，提前一晚去那边住宿。浪费时间和精力。&lt;/p&gt;

&lt;h4 id=&quot;3考试内容&quot;&gt;3、考试内容&lt;/h4&gt;

&lt;p&gt;PMP考试内容主要包括项目管理五个过程：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;过程组&lt;/th&gt;
      &lt;th&gt;内容&lt;/th&gt;
      &lt;th&gt;百分比&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;启动&lt;/td&gt;
      &lt;td&gt;确立一个项目或一个项目阶段。&lt;/td&gt;
      &lt;td&gt;13%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;规划&lt;/td&gt;
      &lt;td&gt;为完成项目，制定和维护一个可操作的计划。&lt;/td&gt;
      &lt;td&gt;24%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;执行&lt;/td&gt;
      &lt;td&gt;协调人力和其他资源以执行计划&lt;/td&gt;
      &lt;td&gt;30%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;监控&lt;/td&gt;
      &lt;td&gt;通过监控和进度测量及必要时采取纠正措施以确保项目目标的实现。&lt;/td&gt;
      &lt;td&gt;25%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;收尾&lt;/td&gt;
      &lt;td&gt;正式验收项目或项目阶段并使其有条不紊地圆满结束&lt;/td&gt;
      &lt;td&gt;8%&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;4pmp考题&quot;&gt;4、PMP考题&lt;/h4&gt;

&lt;p&gt;PMP考试是由200道情景选择题，从09:00到13:00四个小时不间断考试，在考后一个月左右出成绩。考试题目是由中英文组成，一道英文题，对应有一个翻译后的中文题，所以有些概念如果理解不准可以直接看英文来作答。&lt;/p&gt;

&lt;p&gt;200道题目装订成一个小册子，为防止作弊，分为ABCDEF六个类型，每个类型的题目一样，但是题目排序不一样。&lt;/p&gt;

&lt;p&gt;考题样式：单项选择题&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;1、&lt;/strong&gt;某长期项目己在A公司开展了近两年，项目因发生延迟，需额外增加一年方能完工，此时B公司收购了公司A。B公司的新产品系列和战略计划并不包括本项目的预期产品成果。项目经理应该怎么做？
A．继续项目直至产品完成，之后做出关闭项目决定
B．向董事会提交该项目，请求将项目产品纳入公司产品
C．立即解散所有资源，因为项目即将关闭
D．根据正式决策终止，并记录项目&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;5考试成绩&quot;&gt;5、考试成绩&lt;/h4&gt;

&lt;p&gt;在考试后一个月左右会收到可以查询成绩的邮件，登录PMI官网可以查询成绩。&lt;/p&gt;

&lt;p&gt;200道题目，60%正确率为通过，PMI会抽取20道题目(正确率过低或过高的题目)为无效，剩余的180道题目里面要做对180*0.6=108道题目，所以，理论上来说，要做对128道题目就能确保一定可以通过考试。&lt;/p&gt;

&lt;p&gt;这个是我的成绩单：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_8/64.jpeg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到，不会提供具体成绩，只有一个PASS以及每个过程组的排布。俗称的5A就是5个过程组都是Above Target。&lt;/p&gt;

&lt;h4 id=&quot;6备考经验&quot;&gt;6、备考经验&lt;/h4&gt;

&lt;p&gt;有一本官方教材《项目管理知识体系指南》，将近800页，是英译中翻译版。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_8/65.jpeg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看了很多前辈的经验，以及培训班老师的说明，都是说需要把这本教材看至少两遍以上，考试通过可能性比较大。我拿到书后，看了一章感觉官方教材过于晦涩难懂，所以就果断放弃了通读教材这条路线。转而购买了一本教材辅导书《汪博士解读PMP考试》以及一本习题册《汪博士详解PMP模拟题》准备走题目路线。（辅导书个人感觉质量一般，但是好在相比于教材提炼了一些知识点，有利于我预习，未读过其他教材，不知道效果咋样）。&lt;/p&gt;

&lt;p&gt;在参加了培训班之后，每个礼拜周末参加一天的课程，持续6个周末。&lt;/p&gt;

&lt;p&gt;我的备考路线是：紧跟培训班老师的节奏，在周末上课之前，概览一下教材参考书和老师的讲义(实际上就是上课的PPT打印)，对周末要讲解的内容做到心中有数，大概知道知识难点和重点，在上课的时候认真听课，争取在课堂上就对所有的知识点理解透彻。以及在讲义上做好课堂笔记，而在上课之后，充分利用模拟题那本书进行知识点查缺补漏。每个礼拜花的时间也不多，课前二个小时，课后三四个小时，预习+听课+复习，基本上能够把知识点理解并且有一定的印象。&lt;/p&gt;

&lt;p&gt;考前一个月，培训机构会发模拟题，这个模拟题实际上是历次考试的真题，由考生考后回忆整理得到，含金量极高(PMP没有官方题库这一说法)，所以要充分利用好这些模拟真题。两套题目，我都做了两遍。并且建议抽时间，从头到尾做一次，模拟一下考试，也体验一下四个小时的考试过程。&lt;/p&gt;

&lt;p&gt;在做题的过程中，重点是总结题目的一些思路，培养出题感，在我们中学读书阶段都会有一些经验，不再赘述。&lt;/p&gt;

&lt;p&gt;在考试当天，因为对于真题已经比较适应，整个考试过程比较轻松，提前半个小时做完题目并且涂好答题卡。&lt;/p&gt;

&lt;p&gt;以上，便是我2018年12月份的PMP备考路线，如果不喜欢官方教材，也可以选择走”题海“路线，整个备考过程，大概做了2000+题目。&lt;/p&gt;

&lt;h4 id=&quot;7考后感想&quot;&gt;7、考后感想&lt;/h4&gt;

&lt;p&gt;我本身是研发岗位，PMP证书对于我的平时工作，可以说是没有什么直接的加分效果。但是在备考PMP的过程中，系统地学习了项目管理的理论知识，加上之前的一些项目管理经验，可以说是对于项目管理有一个比较深的认识，而项目管理的5个过程组，启动、规划、执行、监控、收尾。对于平时工作的也有一个指导作用，在生活上也是贯穿其中。所以，于证书的价值而言，虽然于研发岗位没有直接作用，但是项目管理的知识更为重要，能够很好地扩大知识领域以及提高管理能力。&lt;/p&gt;

&lt;p&gt;总结：备考PMP，项目启动于2018年8月，中间花费近6千元左右(培训费+考试费)，6个休息日，另有50+的学时，结束于2018年12月，取得4A+成绩，PMP证书一份。&lt;/p&gt;</content><author><name>Ted</name></author><category term="Others" /><summary type="html">作为一名程序员客户端开发，之所以报考PMP是因为在上家公司从事了项目管理的工作，接触了一些项目管理的知识，感觉项目管理的一些理论对于管理水平提升很有用，所以打算系统的学习一下项目管理并且考取证书。</summary></entry><entry><title type="html">iOS编码建议</title><link href="http://www.helloted.com/ios/2019/01/02/code/" rel="alternate" type="text/html" title="iOS编码建议" /><published>2019-01-02T20:00:00+08:00</published><updated>2019-01-02T20:00:00+08:00</updated><id>http://www.helloted.com/ios/2019/01/02/code</id><content type="html" xml:base="http://www.helloted.com/ios/2019/01/02/code/">&lt;h4 id=&quot;一viewcontroller代码结构&quot;&gt;一、ViewController代码结构&lt;/h4&gt;

&lt;p&gt;在函数分组和protocol/delegate实现中使用&lt;code class=&quot;highlighter-rouge&quot;&gt;#pragma mark -&lt;/code&gt;来分类方法，遵循以下结构：&lt;/p&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;c1&quot;&gt;// 生命周期&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#pragma mark - Lifecycle
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;instancetype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;init&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;awakeFromNib&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loadView&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;viewDidLoad&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;viewWillAppear&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BOOL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;animated&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;viewWillLayoutSubviews&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;viewDidLayoutSubviews&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;viewDidAppear&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BOOL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;animated&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;viewWillDisappear&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BOOL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;animated&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;viewDidDisappear&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BOOL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;animated&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dealloc&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;didReceiveMemoryWarning&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;


&lt;span class=&quot;c1&quot;&gt;// 如果是Storyboard/Xib&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#pragma mark - IBActions
&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IBAction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sendBtnClicked&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 公开方法&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#pragma mark - Public
&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;publicMethod&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 私有方法&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#pragma mark - Private
&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;privateMethod&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 各种代理和协议方法&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#pragma mark - Protocol
#pragma mark - UITextFieldDelegate
#pragma mark - UITableViewDataSource
#pragma mark - UITableViewDelegate
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 懒加载的Getter&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#pragma mark - Getter &amp;amp;&amp;amp; Setter
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Copy协议和description较少&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#pragma mark - NSCopying/NSObject
&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;copyWithZone&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSZone&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zone&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;description&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;二命名&quot;&gt;二、命名&lt;/h4&gt;

&lt;p&gt;1、变量和方法名：驼峰命名；&lt;/p&gt;

&lt;p&gt;2、宏和常量命名&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;#define&lt;/code&gt; 预处理定义的常量全部大写，单词间用 _ 分隔&lt;/p&gt;

    &lt;p&gt;例子: #define THIS_IS_AN_MACRO @”THIS_IS_AN_MACRO”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;宏定义的本质是在编译时进行替换，所以宏定义中如果包含表达式或变量，表达式或变量必须用小括号括起来，防止与其他变量出现混合的情况。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3、枚举：枚举类型参考系统应该写全类型：名称+类型&lt;/p&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;NS_ENUM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSInteger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UIViewAnimationTransition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;UIViewAnimationTransitionNone&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;UIViewAnimationTransitionFlipFromLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;UIViewAnimationTransitionFlipFromRight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;UIViewAnimationTransitionCurlUp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;UIViewAnimationTransitionCurlDown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当在switch使用枚举类型时，’default’是不需要的&lt;/p&gt;

&lt;p&gt;4、类的命名：　&lt;/p&gt;

&lt;p&gt;ViewController: 使用ViewController做后缀，例子: XXHomeViewController&lt;/p&gt;

&lt;p&gt;View: 使用View做后缀，例子: XXAlertView&lt;/p&gt;

&lt;p&gt;UITableCell:使用Cell做后缀，例子: XXNewsCell&lt;/p&gt;

&lt;p&gt;Protocol: 使用Delegate或者DataSource作为后缀，例子: UITableViewDelegate&lt;/p&gt;

&lt;p&gt;UI控件依次类推&lt;/p&gt;

&lt;h4 id=&quot;三编码&quot;&gt;三、编码&lt;/h4&gt;

&lt;h4 id=&quot;1字面编码&quot;&gt;1、字面编码&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSString&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;NSDictionary&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;NSArray&lt;/code&gt;, 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;NSNumber&lt;/code&gt;可以在创建不可变值时使用，注意不要传nil值，否则会崩溃。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSArray *names = @[@&quot;Brian&quot;, @&quot;Matt&quot;, @&quot;Chris&quot;, @&quot;Alex&quot;, @&quot;Steve&quot;, @&quot;Paul&quot;];
NSDictionary *productManagers = @{@&quot;iPhone&quot;: @&quot;Kate&quot;, @&quot;iPad&quot;: @&quot;Kamal&quot;, @&quot;Mobile Web&quot;: @&quot;Bill&quot;};
NSNumber *shouldUseLiterals = @YES;
NSNumber *buildingStreetNumber = @10018;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;2条件语句&quot;&gt;2、条件语句&lt;/h4&gt;

&lt;p&gt;条件语句主体为了防止出错应该使用大括号包围，即使条件语句主体能够不用大括号编写(如，只用一行代码)。这些错误包括添加第二行代码和期望它成为if语句；还有，可能发生在if语句里面一行代码被注释了，然后下一行代码不知不觉地成为if语句的一部分。除此之外，这种风格与其他条件语句的风格保持一致，所以更加容易阅读。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 应该
if (!error) {
  return success;
}

// 而不是
if (!error)
  return success;
// 或者
if (!error) return success;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;3构造方法init方法&quot;&gt;3、构造方法/init方法&lt;/h4&gt;

&lt;p&gt;当构造方法被使用时，虽然用id也可以通过编译，但它应该返回类型是&lt;code class=&quot;highlighter-rouge&quot;&gt;instancetype&lt;/code&gt;而不是&lt;code class=&quot;highlighter-rouge&quot;&gt;id&lt;/code&gt;。这样确保编译器正确地推断结果类型。&lt;/p&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;instancetype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;init&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;四变量和属性&quot;&gt;四、变量和属性&lt;/h4&gt;

&lt;p&gt;建议使用属性而不是实例变量。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐:&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RWTTutorial&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NSObject&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tutorialName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
    
&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tutorialName&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;不推荐:&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RWTTutorial&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NSObject&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tutorialName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tutorialName&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;属性会自动有Setter和Getter，可以通过直接用点语法访问Setter和Getter方法。&lt;/li&gt;
  &lt;li&gt;虽然&lt;img src=&quot;https://www.zhihu.com/equation?tex=%2A.&quot; alt=&quot;*.&quot; /&gt; 和 -&amp;gt;是等价的，或者说编译器优化后等价。但是在访问空指针和野指针时有差别——空指针会挂在*解引用，野指针会挂在.访问内存。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;五常量&quot;&gt;五、常量&lt;/h4&gt;

&lt;p&gt;共享一块内存空间，就算项目中N处用到，也不会分配N块内存空间，可以根据const修饰的位置设定能否修改，在编译阶段会执行类型检查&lt;/p&gt;

&lt;p&gt;推荐使用const来定义常量，如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSString *const kWEGMomentTopicNumberUpdateNotification = @&quot;kWEGMomentTopicNumberUpdateNotification&quot;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;const不能满足的情况再考虑使用宏定义&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define kWEGMomentTopicNumberUpdateNotification @&quot;kWEGMomentTopicNumberUpdateNotification&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果是需要外部共享，使用extern关键字，参考苹果官方&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;extern NSString * const UIApplicationDidEnterBackgroundNotification  
extern NSString * const UIApplicationWillEnterForegroundNotification  
extern NSString * const UIApplicationDidFinishLaunchingNotification;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;六整体架构&quot;&gt;六、整体架构&lt;/h4&gt;

&lt;p&gt;推荐MVC+VM(也叫MVCS，S是Store的意思，数据处理逻辑)。&lt;/p&gt;

&lt;p&gt;MVC+VM：MVC是苹果官方推荐，V专注于视图构建，Model是瘦Model，专注于模型构建，仅持有数据；数据流动全部由Controller来传递，流向清晰，当Controller变复杂时，将数据处理逻辑剥离出来成为VM，模型数据流向仍由Controller负责，优点是数据流向清晰，业务耦合弱，缺点是不同Controller可能要生成各种不同VM适配。&lt;/p&gt;

&lt;p&gt;MVVM：主要优点数据绑定，做到数据一致性，同时也能做到给Controller瘦身目的，缺点是数据绑定导致数据流向不清晰，难以调试Bug，如果没有详细清晰文档，很可能成为一个天坑(助手里的聊天模块)。&lt;/p&gt;

&lt;p&gt;MVP：Presenter与Controller相互持有，通过接口，P层拥有了Controller的权利，所有的业务分配都在P层内完成，包括像tableView的数据源和代理。优点是MVC解耦，MVC成为平行；缺点是，有点特意为了解耦而解耦，初看会莫名其妙。&lt;/p&gt;

&lt;p&gt;一份分享&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/sources/PDF/learn_list.pdf&quot;&gt;Android代码整洁&lt;/a&gt;&lt;/p&gt;</content><author><name>Ted</name></author><category term="iOS" /><summary type="html">一、ViewController代码结构</summary></entry><entry><title type="html">Flutter与Native(二)</title><link href="http://www.helloted.com/flutter/2018/12/25/HybridFlutter-2/" rel="alternate" type="text/html" title="Flutter与Native(二)" /><published>2018-12-25T20:00:00+08:00</published><updated>2018-12-25T20:00:00+08:00</updated><id>http://www.helloted.com/flutter/2018/12/25/HybridFlutter-2</id><content type="html" xml:base="http://www.helloted.com/flutter/2018/12/25/HybridFlutter-2/">&lt;h3 id=&quot;一native切换到flutter&quot;&gt;一、Native切换到Flutter&lt;/h3&gt;

&lt;h4 id=&quot;1ios&quot;&gt;1、iOS&lt;/h4&gt;

&lt;p&gt;在iOS中，Flutter的Framework中，提供了一个FlutterViewController来切换到Flutter页面&lt;/p&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FlutterViewController&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UIViewController&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FlutterBinaryMessenger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FlutterTextureRegistry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FlutterPluginRegistry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看到FlutterViewController是继承自UIViewController，然后遵循了一些Flutter的相关协议。所以我们可以像正常使用UIViewController一样来使用Flutter页面&lt;/p&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#import &amp;lt;Flutter/Flutter.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;FlutterViewController&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flutterViewController&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FlutterViewController&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flutterViewController&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setInitialRoute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;initRoute&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;2andorid&quot;&gt;2、Andorid&lt;/h4&gt;

&lt;p&gt;在Android中，Flutter提供了一个FluttreView来显示一部分&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;View&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flutterView&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Flutter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;createView&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MainActivity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getLifecycle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;initRoute&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;也提供了一个FlutterActivity：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;FlutterMain&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;startInitialization&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MainActivity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Intent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;intent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Intent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MainActivity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FlutterActivity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;intent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;putExtra&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;route&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;initRoute&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;MainActivity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;startActivity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;intent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用Activity之前首先在&lt;code class=&quot;highlighter-rouge&quot;&gt;AndroidManifest.xml&lt;/code&gt;注册&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;activity&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;android:name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;io.flutter.app.FlutterActivity&quot;&lt;/span&gt;
 &lt;span class=&quot;na&quot;&gt;android:configChanges=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;orientation|keyboardHidden|keyboard|screenSize|locale|layoutDirection|fontScale|screenLayout|density&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;android:hardwareAccelerated=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;true&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;android:windowSoftInputMode=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;adjustResize&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;android:exported=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;meta-data&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;io.flutter.app.android.SplashScreenUntilFirstFrame&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;true&quot;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/activity&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;3flutter&quot;&gt;3、Flutter&lt;/h4&gt;

&lt;p&gt;注意到在iOS和Android初始化时，都会传入一个值”initRoute”，这个就是Flutter初始化选择的页面，在Flutter中可以通过&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ui.window.defaultRouteName&lt;/code&gt;来获取到，Dart中文档也写的很清楚：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_8/60.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果没有被设置，将会默认是”/”&lt;/li&gt;
  &lt;li&gt;必须在runApp之前就赋好值&lt;/li&gt;
  &lt;li&gt;iOS调用的是[&lt;code class=&quot;highlighter-rouge&quot;&gt;FlutterViewController.setInitialRoute&lt;/code&gt;]&lt;/li&gt;
  &lt;li&gt;Android代码中调用的是&lt;code class=&quot;highlighter-rouge&quot;&gt;FlutterView.setInitialRoute&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以，在Flutter的初始化页面：&lt;/p&gt;

&lt;div class=&quot;language-dart highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// ui.window.defaultRouteName是Native端初始化时传来的route&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;runApp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_widgetForRoute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ui&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;defaultRouteName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 根据route跳转不同界面&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Widget&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;_widgetForRoute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;route&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;route&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'initRoute'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;initWidget&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'home'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DefaultWidget&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DefaultWidget&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;二ios与flutter交互&quot;&gt;二、iOS与Flutter交互&lt;/h3&gt;

&lt;h4 id=&quot;1flutter传值native&quot;&gt;1、Flutter传值Native&lt;/h4&gt;

&lt;p&gt;我们要借助FlutterMethodChannel来传递消息&lt;/p&gt;

&lt;p&gt;在iOS Native端初始化：&lt;/p&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;c1&quot;&gt;// 要与main.dart中一致&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;channelName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;@&quot;com.pages.your/native_get&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;FlutterMethodChannel&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;messageChannel&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FlutterMethodChannel&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;methodChannelWithName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;channelName&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;binaryMessenger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flutterViewController&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;FlutterMethodChannel初始化时，要传入两个参数channelName和flutterViewController，channelName是消息通道的名称，这个是唯一的要与dart的channel保持一致，flutterViewController则是Flutter的VC；&lt;/p&gt;

&lt;p&gt;messageChannel通过回调Block的方式来与Flutter端进行交互。&lt;/p&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;messageChannel&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setMethodCallHandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FlutterMethodCall&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Nonnull&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FlutterResult&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;_Nonnull&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;FlutterMethodCall * _Nonnull call&lt;/code&gt;用于接受Flutter端传递的数据，&lt;code class=&quot;highlighter-rouge&quot;&gt;FlutterResult  _Nonnull result&lt;/code&gt;用于返回Flutter端数据&lt;/p&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// methodChannel保持与Native端一致&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;methodChannel&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MethodChannel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;com&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;your&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;native_get&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;_contactWithNative&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dynamic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;code&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;200&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;data&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]};&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;dynamic&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//result是Native端传递过来的结果，异步得到。&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;methodChannel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;invokeMethod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flutter_method&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PlatformException&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;error&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中，&lt;code class=&quot;highlighter-rouge&quot;&gt;methodChannel.invokeMethod('flutter_method', map)&lt;/code&gt;对应于Native端的&lt;code class=&quot;highlighter-rouge&quot;&gt;FlutterMethodCall * _Nonnull call&lt;/code&gt;，第一个参数为方法名，对应&lt;code class=&quot;highlighter-rouge&quot;&gt;call.method&lt;/code&gt;，必须为字符串类型；第二个参数为要传递给Native的参数，对应iOS端的&lt;code class=&quot;highlighter-rouge&quot;&gt;call.arguments&lt;/code&gt;可以为基础类型，其中基础类型对应为&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Flutter&lt;/th&gt;
      &lt;th&gt;iOS&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;String&lt;/td&gt;
      &lt;td&gt;NSString&lt;/td&gt;
      &lt;td&gt;字符串类型&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;数值类型&lt;/td&gt;
      &lt;td&gt;NSNumber&lt;/td&gt;
      &lt;td&gt;数值类型&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Map&lt;/td&gt;
      &lt;td&gt;NSDictionary&lt;/td&gt;
      &lt;td&gt;key/Value&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;所以在iOS端，我们可以这样回调&lt;/p&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;messageChannel&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setMethodCallHandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FlutterMethodCall&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Nonnull&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FlutterResult&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;_Nonnull&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// call.method 获取 flutter 给回到的方法名，要匹配到 channelName 对应的多个 发送方法名，一般需要判断区分&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// call.arguments 获取到 flutter 给到的参数，（比如跳转到另一个页面所需要参数）&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// result 是给flutter的回调， 该回调只能使用一次&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;NSLog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;method=%@ &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;arguments = %@&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;method&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arguments&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isEqualToString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;iOSFlutter1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;NSDictionary&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dic&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arguments&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;NSLog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;arguments = %@&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;NSDictionary&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;@{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;key&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;从map里获取到的数据&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
            
            &lt;span class=&quot;c1&quot;&gt;// 给Flutter回传结果,这个block只能调用一次才有效&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果要多次从Native回调给Flutter，就需要通过&lt;code class=&quot;highlighter-rouge&quot;&gt;EventChannel&lt;/code&gt;来实现了&lt;/p&gt;

&lt;h4 id=&quot;2native传值到flutter&quot;&gt;2、Native传值到Flutter&lt;/h4&gt;

&lt;p&gt;在iOS端：&lt;/p&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;n&quot;&gt;FlutterViewController&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flutterViewController&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FlutterViewController&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flutterViewController&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setInitialRoute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;iOSSendToFlutter&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;flutterViewController&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;title&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;@&quot;Native传值到Flutter&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;navigationController&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pushViewController&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flutterViewController&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;animated&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;YES&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    
    &lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;channelName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;@&quot;com.pages.your/native_post&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;FlutterEventChannel&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;evenChannal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FlutterEventChannel&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;eventChannelWithName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;channelName&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;binaryMessenger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flutterViewController&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;evenChannal&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setStreamHandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;设置代理&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#pragma mark - &amp;lt;FlutterStreamHandler&amp;gt;
// Flutter端开始监听这个channel时的回调，第二个参数 EventSink是用来传数据的载体。
- (FlutterError* _Nullable)onListenWithArguments:(id _Nullable)arguments eventSink:(FlutterEventSink)events {
	NSLog(@&quot;Flutter开始接受数据并发来参数:%@&quot;,arguments);
    // 用一个实例来指向，这样就可以多次调用
    self.flutterEvents = events;
    return nil;
}

// flutter不再接收
- (FlutterError* _Nullable)onCancelWithArguments:(id _Nullable)arguments {
    NSLog(@&quot;Flutter停止接受并发来参数:%@&quot;,arguments);
    return nil;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样就可以给Flutter端传递数据了&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;self.flutterEvents(@&quot;给flutter传递的数据&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;下面是Dart的代码&lt;/p&gt;

&lt;div class=&quot;language-dart highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;c1&quot;&gt;// 注册一个通知&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EventChannel&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eventChannel&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EventChannel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'com.pages.your/native_post'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  
  &lt;span class=&quot;c1&quot;&gt;// 向iOS端发送一个参数123456789并且开始接收native的广播来传递数据&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;eventChannel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;receiveBroadcastStream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;123456789&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;listen&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_onEvent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;onError:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_onError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 回调事件&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_onEvent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;setState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;c1&quot;&gt;//从iOS端接受的数据&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;receive&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  
  &lt;span class=&quot;c1&quot;&gt;// 错误返回&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_onError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;三android&quot;&gt;三、android&lt;/h3&gt;

&lt;h4 id=&quot;1flutter传值native-1&quot;&gt;1、Flutter传值Native&lt;/h4&gt;

&lt;p&gt;通过注册MethodChannel来达到传递的目的&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;c1&quot;&gt;// 自定义插件&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;MethodChannel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flutterView&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ChannelName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setMethodCallHandler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MethodCallHandler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; 	&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onMethodCall&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MethodCall&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MethodChannel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Result&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            	&lt;span class=&quot;c1&quot;&gt;// 传递过来的方法名称和参数&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;Log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;LOGTAG_D&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;method&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;Log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;LOGTAG_D&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;arguments&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
				
				&lt;span class=&quot;c1&quot;&gt;// 返回值给Flutter&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;success&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;messageReturnToFlutter&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;要传入两个参数：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;flutterView&lt;/code&gt;：如果是FlutterActivity的话用来获取getFlutterView()；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ChannelName&lt;/code&gt;：通道的名称，与Flutter端保持一致&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2native传值到flutter-1&quot;&gt;2、Native传值到Flutter&lt;/h4&gt;

&lt;p&gt;通过注册EventChannel来达到Native主动传值到Flutter的目的&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EventChannel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flutterView&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ChannelName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setStreamHandler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EventChannel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;StreamHandler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 这个onListen是Flutter端开始监听这个channel时的回调，第二个参数 EventSink是用来传数据的载体。&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// arguments是Flutter发送过来的一个对象，可认为是标记&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// events是用来给Flutter传递数据的载体&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onListen&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arguments&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EventChannel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;EventSink&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;events&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;Log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;LOGTAG_D&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arguments&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;myEvents&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;success&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;给flutter发送的数据&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onCancel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arguments&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// Flutter不再接收&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Dart的代码参见上面iOS部分文章&lt;/p&gt;

&lt;h3 id=&quot;四总结&quot;&gt;四、总结&lt;/h3&gt;

&lt;p&gt;Android与iOS一样，是通过两种不同类型的channel来达到Native与Flutter交互的效果。channel是Native与Flutter进行交互的通道，所以必须要注意的是，保持Native端与Flutter两端的ChannelName一致。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Flutter传值Native：Native端通过call的method/methodName来进行区分不同的调用，而传递的对象可以是基础数据，会有一个result一次性的返回参数。&lt;/li&gt;
  &lt;li&gt;Native传值Fluuter：在建立通道之后，可以通过arguments对象来区分通道，并且通过events作为载体来多次传递数据。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Ted</name></author><category term="Flutter" /><summary type="html">一、Native切换到Flutter</summary></entry><entry><title type="html">Flutter与Native(一)</title><link href="http://www.helloted.com/flutter/2018/12/20/HybridFlutter-1/" rel="alternate" type="text/html" title="Flutter与Native(一)" /><published>2018-12-20T20:00:00+08:00</published><updated>2018-12-20T20:00:00+08:00</updated><id>http://www.helloted.com/flutter/2018/12/20/HybridFlutter-1</id><content type="html" xml:base="http://www.helloted.com/flutter/2018/12/20/HybridFlutter-1/">&lt;h3 id=&quot;一初始项目&quot;&gt;一、初始项目&lt;/h3&gt;

&lt;h4 id=&quot;1现有目录&quot;&gt;1、现有目录&lt;/h4&gt;

&lt;p&gt;现有一个最简单的iOS项目MyApp，将iOS项目和Android项目分别放入放入HybridApp文件夹中，目录结构如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;HybridApp
├── Android
	└── AndroidProject
└── iOS
    └── MyApp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;2建立flutter模块&quot;&gt;2、建立Flutter模块&lt;/h4&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;flutter create &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; module xxx
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在HybridApp文件夹的根目录执行以下命令&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;HybridApp
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;flutter create &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; module flutter_module
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;现在目录变成&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;HybridApp
├── Android              //android相关
	└── AndroidProject   //android项目
├── flutter_module       //flutter相关
└── iOS					 // iOS相关
    └── MyApp			 // iOS项目
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_8/44.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;二ios接入&quot;&gt;二、iOS接入&lt;/h3&gt;

&lt;h4 id=&quot;1将flutter的相关信息导入ios项目&quot;&gt;1、将flutter的相关信息导入iOS项目&lt;/h4&gt;

&lt;p&gt;更新，新版本接入，通过cocoapod比较简单&lt;/p&gt;

&lt;p&gt;在PodFile内加入：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;platform :ios, '10.0'

target &quot;NewHybrid&quot; do

flutter_application_path = '../flutter_module'
eval(File.read(File.join(flutter_application_path, '.ios', 'Flutter', 'podhelper.rb')), binding)


end

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;==================================👇为旧版本接入=======================&lt;/p&gt;

&lt;p&gt;在flutter_module目录下有个.iOS的隐藏文件夹，里面有个文件Flutter/Generated.xcconfig，查看可以看到里面有一些flutter的信息&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_8/45.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们需要将将这个文件里的一些信息导入到iOS项目中，做法如下：&lt;/p&gt;

&lt;p&gt;==&amp;gt;新建一个FlutterDebug.config的文件，&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_8/46.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;内容为导入Generated.xcconfig文件路径：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &quot;../../flutter_module/.ios/Flutter/Generated.xcconfig&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_8/47.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;==&amp;gt;将FlutterDebug.xcconfig添加到iOS项目的Info-Configuration里：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_8/48.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;2添加脚本&quot;&gt;2、添加脚本&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;$FLUTTER_ROOT/packages/flutter_tools/bin/xcode_backend.sh&quot; build
&quot;$FLUTTER_ROOT/packages/flutter_tools/bin/xcode_backend.sh&quot; embed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_8/49.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意将Run Scrpt移到列表的前方&lt;/p&gt;

&lt;p&gt;运行项目，在iOS项目文件夹内会生成一个Flutter的文件夹，将这个文件夹添加到项目中&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_8/50.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_8/51.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;3改造appdelegate&quot;&gt;3、改造AppDelegate&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;AppDelegate.h

#import &amp;lt;UIKit/UIKit.h&amp;gt;
#import &amp;lt;Flutter/Flutter.h&amp;gt;

@interface AppDelegate : FlutterAppDelegate
@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;AppDelegate.m

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    return [super application:application didFinishLaunchingWithOptions:launchOptions];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;4新建一个flutter页面&quot;&gt;4、新建一个Flutter页面&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_8/53.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面是效果&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_8/52.gif&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;三安卓接入&quot;&gt;三、安卓接入&lt;/h3&gt;

&lt;h4 id=&quot;1配置&quot;&gt;1、配置&lt;/h4&gt;

&lt;p&gt;在setting.gradle中添加：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//加入下面配置
setBinding(new Binding([gradle: this]))
evaluate(new File(
        settingsDir.parentFile.parentFile,
        'flutter_module/.android/include_flutter.groovy'  //flutter_module路径
))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_8/55.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在bulid.gradle中dependencies添加&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;implementation project(':flutter')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Gradle sync之后就成功导入了Flutter&lt;/p&gt;

&lt;h4 id=&quot;2使用&quot;&gt;2、使用&lt;/h4&gt;

&lt;p&gt;在iOS中，Flutter是以一整个页面ViewController的方式接入到Native中，而在android中，Flutter既可以在现有Activity内插入一个FlutterView作为一部分，也可以直接继承自一个FlutterActivity.&lt;/p&gt;

&lt;p&gt;作为一部分接入View&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;View&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flutterView&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Flutter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;createView&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MainActivity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getLifecycle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;route1&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;FrameLayout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;LayoutParams&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;layout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FrameLayout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;LayoutParams&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;600&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;800&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;layout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;leftMargin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;layout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;topMargin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;addContentView&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flutterView&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;layout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_8/56.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;或者Activity形式&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;FlutterMain&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;startInitialization&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MainActivity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Intent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;intent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Intent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MainActivity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FlutterActivity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;intent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;putExtra&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;route&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;initRoute&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;MainActivity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;startActivity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;intent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_8/57.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;</content><author><name>Ted</name></author><category term="Flutter" /><summary type="html">一、初始项目</summary></entry></feed>