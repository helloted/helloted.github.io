<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.5.1">Jekyll</generator><link href="http://www.helloted.com/feed.xml" rel="self" type="application/atom+xml" /><link href="http://www.helloted.com/" rel="alternate" type="text/html" /><updated>2017-11-23T14:30:23+08:00</updated><id>http://www.helloted.com/</id><title type="html">Helloted Blog</title><subtitle>Write your site description here. It will be used as your sites meta description as well!</subtitle><entry><title type="html">iOS进程/线程间通信</title><link href="http://www.helloted.com/2017/10/26/thread_message/" rel="alternate" type="text/html" title="iOS进程/线程间通信" /><published>2017-10-26T20:00:00+08:00</published><updated>2017-10-26T20:00:00+08:00</updated><id>http://www.helloted.com/2017/10/26/thread_message</id><content type="html" xml:base="http://www.helloted.com/2017/10/26/thread_message/">&lt;h3 id=&quot;一线程间通信&quot;&gt;一、线程间通信&lt;/h3&gt;

&lt;p&gt;因为线程是共享内存空间的，所以线程间通信相比于进程间通信会简单一些，线程间通信的体现&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1个线程传递数据给另1个线程&lt;/li&gt;
  &lt;li&gt;在1个线程中执行完特定任务后，转到另1个线程继续执行任务&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在iOS多线程开发中，有NSObject、NSThread、GCD、NSOpeartion几种方式，对应的线程间通信也有几种&lt;/p&gt;

&lt;h4 id=&quot;1nsobject&quot;&gt;1、NSObject&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/*
 *  回到主线程执行，执行self的showImage方法，参数是image
 */
[self performSelectorOnMainThread:@selector(showImage:) withObject:image waitUntilDone:YES];

// waitUntilDone的含义:
//    如果传入的是YES: 那么会等到主线程中的方法执行完毕, 才会继续执行下面其他行的代码
//    如果传入的是NO: 那么不用等到主线程中的方法执行完毕, 就可以继续执行下面其他行的低吗
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/*
 *  去xx线程执行aSelector方法，参数是arg
 */
- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;2gcd&quot;&gt;2、GCD&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dispatch_async(queue, ^{
		# do something
		
		
        dispatch_sync(dispatch_get_main_queue(), ^{
			#回到主线程
        });
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;3nsoperation&quot;&gt;3、NSOperation&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSOperationQueue *queue = [[NSOperationQueue alloc] init];

    // 2.添加任务(操作)
    [queue addOperationWithBlock:^{
		
		# 回到主线程
        [[NSOperationQueue mainQueue] addOperationWithBlock:^{
            self.imageView.image = image;
        }];
    }];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;二进程间通信app间通信&quot;&gt;二、进程间通信/APP间通信&lt;/h3&gt;

&lt;p&gt;进程是容纳运行一个程序所需要所有信息的容器。在iOS中每个APP里就一个进程，所以进程间的通信实际上是APP之间的通信。iOS是封闭的系统，每个APP都只能访问各自沙盒里的内容&lt;/p&gt;

&lt;h4 id=&quot;1url-scheme&quot;&gt;1、URL Scheme&lt;/h4&gt;

&lt;p&gt;App1通过openURL的方法跳转到App2，并且在URL中带上想要的参数，有点类似http的get请求那样进行参数传递。这种方式是使用最多的最常见的，使用方法也很简单只需要源App1在info.plist中配置LSApplicationQueriesSchemes，指定目标App2的scheme；然后在目标App2的info.plist中配置好URL types，表示该app接受何种URL scheme的唤起。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_1/09.jpeg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;UIApplication *application = [UIApplication sharedApplication];
[application openURL:URL options:@{} completionHandler:nil];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;2keychain&quot;&gt;2、Keychain&lt;/h4&gt;

&lt;p&gt;Keychain是iOS中一个安全存储容器，本质是一个sqlite数据库，位置在/private/var/Keychains/keychain-2.db。它是独立于每个App的沙盒之外的，所以即使App被删除之后，Keychain里面的信息依然存在。基于安全和独立于app沙盒的两个特性，Keychain主要用于给app保存登录和身份凭证等敏感信息，这样只要用户登录过，即使用户删除了app重新安装也不需要重新登录。&lt;/p&gt;

&lt;p&gt;Keychain用于App间通信的一个典型场景也和app的登录相关，就是统一账户登录平台。使用同一个账号平台的多个app，只要其中一个app用户进行了登录，其他app就可以实现自动登录不需要用户多次输入账号和密码。一般开放平台都会提供登录SDK，在这个SDK内部就可以把登录相关的信息都写到keychain中，这样如果多个app都集成了这个SDK，那么就可以实现统一账户登录了。&lt;/p&gt;

&lt;p&gt;可以自封装一个keychain相关的存储&lt;/p&gt;

&lt;h4 id=&quot;3uipasteboard&quot;&gt;3、UIPasteboard&lt;/h4&gt;

&lt;p&gt;UIPasteboard是剪切板功能，因为iOS的原生控件UITextView，UITextField 、UIWebView，我们在使用时如果长按，就会出现复制、剪切、选中、全选、粘贴等功能，这个就是利用了系统剪切板功能来实现的。而每一个App都可以去访问系统剪切板，所以就能够通过系统剪贴板进行App间的数据传输了。&lt;/p&gt;

&lt;p&gt;UIPasteboard典型的使用场景就是淘宝跟微信/QQ的链接分享。淘口令。&lt;/p&gt;

&lt;h4 id=&quot;4uidocumentinteractioncontroller&quot;&gt;4、UIDocumentInteractionController&lt;/h4&gt;

&lt;p&gt;UIDocumentInteractionController主要是用来实现同设备上app之间的共享文档，以及文档预览、打印、发邮件和复制等功能。它的使用非常简单.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#import &quot;ViewController.h&quot;
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ViewController&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UIDocumentInteractionControllerDelegate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ViewController&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;viewDidLoad&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;viewDidLoad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;navigationItem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;预览&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;urlStr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSBundle&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;mainBundle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pathForResource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;iOS开发指南.pdf&quot;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ofType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;NSURL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSURL&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fileURLWithPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;urlStr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;UIDocumentInteractionController&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;documentVc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UIDocumentInteractionController&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;interactionControllerWithURL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;documentVc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delegate&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;documentVc&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;presentPreviewAnimated&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;YES&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;cp&quot;&gt;#pragma mark - UIDocumentInteractionController 代理方法
&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UIViewController&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;documentInteractionControllerViewControllerForPreview&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UIDocumentInteractionController&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;controller&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UIView&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;documentInteractionControllerViewForPreview&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UIDocumentInteractionController&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;controller&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CGRect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;documentInteractionControllerRectForPreview&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UIDocumentInteractionController&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;controller&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bounds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_1/10.jpeg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;5local-socket&quot;&gt;5、local socket&lt;/h4&gt;

&lt;p&gt;App1在本地的端口port1234进行TCP的bind和listen，另外一个App2在同一个端口port1234发起TCP的connect连接，这样就可以建立正常的TCP连接，进行TCP通信了，那么就想传什么数据就可以传什么数据了。&lt;/p&gt;

&lt;p&gt;这种方式最大的特点就是灵活，只要连接保持着，随时都可以传任何相传的数据，而且带宽足够大。它的缺点就是因为iOS系统在任意时刻只有一个app在前台运行，那么就要通信的另外一方具备在后台运行的权限，像导航或者音乐类app。&lt;/p&gt;

&lt;p&gt;它是常用使用场景就是某个App1具有特殊的能力，比如能够跟硬件进行通信，在硬件上处理相关数据。而App2则没有这个能力，但是它能给App1提供相关的数据，这样APP2跟App1建立本地socket连接，传输数据到App1，然后App1在把数据传给硬件进行处理。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_1/11.jpeg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;</content><author><name>Ted</name></author><summary type="html">一、线程间通信</summary></entry><entry><title type="html">iOS设计模式</title><link href="http://www.helloted.com/2017/09/08/designPatten/" rel="alternate" type="text/html" title="iOS设计模式" /><published>2017-09-08T20:00:00+08:00</published><updated>2017-09-08T20:00:00+08:00</updated><id>http://www.helloted.com/2017/09/08/designPatten</id><content type="html" xml:base="http://www.helloted.com/2017/09/08/designPatten/">&lt;p&gt;部分代码位置&lt;a href=&quot;https://github.com/helloted/designpattern&quot;&gt;Github-设计模式&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;创建型&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;单件模式&lt;/li&gt;
  &lt;li&gt;工厂模式&lt;/li&gt;
  &lt;li&gt;抽象工厂模式&lt;/li&gt;
  &lt;li&gt;创建者模式&lt;/li&gt;
  &lt;li&gt;原型模式&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;结构型&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;组合模式&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;外观模式&lt;/li&gt;
  &lt;li&gt;适配器模式&lt;/li&gt;
  &lt;li&gt;桥模式&lt;/li&gt;
  &lt;li&gt;装饰模式&lt;/li&gt;
  &lt;li&gt;享元模式&lt;/li&gt;
  &lt;li&gt;代理模式&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;行为型&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;命令模式&lt;/li&gt;
  &lt;li&gt;观察者模式&lt;/li&gt;
  &lt;li&gt;策略模式&lt;/li&gt;
  &lt;li&gt;职责模式&lt;/li&gt;
  &lt;li&gt;模板模式&lt;/li&gt;
  &lt;li&gt;中介者模式&lt;/li&gt;
  &lt;li&gt;解释器模式&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;1单例模式singleton&quot;&gt;1、单例模式(Singleton)&lt;/h4&gt;

&lt;p&gt;概念理解：整个应用或系统只能有该类的一个实例&lt;/p&gt;

&lt;p&gt;iOS中几个常用的单例：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;UIApplication类提供了 ＋sharedAPplication方法创建和获取UIApplication单例&lt;/li&gt;
  &lt;li&gt;NSBundle类提供了 +mainBunle方法获取NSBundle单例&lt;/li&gt;
  &lt;li&gt;NSFileManager类提供了 ＋defaultManager方法创建和获得NSFileManager单例。（PS：有些时候我们得放弃使用单例模式，使用－init方法去实现一个新的实例，比如使用委托时）&lt;/li&gt;
  &lt;li&gt;NSNotificationCenter提供了 ＋defaultCenter方法创建和获取NSNotificationCenter单例（PS：该类还遵循了另一个重要的设计模式：观察者模式）&lt;/li&gt;
  &lt;li&gt;NSUserDefaults类提供了 ＋defaultUserDefaults方法去创建和获取NSUserDefaults单例&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们也可以自己去生成一个单例&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (SingleObject *)sharedSingleton{
    static SingleObject *_singleObj = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;amp;onceToken, ^{
        _singleObj = [[self alloc] init];
    });
    return _singleObj;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;2mvc模式&quot;&gt;2、MVC模式&lt;/h4&gt;

&lt;p&gt;MVC是Cocoa框架采用推荐的一种设计模式，也是iOS开发中最常用的一种模式，是由各种类型的设计模式组成的复合结构&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;M-Model:&lt;/code&gt; “模型”封装应用程序的数据，模型对象维护应用程序的数据，并定义操作数据的特定逻辑。模型对象可以复用，因为它表示的知识适用于特定问题的领域。理想状况下，模型对象同用于进行显示和编辑的用户界面之间不应有任何直接的关联。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;V-View&lt;/code&gt;: “视图”显示和编辑数据，视图对象可以响应用户操作。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;C-Controller&lt;/code&gt;: “控制器”处理前两者之间的逻辑关系。控制器对象作为中间人或者协调人，使视图得以知晓模型的变更而给予响应。控制器对象还可以作为管理其他对象的生命周期，进行设置和协调任务。&lt;/p&gt;

&lt;h4 id=&quot;3原型模式prototype&quot;&gt;3、原型模式(Prototype)&lt;/h4&gt;

&lt;p&gt;概念：使用原型实例指定对象的种类，并通过复制这个原型创建新的对象，原型模型也称为复制模式，此模式是生成对象的真实副本，以用作同一环境下其他相关事物的基础(原型)&lt;/p&gt;

&lt;p&gt;应用：NSObject的派生类提供了实现深复制的协议，其他类需要实现NSCopying协议及其方法&lt;code class=&quot;highlighter-rouge&quot;&gt;-(id)copyWithZone:(NSZone *)zone&lt;/code&gt;来实现&lt;code class=&quot;highlighter-rouge&quot;&gt;-(id)copy&lt;/code&gt;方法，否则会引发异常。思路是复制必需的成员变量与资源，传给此类的新实例。&lt;/p&gt;

&lt;h4 id=&quot;4简单工厂模式simple-factory&quot;&gt;4、简单工厂模式(Simple Factory)&lt;/h4&gt;

&lt;p&gt;概念：提供一个创建实例的接口，根据传入值不一样来获取不一样的类&lt;/p&gt;

&lt;p&gt;应用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AnimalFactory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;NSObject&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Animal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;createAnimalyWithType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;5工厂方法模式factory-method&quot;&gt;5、工厂方法模式(Factory Method)&lt;/h4&gt;

&lt;p&gt;概念：封装类中不变的部分，提取其中个性化善变的部分为独立类，通过依赖注入以达到解耦、复用和方便后期维护拓展的目的.定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中&lt;/p&gt;

&lt;p&gt;应用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AnimalFactory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;NSObject&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Animal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;createAnimal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DogFactory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;AnimalFactory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DogFactory&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Animal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;createAnimal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#Dog继承自Animal
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;retrurn&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dog&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CatFactory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;AnimalFactory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Cat&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Factory&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Animal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;createAnimal&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;retrurn&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cat&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;6抽象工厂模式abstract-factory&quot;&gt;6、抽象工厂模式(Abstract Factory)&lt;/h4&gt;

&lt;p&gt;概念：提供一个创建一系列相关或者相互依赖对象的接口，而无需指定它们具体的类&lt;/p&gt;

&lt;p&gt;应用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AnimalFactory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;NSObject&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dog&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;createDog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;createCat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Cocoa中的NSNumber也是如此，numberWithBool:和numberWithInt:分别返回的是NSCFBoolean、NSCFNumber类型&lt;/p&gt;

&lt;h4 id=&quot;7生成器模式builder&quot;&gt;7、生成器模式(Builder)&lt;/h4&gt;

&lt;p&gt;概念：将一个复杂对象的构建与它的表现分离，通过分层来构建对象。领导者-&amp;gt;生成者-&amp;gt;产品。领导者提供原料，生产者去实现加工成产品，不同的生产者提供不同等级的产品&lt;/p&gt;

&lt;p&gt;应用：&lt;a href=&quot;https://github.com/helloted/designpattern&quot;&gt;Github-设计模式&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;与抽象工厂模式的区别：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;生成器构建复杂对象，抽象工厂构建简单或者复杂对象；&lt;/li&gt;
  &lt;li&gt;生成器以多个步骤构建对象，抽象工厂以单一步骤构建对象；&lt;/li&gt;
  &lt;li&gt;生成器以多种方式构建对象昂，抽象工厂以单一步骤构建对象；&lt;/li&gt;
  &lt;li&gt;生成器在构建过程的最后一步返回产品，抽象工厂立刻返回产品；&lt;/li&gt;
  &lt;li&gt;生成器专注一个特定产品的不同等级，抽象工厂强调一套产品。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;8适配器模式adapter&quot;&gt;8、适配器模式(Adapter)&lt;/h4&gt;

&lt;p&gt;概念：有时也称为“包装器”(Wrapper)，用于连接两种不同种类的对象，使其毫无问题地协同工作，将一个类的接口转换成客户希望的另外一个接口&lt;/p&gt;

&lt;p&gt;应用：&lt;code class=&quot;highlighter-rouge&quot;&gt;-(void)laodData:(AModel*)model ;&lt;/code&gt;,我们的视图需要一个AModel，但此时有一个BModel，就需要一个适配器来适配BModel,&lt;code class=&quot;highlighter-rouge&quot;&gt;-(AModel *)adapterfrom(BModel *)model&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;优点：&lt;/p&gt;

&lt;p&gt;解耦合，让视图类不合数据类产生耦合，使视图类更加独立。  新增加数据类的时候不需要修改视图类。&lt;/p&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;p&gt;会新增加很多类，使系统更凌乱，代码可读性更弱了。&lt;/p&gt;

&lt;h4 id=&quot;9桥接模式bridge&quot;&gt;9、桥接模式(Bridge)&lt;/h4&gt;

&lt;p&gt;概念：桥接模式的目的是把抽象层次结构从其实现中分离出来，使其能够独立变更。抽象层定义了供客户端使用的上层的抽象接口。实现层定义了供抽象层使用的底层接口。实现类的引用被封装于抽象层的实例中，桥接就形成。（与外观模式有一定的相似之处）。&lt;/p&gt;

&lt;p&gt;应用：&lt;a href=&quot;https://github.com/helloted/designpattern/tree/master/Designpattern/DesignPattern/Bridge&quot;&gt;桥接模式-Bridge&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;优点：&lt;/p&gt;

&lt;p&gt;桥接模式使用聚合关系，解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。
提高了系统的可扩展性，可以独立地对抽象部分和实现部分进行扩展。
可减少子类的个数，这个在前面讲手机示例的时候进行分析了。&lt;/p&gt;

&lt;p&gt;缺点：桥接模式的引入会增加系统的理解与设计难度，由于聚合关系建立在抽象层，要求开发者针对抽象进行设计与编程。
桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。&lt;/p&gt;

&lt;h4 id=&quot;10外观模式facade&quot;&gt;10、外观模式(Facade)&lt;/h4&gt;

&lt;p&gt;概念：为系统中的一组接口提供一个统一的接口&lt;/p&gt;

&lt;p&gt;应用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Facade&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NSObject&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;createApp&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NSObject&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;instancetype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;init&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ios_dev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IosDev&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;andriod_dev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AndroidDev&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;server_dev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ServerDev&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;createApp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ios_dev&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ios&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;andriod_dev&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;android&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;server_dev&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;server&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;11中介者模式mediator&quot;&gt;11、中介者模式(Mediator)&lt;/h4&gt;

&lt;p&gt;概念：用一个对象来封装一系列对象的交互方式，中介者使各对象不需要显式地相互引用，从而使其耦合松散。&lt;/p&gt;

&lt;p&gt;应用：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_1/07.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_1/08.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/helloted/designpattern/tree/master/Designpattern/DesignPattern/Mediator&quot;&gt;中介者模式-Mediator&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;12观察者模式observer&quot;&gt;12、观察者模式(Observer)&lt;/h4&gt;

&lt;p&gt;概念：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新&lt;/p&gt;

&lt;p&gt;应用：Notification、KVO。&lt;/p&gt;

&lt;h4 id=&quot;13组合模式composite&quot;&gt;13、组合模式(Composite)&lt;/h4&gt;

&lt;p&gt;概念：把具有相同基类类型的对象组合到树形结构中，以表示“部分－整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。组合模式使得树形结构中的每个节点都具有相同的抽象接口，整个结构可作为一个统一的抽象结构使用，而不暴露其内部表示。每个节点的任何操作，可以通过抽象基类中定义的相同接口来进行。&lt;/p&gt;

&lt;p&gt;应用：UIView对象被组合成一个树形结构，UIView对象可以包含其他的UIView对象。这种组合方式便于统一用于事件处理，例如处理渲染事件时，事件会在父视图中被处理，然后在传递给子视图，因为他们都是相同的类型，事件可以传递到树形结构的每一视图。&lt;/p&gt;

&lt;p&gt;优点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可以使用简单的基本对象组合成较为复杂的组合对象，复杂组合对象又可以组合成更为复杂的对象，如此递归循环。但是使用简单对象和使用复杂组合对象是无差别的&lt;/li&gt;
  &lt;li&gt;简化客户单代码，同时使得创建同类型的复杂对象更简单。因为客户端不需要区分单个对象还是组合对象，所以不必写if-else之类的各种判断&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;14迭代器模式composite&quot;&gt;14、迭代器模式(Composite)&lt;/h4&gt;

&lt;p&gt;概念：提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示&lt;/p&gt;

&lt;p&gt;应用：NSEnumerator,&lt;code class=&quot;highlighter-rouge&quot;&gt;enumerateObjectsUsingBlock:(void(^)(id obj, NSUInteger idx, BOOL *stop))block&lt;/code&gt;  等等&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;NSObject&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;First&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BOOL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IsDone&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CurrentItem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;15访问者模式vistor&quot;&gt;15、访问者模式(Vistor)&lt;/h4&gt;

&lt;p&gt;概念：表示一个作用于表示一个作用于某对象结构中的各个元素的操作，它让我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作&lt;/p&gt;

&lt;p&gt;应用：这用于某个对象结构中的元素数目比较固定（基本不会变动），而对于这些元素的操作可能要变化（增加新操作），vistor提供了在某个状态下，对对象结构中各元素的不同操作的访问接口，对象中使用accept接口接受一个具体的访问者。符合open-close原则。&lt;/p&gt;

&lt;p&gt;访问者模式适用于数据结构相对稳定的系统，它把数据结构和作用于结构上的操作之间的耦合解开，使得操作集合可以相对自由地演化。&lt;/p&gt;

&lt;p&gt;访问者模式的优点就是增加新的操作很容易，因为增加新的操作就意味着增加一个新的访问者。访问者模式将有关的行为集中到一个访问者对象中。缺点是是增加新的数据结构变得复杂&lt;/p&gt;

&lt;h4 id=&quot;16装饰者模式decorator&quot;&gt;16、装饰者模式(Decorator)&lt;/h4&gt;

&lt;p&gt;概念：是面向对象编程领域中，一种动态地往一个类中添加新的行为的设计模式。就功能而言，修饰模式相比生成子类更为灵活，这样可以给某个对象而不是整个类添加一些功能&lt;/p&gt;

&lt;p&gt;应用：Category,Delegate&lt;/p&gt;

&lt;h4 id=&quot;17责任链模式chain-of-responsibility&quot;&gt;17、责任链模式(Chain of Responsibility)&lt;/h4&gt;

&lt;p&gt;概念：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间发生耦合。此模式将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。&lt;/p&gt;

&lt;p&gt;应用：响应者链条&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;降低耦合度。
可简化对象的相互连接。
增强给对象指派职责的灵活性。
增加新的请求处理类很方便。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;不能保证请求一定被接收。
系统性能将受到一定影响，而且在进行代码调试时不太方便（可能会造成循环调用）。&lt;/p&gt;

&lt;h4 id=&quot;18模板方法模式template-method&quot;&gt;18、模板方法模式(Template Method)&lt;/h4&gt;

&lt;p&gt;概念：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。核心思想就是通过把不变的行为搬移到超类，去除子类中的重复代码来体现它的优势。其实，模板方法模式就是提供了一个很好的代码复用平台。定义一个父类，有父类定义接口规范，然后不同的行为在子类中实现。这样一方面提高了代码的复用性，另一方面还可以利用面向对象的多态性，在运行时选择一种具体子类&lt;/p&gt;

&lt;p&gt;应用：&lt;code class=&quot;highlighter-rouge&quot;&gt;-(void)drawRect:(CGRect)rect&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;模板模式和策略模式的不同点：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;（1）策略模式的应用场景:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;多个类的区别只是在于行为不同。&lt;/li&gt;
  &lt;li&gt;你需要行为的算法做很多变动。&lt;/li&gt;
  &lt;li&gt;客户端不知道算法使用的数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;（2）模板模式的使用场景：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;相同的算法放在一个类中（父类）将算法变化的部分放在子类中。&lt;/li&gt;
  &lt;li&gt;子类公共的算法放在一个公共类中，避免代码重复。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;19策略模式strategy&quot;&gt;19、策略模式(Strategy)&lt;/h4&gt;

&lt;p&gt;概念：定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。策略模式是对算法的包装，是把使用算法的责任和算法本身分割开来，委派给不同的对象管理。看到策略模式的时候有的时候跟简单工厂相比较，其实有很大的迷惑性，都是继承多态感觉没有太大的差异性，简单工厂模式是对对象的管理，策略模式是对行为的封装。&lt;/p&gt;

&lt;p&gt;应用：&lt;a href=&quot;https://github.com/helloted/designpattern/tree/master/Designpattern/DesignPattern/Strategy&quot;&gt;策略模式demo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;优点：
1、 策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码转移到父类里面，从而避免重复的代码。
2、 策略模式提供了可以替换继承关系的办法。继承可以处理多种算法或行为。如果不是用策略模式，那么使用算法或行为的环境类就可能会有一些子类，每一个子类提供一个不同的算法或行为。但是，这样一来算法或行为的使用者就和算法或行为本身混在一起。决定使用哪一种算法或采取哪一种行为的逻辑就和算法或行为的逻辑混合在一起，从而不可能再独立演化。继承使得动态改变算法或行为变得不可能。
3、 使用策略模式可以避免使用多重条件转移语句。多重转移语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重转移语句里面，比使用继承的办法还要原始和落后。
缺点：
1、客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道所有的算法或行为的情况。
2、 策略模式造成很多的策略类，每个具体策略类都会产生一个新类。有时候可以通过把依赖于环境的状态保存到客户端里面，而将策略类设计成可共享的，这样策略类实例可以被不同客户端使用。换言之，可以使用享元模式来减少对象的数量。&lt;/p&gt;

&lt;h4 id=&quot;20命令模式command&quot;&gt;20、命令模式(Command)&lt;/h4&gt;

&lt;p&gt;概念：将请求封装成对象，以便使用不同的请求、日志、队列等来参数化其他对象。命令模式也支持撤销操作。这个封装请求比原始的请求要灵活并且可以在对象之前被传递，存储，动态修改或者放进队列里面。一般在想让应用程序支持撤销与恢复的情况下使用这一模式。&lt;/p&gt;

&lt;p&gt;应用：Target-Action机制和NSInvocation&lt;/p&gt;

&lt;h4 id=&quot;21享元模式flyweight&quot;&gt;21、享元模式(Flyweight)&lt;/h4&gt;

&lt;p&gt;概念：复用我们内存中已存在的对象，降低系统创建对象实例的性能消耗。&lt;/p&gt;

&lt;p&gt;应用：UITableViewCell复用&lt;/p&gt;

&lt;h4 id=&quot;22代理模式proxy&quot;&gt;22、代理模式(Proxy)&lt;/h4&gt;

&lt;p&gt;概念：为其他对象提供一种代理以控制对这个对象的访问。&lt;/p&gt;

&lt;p&gt;应用：Delegate&lt;/p&gt;

&lt;h4 id=&quot;23备忘录模式memento&quot;&gt;23、备忘录模式(Memento)&lt;/h4&gt;

&lt;p&gt;概念：在不破坏封装的前提下，捕获一个对象的内部状态，以后可以将该对象回复到原先保存的状态&lt;/p&gt;

&lt;p&gt;应用：对象序列化保存&lt;/p&gt;

&lt;p&gt;部分真实代码位置&lt;a href=&quot;https://github.com/helloted/designpattern&quot;&gt;Github-设计模式&lt;/a&gt;&lt;/p&gt;</content><author><name>Ted</name></author><summary type="html">部分代码位置Github-设计模式</summary></entry><entry><title type="html">iOS开发之声音</title><link href="http://www.helloted.com/2017/08/26/voice/" rel="alternate" type="text/html" title="iOS开发之声音" /><published>2017-08-26T20:00:00+08:00</published><updated>2017-08-26T20:00:00+08:00</updated><id>http://www.helloted.com/2017/08/26/voice</id><content type="html" xml:base="http://www.helloted.com/2017/08/26/voice/">&lt;p&gt;部分代码位置&lt;a href=&quot;https://github.com/helloted/voice&quot;&gt;Github-VoiceDemo&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Pre&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;与图片中默认的格式为PNG格式一样，iOS开发中声音的格式也有默认格式，为wav格式，本文中的产生的格式均为wav格式，其他格式则需要转换。有第三方的框架，进行转换成amr等格式&lt;/p&gt;

&lt;h3 id=&quot;一声音录制&quot;&gt;一、声音录制&lt;/h3&gt;

&lt;p&gt;要先引入AVFoundation的框架&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &amp;lt;AVFoundation/AVFoundation.h&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    self.voiceRecorder = [[AVAudioRecorder alloc]initWithURL:[NSURL fileURLWithPath:self.voicePath] settings:self.recorderSetting error:nil];
    if ([self.voiceRecorder prepareToRecord]){
        [[AVAudioSession sharedInstance] setCategory: AVAudioSessionCategoryPlayAndRecord error:nil];
        [[AVAudioSession sharedInstance] setActive:YES error:nil];
        
        //开始录音
        [self.voiceRecorder record];
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;录制声音主要设置两个参数，Path和Setting&lt;/p&gt;

&lt;p&gt;Path：声音文件录制后存储的路径&lt;/p&gt;

&lt;p&gt;Setting：一个录制参数的字典，设置一些录制的必要的参数，需要进行调整到合适的值&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        _recorderSetting = [[NSDictionary alloc] initWithObjectsAndKeys:
                            [NSNumber numberWithFloat: 8000.0],AVSampleRateKey, //采样率
                            [NSNumber numberWithInt: kAudioFormatLinearPCM],AVFormatIDKey,
                            [NSNumber numberWithInt:16],AVLinearPCMBitDepthKey,//采样位数 默认 16
                            [NSNumber numberWithInt: 1], AVNumberOfChannelsKey,//通道的数目
                            nil];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AVAudioRecorder&lt;/code&gt;在录制的时候可以暂停和恢复&lt;/p&gt;

&lt;p&gt;暂停&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)pause; /* pause recording */
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;恢复/开始&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)record;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;录制完成&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)stop;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;二声音播放&quot;&gt;二、声音播放&lt;/h3&gt;

&lt;p&gt;先引入MediaPlayer&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &amp;lt;MediaPlayer/MediaPlayer.h&amp;gt;
@import AVFoundation;
@import AudioToolbox;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;设置好录音文件路径就可以播放。注意：如果在播上一段录音，同时再点播放的话，两个声音会一起播放&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    if (_player) { // 如果正在播放上一段录音，则停止
        [_player stop];
    }
    [[AVAudioSession sharedInstance] setCategory: AVAudioSessionCategoryPlayback error:nil];
    [[AVAudioSession sharedInstance] setActive:YES error:nil];
    if (path&amp;amp;&amp;amp; [self fileSizeAtPath:path]) {
        self.player = [self.player initWithContentsOfURL:[NSURL URLWithString:path] error:nil];
        self.player.delegate = self;
        [self.player play];
        NSLog(@&quot;开始播放&quot;);
    }else{
        NSLog(@&quot;no voice&quot;);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;声音播放也可以暂停恢复和停止&lt;/p&gt;

&lt;p&gt;完整代码位置&lt;a href=&quot;https://github.com/helloted/voice&quot;&gt;Github-VoiceDemo&lt;/a&gt;&lt;/p&gt;</content><author><name>Ted</name></author><summary type="html">部分代码位置Github-VoiceDemo</summary></entry><entry><title type="html">源码分析之AFNetworking(三)</title><link href="http://www.helloted.com/2017/05/26/AFNetWorking_3/" rel="alternate" type="text/html" title="源码分析之AFNetworking(三)" /><published>2017-05-26T20:00:00+08:00</published><updated>2017-05-26T20:00:00+08:00</updated><id>http://www.helloted.com/2017/05/26/AFNetWorking_3</id><content type="html" xml:base="http://www.helloted.com/2017/05/26/AFNetWorking_3/">&lt;h3 id=&quot;五afnetworkreachabilitymanager&quot;&gt;五、AFNetworkReachabilityManager&lt;/h3&gt;

&lt;h4 id=&quot;一文档翻译&quot;&gt;（一）文档翻译&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;/**&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AFNetworkReachabilityManager&lt;/code&gt; monitors the reachability of domains, and addresses for both WWAN and WiFi network interfaces.&lt;/p&gt;

  &lt;p&gt;Reachability can be used to determine background information about why a network operation failed, or to trigger a network operation retrying when a connection is established. It should not be used to prevent a user from initiating a network request, as it’s possible that an initial request may be required to establish reachability.&lt;/p&gt;

  &lt;p&gt;See Apple’s Reachability Sample Code ( https://developer.apple.com/library/ios/samplecode/reachability/ )&lt;/p&gt;

  &lt;p&gt;@warning Instances of &lt;code class=&quot;highlighter-rouge&quot;&gt;AFNetworkReachabilityManager&lt;/code&gt; must be started with &lt;code class=&quot;highlighter-rouge&quot;&gt;-startMonitoring&lt;/code&gt; before reachability status can be determined.&lt;/p&gt;

  &lt;p&gt;*/&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AFNetworkReachabilityManager&lt;/code&gt;用于监测domains和addresses的可达性，包括WWAN和WiFi&lt;/p&gt;

&lt;p&gt;Reachability模块可以用来监测一个网络活动失败的背景原因，或者当一个连接建立之后，去触发重复请求，它不应该被用来阻止用户初始化一个网络请求，但是初始化一个网络请求需要建立可达性。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AFNetworkReachabilityManager&lt;/code&gt;的实例必须启用&lt;code class=&quot;highlighter-rouge&quot;&gt;-startMonitoring&lt;/code&gt;才能开始监听状态&lt;/p&gt;

&lt;h4 id=&quot;二状态&quot;&gt;（二）状态&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef NS_ENUM(NSInteger, AFNetworkReachabilityStatus) {
    AFNetworkReachabilityStatusUnknown          = -1,  //未知状态
    AFNetworkReachabilityStatusNotReachable     = 0,   //不可到达状态
    AFNetworkReachabilityStatusReachableViaWWAN = 1,   //蜂窝网络状态
    AFNetworkReachabilityStatusReachableViaWiFi = 2,  //Wifi网络状态
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以检测出总共四种状态：未知状态、不可到达状态、蜂窝网络(2G,3G,4G)状态、Wifi网络状态&lt;/p&gt;

&lt;h4 id=&quot;三使用方式&quot;&gt;（三）使用方式&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    AFNetworkReachabilityManager *manager = [AFNetworkReachabilityManager sharedManager];
    [manager setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) {
		NSLog(@&quot;current--%@&quot;,[manager localizedNetworkReachabilityStatusString]);
	}];
    [manager startMonitoring];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;四初始化&quot;&gt;（四）初始化&lt;/h4&gt;

&lt;p&gt;有四种类型的初始化方式&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Creates and returns a network reachability manager with the default socket address.
 // 监控一个默认的地址
+ (instancetype)manager;


 Creates and returns a network reachability manager for the specified domain.
  // 监控一个默认的地址
+ (instancetype)managerForDomain:(NSString *)domain;

/**
 Creates and returns a network reachability manager for the socket address.
 // 监测指定的地址
+ (instancetype)managerForAddress:(const void *)address;

/**
 Initializes an instance of a network reachability manager from the specified reachability object.
- (instancetype)initWithReachability:(SCNetworkReachabilityRef)reachability；
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下面是其中一种方法的实现&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (instancetype)managerForDomain:(NSString *)domain {
    SCNetworkReachabilityRef reachability = SCNetworkReachabilityCreateWithName(kCFAllocatorDefault, [domain UTF8String]);
    AFNetworkReachabilityManager *manager = [[self alloc] initWithReachability:reachability];  
    CFRelease(reachability);
    return manager;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以发现，最终都是要得到&lt;code class=&quot;highlighter-rouge&quot;&gt;SCNetworkReachabilityRef&lt;/code&gt;这个东西，这是何许东西？&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;​	@discussion The SCNetworkReachability API allows an application to&lt;/p&gt;

  &lt;p&gt;​		determine the status of a system’s current network&lt;/p&gt;

  &lt;p&gt;​		configuration and the reachability of a target host.&lt;/p&gt;

  &lt;p&gt;​		In addition, reachability can be monitored with notifications&lt;/p&gt;

  &lt;p&gt;​		that are sent when the status has changed.&lt;/p&gt;

  &lt;p&gt;​		“Reachability” reflects whether a data packet, sent by&lt;/p&gt;

  &lt;p&gt;​		an application into the network stack, can leave the local&lt;/p&gt;

  &lt;p&gt;​		computer.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;SCNetworkReachability可以监测APP的当前网络状态，对于目标host的可达性，当状态发送改变时，reachability可以监测到这个通知。&lt;/p&gt;

&lt;p&gt;“Reachability”反应的是，一个数据包是否会离开本机，并不能确保可以被主机收到&lt;/p&gt;

&lt;h4 id=&quot;五开启监控&quot;&gt;（五）开启监控&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/AFNetworking/09.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;里面有两个技术细节：&lt;/p&gt;

&lt;p&gt;1、在Block外面调用&lt;code class=&quot;highlighter-rouge&quot;&gt;__weak __typeof(self)weakSelf = self;&lt;/code&gt;，目的是防止循环引用，在Block内部调用&lt;code class=&quot;highlighter-rouge&quot;&gt;__strong __typeof(weakSelf)strongSelf = weakSelf;&lt;/code&gt;，目的是为了防止weakself被提前释放&lt;/p&gt;

&lt;p&gt;2、将整个监测放到异步线程，将优先级设为最低，并且开启了Runloop模式，目的是为了一直监测&lt;/p&gt;</content><author><name>Ted</name></author><summary type="html">五、AFNetworkReachabilityManager</summary></entry><entry><title type="html">源码分析之AFNetworking(二)</title><link href="http://www.helloted.com/2017/05/26/AFNetWorking_2/" rel="alternate" type="text/html" title="源码分析之AFNetworking(二)" /><published>2017-05-26T20:00:00+08:00</published><updated>2017-05-26T20:00:00+08:00</updated><id>http://www.helloted.com/2017/05/26/AFNetWorking_2</id><content type="html" xml:base="http://www.helloted.com/2017/05/26/AFNetWorking_2/">&lt;h3 id=&quot;三afhttpsessionmanager&quot;&gt;三、AFHTTPSessionManager&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@interface AFHTTPSessionManager : AFURLSessionManager &amp;lt;NSSecureCoding, NSCopying&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AFHTTPSessionManager&lt;/code&gt; is a subclass of &lt;code class=&quot;highlighter-rouge&quot;&gt;AFURLSessionManager&lt;/code&gt; with convenience methods for making HTTP requests. When a &lt;code class=&quot;highlighter-rouge&quot;&gt;baseURL&lt;/code&gt; is provided, requests made with the &lt;code class=&quot;highlighter-rouge&quot;&gt;GET&lt;/code&gt; / &lt;code class=&quot;highlighter-rouge&quot;&gt;POST&lt;/code&gt; / et al. convenience methods can be made with relative paths.&lt;/p&gt;

  &lt;p&gt;## Subclassing Notes&lt;/p&gt;

  &lt;p&gt;Developers targeting iOS 7 or Mac OS X 10.9 or later that deal extensively with a web service are encouraged to subclass &lt;code class=&quot;highlighter-rouge&quot;&gt;AFHTTPSessionManager&lt;/code&gt;, providing a class method that returns a shared singleton object on which authentication and other configuration can be shared across the application.&lt;/p&gt;

  &lt;p&gt;For developers targeting iOS 6 or Mac OS X 10.8 or earlier, &lt;code class=&quot;highlighter-rouge&quot;&gt;AFHTTPRequestOperationManager&lt;/code&gt; may be used to similar effect.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;文档翻译：&lt;/p&gt;

&lt;p&gt;AFHTTPSessionManager继承自AFURLSessionManager，提供了便捷的方法用于HTTP请求，当一个baseURL，根据相对路径，可以很方便地进行GET/POST或者其他请求。AFHTTPSessionManager本身并没有做什么实事，只是作为一个封装，将一些需求分发到其他相关类去做。&lt;/p&gt;

&lt;p&gt;建议iOS 7之后的开发者在 AFHTTPSessionManager的基础上再进行一次封装，封装一些开发者自己的需要。而针对iOS 6以及更早的则建议使用AFHTTPRequestOperationManager。&lt;/p&gt;

&lt;p&gt;注：AFHTTPRequestOperationManager基于开发的NSURLConnection已经在iOS 9被废弃。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;初始化&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;AFHTTPSessionManager对象的初始化有两种方式：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (instancetype)manager;
- (instancetype)initWithBaseURL:(nullable NSURL *)url;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;两种方式的区别在于后一种初始化方式会让你传入一个BaseURL，而前一种类方法则默认BaseURL为nil，BaseURL在生成全URL时有作用，AFHTTPSessionManager文档里也提供了说明。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    NSURL *baseURL = [NSURL URLWithString:@&quot;http://example.com/v1/&quot;];
    [NSURL URLWithString:@&quot;foo&quot; relativeToURL:baseURL];                  // http://example.com/v1/foo
    [NSURL URLWithString:@&quot;foo?bar=baz&quot; relativeToURL:baseURL];          // http://example.com/v1/foo?bar=baz
    [NSURL URLWithString:@&quot;/foo&quot; relativeToURL:baseURL];                 // http://example.com/foo
    [NSURL URLWithString:@&quot;foo/&quot; relativeToURL:baseURL];                 // http://example.com/v1/foo
    [NSURL URLWithString:@&quot;/foo/&quot; relativeToURL:baseURL];                // http://example.com/foo/
    [NSURL URLWithString:@&quot;http://example2.com/&quot; relativeToURL:baseURL]; // http://example2.com/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/img/AFNetworking/06.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;初始化的时候对url做了一下格式化处理，请求序列化默认用的是AFHTTPRequestSerializer进行序列化，返回结果的序列化默认用的是AFJSONResponseSerializer&lt;/p&gt;

&lt;p&gt;下面这个方法是AFHTTPSessionManager对象开启一个新请求的一个API&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// AFHTTPSessionManager.h
&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nullable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSURLSessionDataTask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GET&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;URLString&lt;/span&gt;
                   &lt;span class=&quot;n&quot;&gt;parameters&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nullable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parameters&lt;/span&gt;
                      &lt;span class=&quot;n&quot;&gt;success&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nullable&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSURLSessionDataTask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Nullable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;responseObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;success&lt;/span&gt;
                      &lt;span class=&quot;n&quot;&gt;failure&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nullable&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSURLSessionDataTask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Nullable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSError&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;failure&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;除了GET，还有PUT，PATCH，DELETE几个方法的封装，请求方式都一样,最终都汇总到一个方法，&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/AFNetworking/03.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;AFHTTPSessionManager的封装步骤&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;1、根据不同的HTTP Method和不同的请求参数序列化方式，以及URL合成，从&lt;code class=&quot;highlighter-rouge&quot;&gt;AFURLRequestSerialization&lt;/code&gt;类里封装出一个NSMutableURLRequest对象&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# AFURLRequestSerialization.h
- (NSMutableURLRequest *)requestWithMethod:(NSString *)method
                                 URLString:(NSString *)URLString
                                parameters:(id)parameters
                                     error:(NSError *__autoreleasing *)error
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2、NSMutableURLRequest对象，作为一个参数重写父类&lt;code class=&quot;highlighter-rouge&quot;&gt;AFURLSessionManager&lt;/code&gt;的方法生成一个NSURLSessionDataTask对象&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// AFURLSessionManager.h
- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request
                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock
                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock
                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3、NSURLSessionDataTask对象开始网络请求&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// AFHTTPSessionManager.h
[dataTask resume];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;四afurlsessionmanager之request请求&quot;&gt;四、AFURLSessionManager之request请求&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@interface AFURLSessionManager : NSObject &amp;lt;NSURLSessionDelegate, NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate, NSSecureCoding, NSCopying&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;AFURLSessionManager是对&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLSession&lt;/code&gt;的封装，&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLSession&lt;/code&gt;提供了下面网络请求三种的API，返回三种不同的Task&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request;
- (NSURLSessionUploadTask *)uploadTaskWithStreamedRequest:(NSURLRequest *)request;
- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/*
 * An NSURLSessionDataTask does not provide any additional
 * functionality over an NSURLSessionTask and its presence is merely
 * to provide lexical differentiation from download and upload tasks.
 */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NSURLSessionDataTask&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NSURLSessionTask&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/*
 * An NSURLSessionUploadTask does not currently provide any additional
 * functionality over an NSURLSessionDataTask.  All delegate messages
 * that may be sent referencing an NSURLSessionDataTask equally apply
 * to NSURLSessionUploadTasks.
 */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NSURLSessionUploadTask&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NSURLSessionDataTask&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/*
 * NSURLSessionDownloadTask is a task that represents a download to
 * local storage.
 */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NSURLSessionDownloadTask&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NSURLSessionTask&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;相对的，AFURLSessionManager提供了request请求，上传，下载的三种封装。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/AFNetworking/04.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上面的代码主要就两个步骤：&lt;/p&gt;

&lt;p&gt;1.根据初始化生成的Session生成datatask;&lt;/p&gt;

&lt;p&gt;2.给datatask绑定一个代理&lt;code class=&quot;highlighter-rouge&quot;&gt;AFURLSessionManagerTaskDelegate&lt;/code&gt;；&lt;/p&gt;

&lt;p&gt;依次来查看一下这两个步骤：&lt;/p&gt;

&lt;p&gt;在生成NSURLSessionDataTask对象时采用了url_session_manager_create_task_safely的方式，查看代码&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/AFNetworking/05.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;是因为之前iOS的一个bug，在并发队列中生成NSURLSessionDataTask对象会有问题，所以做了一个处理：&lt;/p&gt;

&lt;p&gt;如果版本低，则自己生成一个串行队列。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;self.session&lt;/code&gt;则是在初始化中生成了&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;初始化&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/img/AFNetworking/07.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;初始化过程中，主要是生成了一个NSURLSession并将其添加到了异步线程。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;AFURLSessionManagerTaskDelegate&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;AFURLSessionManagerTaskDelegate主要负责处理SessionTask网络请求过程中的事项，以及请求完成的事项。AFN给每个dataTask都绑定了一个代理，主要处理例如下载进度，下载完成后的一些格式处理&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask
                uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock
              downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock
             completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler
{
    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];
    delegate.manager = self;
    delegate.completionHandler = completionHandler;

    dataTask.taskDescription = self.taskDescriptionForSessionTasks;
    [self setDelegate:delegate forTask:dataTask];

    delegate.uploadProgressBlock = uploadProgressBlock;
    delegate.downloadProgressBlock = downloadProgressBlock;
}


- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate
            forTask:(NSURLSessionTask *)task
{
    NSParameterAssert(task);
    NSParameterAssert(delegate);

    [self.lock lock];
    self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;
    [delegate setupProgressForTask:task];
    // 进度处理
    [self addNotificationObserverForTask:task];
    [self.lock unlock];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;进度处理&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;是通过KVO的方式监听task的几个值&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    [task addObserver:self
           forKeyPath:NSStringFromSelector(@selector(countOfBytesReceived))
              options:NSKeyValueObservingOptionNew
              context:NULL];
    [task addObserver:self
           forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToReceive))
              options:NSKeyValueObservingOptionNew
              context:NULL];

    [task addObserver:self
           forKeyPath:NSStringFromSelector(@selector(countOfBytesSent))
              options:NSKeyValueObservingOptionNew
              context:NULL];
    [task addObserver:self
           forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToSend))
              options:NSKeyValueObservingOptionNew
              context:NULL];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;请求完成或错误&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;请求完成的处理是在SessionTask的代理方法NSURLSessionTaskDelegate&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\- (void)URLSession:(__unused NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/AFNetworking/08.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;分为error处理和成功完成请求，如果对请求处理有提前设置异步线程manager.completionQueue去处理，否则回到主线程处理。到这里一个完整的请求就完成了。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;总结&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以，AFURLSessionManager做的封装主要是&lt;/p&gt;

&lt;p&gt;1、生成Session，并对一些参数进行默认设置，并将session放到异步线程&lt;/p&gt;

&lt;p&gt;2、根据Session生成Task，然后task开启，并对task的一些值进行监听从而获取请求的进度&lt;/p&gt;

&lt;p&gt;3、在task的完成代理方法里，对请求完成或者错误再次封装一次&lt;/p&gt;</content><author><name>Ted</name></author><summary type="html">三、AFHTTPSessionManager</summary></entry><entry><title type="html">源码分析之AFNetworking(一)</title><link href="http://www.helloted.com/2017/05/26/AFNetWorking_1/" rel="alternate" type="text/html" title="源码分析之AFNetworking(一)" /><published>2017-05-26T20:00:00+08:00</published><updated>2017-05-26T20:00:00+08:00</updated><id>http://www.helloted.com/2017/05/26/AFNetWorking_1</id><content type="html" xml:base="http://www.helloted.com/2017/05/26/AFNetWorking_1/">&lt;h3 id=&quot;0前言&quot;&gt;0、前言&lt;/h3&gt;

&lt;p&gt;AFNetworking这个框架是iOS必备的一个第三方框架，其高效简洁的API使其成为最好的iOS网络请求框架，也让iOS开发的网络请求轻松许多，&lt;a href=&quot;https://github.com/AFNetworking/AFNetworking&quot;&gt;AFNetworking-Github&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文分析基于版本是3.1.0&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pod 'AFNetworking', '~&amp;gt; 3.1.0'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;因为iOS9开始NSURLConnection这个类已经被废弃，所以框架的主要类也由&lt;code class=&quot;highlighter-rouge&quot;&gt;AFHTTPRequestOperationManager&lt;/code&gt;变为&lt;code class=&quot;highlighter-rouge&quot;&gt;AFHTTPSessionManager&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;一架构分析&quot;&gt;一、架构分析&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/img/AFNetworking/01.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从图中就可以看出，整体分为以下几个部分&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;NSURLSession：网络请求的主要类，&lt;code class=&quot;highlighter-rouge&quot;&gt;AFURLSessionManager&lt;/code&gt;封装的是&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLSession&lt;/code&gt;,而&lt;code class=&quot;highlighter-rouge&quot;&gt;AFHTTPSessionManager&lt;/code&gt;是其子类，用于HTTP请求做了一些优化&lt;/li&gt;
  &lt;li&gt;Reachability：网络状况，&lt;code class=&quot;highlighter-rouge&quot;&gt;AFNetworkReachabilityManager&lt;/code&gt;是用来监测当前网络状况的一个类&lt;/li&gt;
  &lt;li&gt;Security：网络安全，HTTPS请求就要用到&lt;code class=&quot;highlighter-rouge&quot;&gt;AFSecurityPolicy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Serialization：序列化，&lt;code class=&quot;highlighter-rouge&quot;&gt;AFURLRequestSerialization&lt;/code&gt;是请求前的序列化，&lt;code class=&quot;highlighter-rouge&quot;&gt;AFURLResponseSerialization&lt;/code&gt;是请求完成后对结果的序列化&lt;/li&gt;
  &lt;li&gt;UIKit：里面则是一些UIkit的拓展Category&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以整个AFNetworking网络请求的过程就是：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/AFNetworking/02.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;</content><author><name>Ted</name></author><summary type="html">0、前言</summary></entry><entry><title type="html">Runtime运用：Json转Model</title><link href="http://www.helloted.com/2017/05/09/JsonToModel/" rel="alternate" type="text/html" title="Runtime运用：Json转Model" /><published>2017-05-09T20:00:00+08:00</published><updated>2017-05-09T20:00:00+08:00</updated><id>http://www.helloted.com/2017/05/09/JsonToModel</id><content type="html" xml:base="http://www.helloted.com/2017/05/09/JsonToModel/">&lt;p&gt;完整版代码可以在&lt;a href=&quot;https://github.com/helloted/JsonToModel&quot;&gt;GitHub-JsonToModel&lt;/a&gt;下载&lt;/p&gt;

&lt;h3 id=&quot;一前言&quot;&gt;一、前言&lt;/h3&gt;

&lt;p&gt;与后台交互，后台返回的数据一般是Json类型的，然而我们的定义的模型一般是继承自NSObject，Json与Model之间的转换，第三方工具也有很多，比如YYModel,JSONModel,MJExtention.&lt;/p&gt;

&lt;p&gt;这三个第三方框架的测试效率为YYModel&amp;gt;MJExtention&amp;gt;JsonModel&lt;/p&gt;

&lt;p&gt;其中JSon转Model的核心知识点就在于利用Runtime的特点来获取属性以及KVC进行赋值，尝试了一下，封装了一个简易版的工具，一行代码即可完成转换&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;User *user = [User ht_modelFromJson:jsonStr];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;二流程&quot;&gt;二、流程&lt;/h3&gt;

&lt;p&gt;首先要引入runtime&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &amp;lt;objc/runtime.h&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;拿到Model里的所有属性&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//获取当前类中的所有属性
 unsigned int propertyCount;
 objc_property_t *allPropertys = class_copyPropertyList([self class], &amp;amp;propertyCount);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;获取属性的name&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  //拿到属性名称
 NSString *property_name = [NSString stringWithUTF8String:property_getName(property)];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以name为key从Json字典里获取值&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 从Json字典里获取值
id value = [dict objectForKey:key];
if (value == nil) {
continue;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;KVC赋值&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[self setValue:value forKey:key];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;三补充&quot;&gt;三、补充&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;1、拿到的可能不是Json字典，而是Json字符串或者是二进制类型NSData，那么首先要对将Json字符串转成Json字典&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (NSDictionary *)dictionaryWithJSON:(id)json
{
    if (!json) {
        return nil;
    }
    // 若是NSDictionary类型，直接返回
    if ([json isKindOfClass:[NSDictionary class]]) {
        return json;
    }
    
    NSDictionary *dict = nil;
    NSData *jsonData = nil;
    
    // 如果是NSString，就先转化为NSData
    if ([json isKindOfClass:[NSString class]]) {
        jsonData = [(NSString *)json dataUsingEncoding:NSUTF8StringEncoding];
    } else if ([json isKindOfClass:[NSData class]]) {
        jsonData = json;
    }
    
    // 如果时NSData类型，使用NSJSONSerialization
    if (jsonData &amp;amp;&amp;amp; [jsonData isKindOfClass:[NSData class]]) {
        NSError *error = nil;
        dict = [NSJSONSerialization JSONObjectWithData:jsonData options:0 error:&amp;amp;error];
        if (error) {
            NSLog(@&quot;dictionaryWithJSON error:%@&quot;, error);
            return nil;
        }
        if (![dict isKindOfClass:[NSDictionary class]]) {
            return nil;
        }
    }
    
    return dict;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;2、如果字典属性与模型属性不完全相同，则需要匹配一下&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;解决方案是定义一个Protocol&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@protocol&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;JSONModelSpecialAttributesProtocol&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@optional&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 属性匹配
&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSDictionary&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attributesMapperDictionary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 嵌套模型
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSDictionary&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attributesNestDictionary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果某个Model与字典不一一匹配，则遵循这个协议，将需要配套的属性返回即可，在赋值的时候，将key现行转换一下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;c1&quot;&gt;// 某些属性需要重新映射===
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;NSDictionary&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mapperDict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;conformsToProtocol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;@protocol&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;JSONModelSpecialAttributesProtocol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;respondsToSelector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;@selector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attributesMapperDictionary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;mapperDict&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;attributesMapperDictionary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;// 如果有属性需要重新映射===
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;property_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mapperDict&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mapperDict&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;objectForKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;property_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mapperDict&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;objectForKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;property_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;3、如果模型里面嵌套了模型，也是需要先自定义下，在赋值时做个区分&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      // 如果有属性嵌套其他Model
        if (nestDict &amp;amp;&amp;amp; [nestDict objectForKey:property_name]) {
            NSString *className = [nestDict objectForKey:property_name];
            Class class = NSClassFromString(className);
            id obj = [[class alloc]init];
            [obj modelWithJsonDictionary:value];
            [self setValue:obj forKey:key];
        }else{
            [self setValue:value forKey:key];
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;完整版代码可以在&lt;a href=&quot;https://github.com/helloted/JsonToModel&quot;&gt;GitHub-JsonToModel&lt;/a&gt;下载&lt;/p&gt;</content><author><name>Ted</name></author><summary type="html">完整版代码可以在GitHub-JsonToModel下载</summary></entry><entry><title type="html">热修复=Runtime+Javascriptcore</title><link href="http://www.helloted.com/2017/04/30/hotfix/" rel="alternate" type="text/html" title="热修复=Runtime+Javascriptcore" /><published>2017-04-30T20:00:00+08:00</published><updated>2017-04-30T20:00:00+08:00</updated><id>http://www.helloted.com/2017/04/30/hotfix</id><content type="html" xml:base="http://www.helloted.com/2017/04/30/hotfix/">&lt;h3 id=&quot;一运行时&quot;&gt;一、运行时&lt;/h3&gt;

&lt;p&gt;热修复的基本原理就是Runtime运行时的方法替换，主要是下列几个方法&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;class_replaceMethod&lt;/code&gt;:方法替换&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;method_exchangeImplementations&lt;/code&gt;:IMP交换&lt;/p&gt;

&lt;p&gt;实例，当我们要对某个类的old_method方法以new_method方法替换掉，则新建一个Category，在其load类方法(Load方法每次APP加载都会调用)中实现以下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    static dispatch_once_t onceToken;
    dispatch_once(&amp;amp;onceToken, ^{
        Class class = [self class];
        
        SEL originalSelector = @selector(old_method);
        SEL swizzledSelector = @selector(new_method);
        
        Method originalMethod = class_getInstanceMethod(class, originalSelector);
        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);
        
        
        BOOL didAddMethod =
        class_addMethod(class,
                        originalSelector,
                        method_getImplementation(swizzledMethod),
                        method_getTypeEncoding(swizzledMethod));
        
        if (didAddMethod) {
            class_replaceMethod(class,
                                swizzledSelector,
                                method_getImplementation(originalMethod),
                                method_getTypeEncoding(originalMethod));
        } else {
            method_exchangeImplementations(originalMethod, swizzledMethod);
        }
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;二javascriptcore&quot;&gt;二、Javascriptcore&lt;/h3&gt;

&lt;p&gt;Javascriptcore是一个iOS原生框架，用于javascript与Objecive C语言进行相互调用，而我们热修改需要用到的就是javascript可以调用OC方法&lt;/p&gt;

&lt;p&gt;三、热修复&lt;/p&gt;</content><author><name>Ted</name></author><summary type="html">一、运行时</summary></entry><entry><title type="html">iOS之Runloop(3):应用</title><link href="http://www.helloted.com/2017/04/16/Runloop_3/" rel="alternate" type="text/html" title="iOS之Runloop(3):应用" /><published>2017-04-16T20:00:00+08:00</published><updated>2017-04-16T20:00:00+08:00</updated><id>http://www.helloted.com/2017/04/16/Runloop_3</id><content type="html" xml:base="http://www.helloted.com/2017/04/16/Runloop_3/">&lt;p&gt;其他两篇关于Runloop:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.helloted.com/2017/04/10/Runloop_1/&quot;&gt;iOS之Runloop(1):基础&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.helloted.com/2017/04/16/Runloop_2/&quot;&gt;iOS之Runloop(2):事件源&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;前：&lt;/p&gt;

&lt;p&gt;1、线程创建需要的内存和时间消耗都比较大，因此建议你的入口点函数做相当数量的工作，或建立一个Run Loops允许进行经常性的工作。
2、Run Loops可以让你使用最小的资源来创建长时间运行线程。因为run loop在没有任何事件处理的时候会把它的线程置于休眠状态，它消除了消耗CPU周期轮询，并防止处理器本身进入休眠状态并节省电源。&lt;/p&gt;

&lt;p&gt;RunLoop，就是一个循环，只是这个循环里加入很多特性。 首先循环体的开始需要检测是否有需要处理的事件，如果有则去处理，如果没有则进入睡眠以节省CPU时间。所以重点便是这个需要处理的事件，在RunLoop中，需要处理的事件分两类，一种是输入源，一种是定时器，定时器好理解就是那些需要定时执行的操作，输入源分三类：performSelector源，基于端口（Mach port）的源，以及自定义的源。编程的时候可以添加自己的源&lt;/p&gt;

&lt;h4 id=&quot;1autoreleasepool&quot;&gt;1、AutoreleasePool&lt;/h4&gt;

&lt;p&gt;App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。&lt;/p&gt;

&lt;p&gt;第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。&lt;/p&gt;

&lt;p&gt;第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。&lt;/p&gt;

&lt;p&gt;在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。&lt;/p&gt;

&lt;h4 id=&quot;2定时器&quot;&gt;2、定时器&lt;/h4&gt;

&lt;p&gt;NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。&lt;/p&gt;

&lt;p&gt;如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。&lt;/p&gt;

&lt;p&gt;CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。&lt;/p&gt;

&lt;h4 id=&quot;3performselector&quot;&gt;3、PerformSelector&lt;/h4&gt;

&lt;p&gt;当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。&lt;/p&gt;

&lt;p&gt;当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。&lt;/p&gt;

&lt;h4 id=&quot;4事件响应&quot;&gt;4、事件响应&lt;/h4&gt;

&lt;p&gt;苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。&lt;/p&gt;

&lt;p&gt;当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。&lt;/p&gt;

&lt;p&gt;_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。&lt;/p&gt;

&lt;h4 id=&quot;5手势识别&quot;&gt;5、手势识别&lt;/h4&gt;

&lt;p&gt;当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。&lt;/p&gt;

&lt;p&gt;苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。&lt;/p&gt;

&lt;p&gt;当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。&lt;/p&gt;

&lt;h4 id=&quot;6界面更新&quot;&gt;6、界面更新&lt;/h4&gt;

&lt;p&gt;当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。&lt;/p&gt;

&lt;p&gt;苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：&lt;/p&gt;

&lt;p&gt;_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()
    QuartzCore:CA::Transaction::observer_callback:
        CA::Transaction::commit();
            CA::Context::commit_transaction();
                CA::Layer::layout_and_display_if_needed();
                    CA::Layer::layout_if_needed();
                        [CALayer layoutSublayers];
                            [UIView layoutSubviews];
                    CA::Layer::display_if_needed();
                        [CALayer display];
                            [UIView drawRect];
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;7关于gcd&quot;&gt;7、关于GCD&lt;/h4&gt;

&lt;p&gt;实际上 RunLoop 底层也会用到 GCD 的东西。但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()&lt;/p&gt;

&lt;p&gt;当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 &lt;strong&gt;CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE&lt;/strong&gt;() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。&lt;/p&gt;

&lt;h4 id=&quot;8关于网络请求&quot;&gt;8、关于网络请求&lt;/h4&gt;

&lt;p&gt;iOS 中，关于网络请求的接口自下至上有如下几层:&lt;/p&gt;

&lt;p&gt;• CFSocket 是最底层的接口，只负责 socket 通信。&lt;/p&gt;

&lt;p&gt;• CFNetwork 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作于这一层。&lt;/p&gt;

&lt;p&gt;• NSURLConnection 是基于 CFNetwork 的更高层的封装，提供面向对象的接口，AFNetworking 工作于这一层。&lt;/p&gt;

&lt;p&gt;• NSURLSession 是 iOS7 中新增的接口，表面上是和 NSURLConnection 并列的，但底层仍然用到了 NSURLConnection 的部分功能 (比如com.apple.NSURLConnectionLoader 线程)，AFNetworking2 和 Alamofire 工作于这一层。&lt;/p&gt;

&lt;p&gt;下面主要介绍下 NSURLConnection 的工作过程。&lt;/p&gt;

&lt;p&gt;通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。&lt;/p&gt;

&lt;p&gt;当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。&lt;/p&gt;

&lt;p&gt;NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。&lt;/p&gt;</content><author><name>Ted</name></author><summary type="html">其他两篇关于Runloop:</summary></entry><entry><title type="html">iOS之Runloop(2):事件源</title><link href="http://www.helloted.com/2017/04/16/Runloop_2/" rel="alternate" type="text/html" title="iOS之Runloop(2):事件源" /><published>2017-04-16T20:00:00+08:00</published><updated>2017-04-16T20:00:00+08:00</updated><id>http://www.helloted.com/2017/04/16/Runloop_2</id><content type="html" xml:base="http://www.helloted.com/2017/04/16/Runloop_2/">&lt;p&gt;其他两篇关于Runloop:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.helloted.com/2017/04/10/Runloop_1/&quot;&gt;iOS之Runloop(2):基础&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.helloted.com/2017/04/16/Runloop_3/&quot;&gt;iOS之Runloop(3):应用&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;苹果官方文档：&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW7&quot;&gt;Run loops&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;一定义一个custom-input-source&quot;&gt;一、定义一个Custom Input Source&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Creating a custom input source involves defining the following:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;The information you want your input source to process.&lt;/li&gt;
    &lt;li&gt;A scheduler routine to let interested clients know how to contact your input source.&lt;/li&gt;
    &lt;li&gt;A handler routine to perform requests sent by any clients.&lt;/li&gt;
    &lt;li&gt;A cancellation routine to invalidate your input source.&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;Because you create a custom input source to process custom information, the actual configuration is designed to be flexible. The scheduler, handler, and cancellation routines are the key routines you almost always need for your custom input source. Most of the rest of the input source behavior, however, happens outside of those handler routines. For example, it is up to you to define the mechanism for passing data to your input source and for communicating the presence of your input source to other threads.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;创建一个自定义的input source需要涉及以下几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;需要input source处理的信息&lt;/li&gt;
  &lt;li&gt;调度程序让需要的端口知道怎么连接你的input source&lt;/li&gt;
  &lt;li&gt;可用的程序来处理任意端口发出的请求&lt;/li&gt;
  &lt;li&gt;有程序来取消input source&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因为创建一个自定义的input source来处理自定义信息，可配置的还是很灵活的，调度程序、处理程序和取消是关键。其他的input source就是在这些程序之外。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Figure shows a sample configuration of a custom input source. In this example, the application’s main thread maintains references to the input source, the custom command buffer for that input source, and the run loop on which the input source is installed. When the main thread has a task it wants to hand off to the worker thread, it posts a command to the command buffer along with any information needed by the worker thread to start the task. (Because both the main thread and the input source of the worker thread have access to the command buffer, that access must be synchronized.) Once the command is posted, the main thread signals the input source and wakes up the worker thread’s run loop. Upon receiving the wake up command, the run loop calls the handler for the input source, which processes the commands found in the command buffer&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下图展示了配置一个自定义input sources，主线程操控维护了input source的引用、input source的命令缓存区、input source安装在的那个runloop。当主线程有任务想要交给工作线程去处理，主线程发送命令到command buffer命令缓存区(命令带了工作线程工作所需的)。主线程和工作线程的input source都可以访问command buffer命令缓存区，所以这个访问必须是同步的。一旦命令发出，主线程通知input source并且唤醒工作线程的runloop。runloop一旦接到唤醒命令，runloop就会回调处理方法给input source，处理在command buffer命令缓存区里找到的命令。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Runloop/runloop_05.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RunLoopSource&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NSObject&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;CFRunLoopSourceRef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;runLoopSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;NSMutableArray&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;commands&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addToCurrentRunLoop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;invalidate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 
&lt;span class=&quot;c1&quot;&gt;// Handler method
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sourceFired&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 
&lt;span class=&quot;c1&quot;&gt;// Client interface for registering commands to process
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;addCommand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSInteger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;command&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;withData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;fireAllCommandsOnRunLoop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CFRunLoopRef&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;runloop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;RunLoopSource&lt;/code&gt; object manages a command buffer and uses that buffer to receive messages from other threads&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;RunLoopSource对象管理了一个command buffer并且用buffer来从其他线程接受信息。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// These are the CFRunLoopSourceRef callback functions.
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RunLoopSourceScheduleRoutine&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CFRunLoopRef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CFStringRef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RunLoopSourcePerformRoutine&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RunLoopSourceCancelRoutine&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CFRunLoopRef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CFStringRef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 
&lt;span class=&quot;c1&quot;&gt;// RunLoopContext is a container object used during registration of the input source.
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RunLoopContext&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NSObject&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;CFRunLoopRef&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;runLoop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;RunLoopSource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readonly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CFRunLoopRef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;runLoop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readonly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RunLoopSource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;initWithSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RunLoopSource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;src&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;andLoop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CFRunLoopRef&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RunLoopContext&lt;/code&gt; object, which is really just a container object used to pass a &lt;code class=&quot;highlighter-rouge&quot;&gt;RunLoopSource&lt;/code&gt; object and a run loop reference to the application’s main thread.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;RunLoopContext对象是一个容器，用来传递RunLoopSource对象和runloop引用给主线程。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The first of these functions is called when you actually attach the run loop source to your run loop，Because this input source has only one client (the main thread), it uses the scheduler function to send a message to register itself with the application delegate on that thread. When the delegate wants to communicate with the input source, it uses the information in &lt;code class=&quot;highlighter-rouge&quot;&gt;RunLoopContext&lt;/code&gt; object to do so&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当你把runloop source放入到runloop时，实际会调用下面这个函数。因为input source只有一个端口（主线程），input source使用调度函数来发送一个消息从而注册他本身到线程的delegate上，当delegate用&lt;code class=&quot;highlighter-rouge&quot;&gt;RunLoopContext&lt;/code&gt;与input source交流，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void RunLoopSourceScheduleRoutine (void *info, CFRunLoopRef rl, CFStringRef mode)
{
    RunLoopSource* obj = (RunLoopSource*)info;
    AppDelegate*   del = [AppDelegate sharedAppDelegate];
    RunLoopContext* theContext = [[RunLoopContext alloc] initWithSource:obj andLoop:rl];
 
    [del performSelectorOnMainThread:@selector(registerSource:)
                                withObject:theContext waitUntilDone:NO];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;One of the most important callback routines is the one used to process custom data when your input source is signaled. Listing 3-5 shows the perform callback routine associated with the &lt;code class=&quot;highlighter-rouge&quot;&gt;RunLoopSource&lt;/code&gt; object. This function simply forwards the request to do the work to the &lt;code class=&quot;highlighter-rouge&quot;&gt;sourceFired&lt;/code&gt; method, which then processes any commands present in the command buffer.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最重要之一的回调是当input sour发完信号时处理自定义的数据，下面的代码展示了RunLoopSource的处理回调。这个函数简单地将需求转发到sourceFired方法（处理任何在命令缓存池的命令）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void RunLoopSourcePerformRoutine (void *info)
{
    RunLoopSource*  obj = (RunLoopSource*)info;
    [obj sourceFired];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;f you ever remove your input source from its run loop using the &lt;code class=&quot;highlighter-rouge&quot;&gt;CFRunLoopSourceInvalidate&lt;/code&gt; function, the system calls your input source’s cancellation routine. You can use this routine to notify clients that your input source is no longer valid and that they should remove any references to it&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果你使用CFRunLoopSourceInvalidate这个函数来将input source移除，系统会调input source的移除例程函数，你可以用这个例程函数来通知客户端你的input source不再可用而且应该移除相关。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void RunLoopSourceCancelRoutine (void *info, CFRunLoopRef rl, CFStringRef mode)
{
    RunLoopSource* obj = (RunLoopSource*)info;
    AppDelegate* del = [AppDelegate sharedAppDelegate];
    RunLoopContext* theContext = [[RunLoopContext alloc] initWithSource:obj andLoop:rl];
 
    [del performSelectorOnMainThread:@selector(removeSource:)
                                withObject:theContext waitUntilDone:YES];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;将input-source放入runloop&quot;&gt;将input source放入runloop&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;Installation of the input source does not occur until the worker thread invokes the &lt;code class=&quot;highlighter-rouge&quot;&gt;addToCurrentRunLoop&lt;/code&gt; method, at which point the &lt;code class=&quot;highlighter-rouge&quot;&gt;RunLoopSourceScheduleRoutine&lt;/code&gt; callback function is called. Once the input source is added to the run loop, the thread can run its run loop to wait on it.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在工作线程调用addToCurrentRunLoop方法之前，input source并不会install，这个时候会调用RunLoopSourceScheduleRoutine回调函数，一旦input source被添加进runloop，线程就开始运行runloop.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (id)init
{
    CFRunLoopSourceContext    context = {0, self, NULL, NULL, NULL, NULL, NULL,
                                        &amp;amp;RunLoopSourceScheduleRoutine,
                                        RunLoopSourceCancelRoutine,
                                        RunLoopSourcePerformRoutine};
 
    runLoopSource = CFRunLoopSourceCreate(NULL, 0, &amp;amp;context);
    commands = [[NSMutableArray alloc] init];
 
    return self;
}
 
- (void)addToCurrentRunLoop
{
    CFRunLoopRef runLoop = CFRunLoopGetCurrent();
    CFRunLoopAddSource(runLoop, runLoopSource, kCFRunLoopDefaultMode);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;调度input-source的客户端&quot;&gt;调度input source的客户端&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;For your input source to be useful, you need to manipulate it and signal it from another thread. The whole point of an input source is to put its associated thread to sleep until there is something to do. That fact necessitates having other threads in your application know about the input source and have a way to communicate with it.&lt;/p&gt;

  &lt;p&gt;One way to notify clients about your input source is to send out registration requests when your input source is first installed on its run loop. You can register your input source with as many clients as you want, or you can simply register it with some central agency that then vends your input source to interested clients.&lt;/p&gt;

  &lt;p&gt;Listing 3-8 shows the registration method defined by the application delegate and invoked when the &lt;code class=&quot;highlighter-rouge&quot;&gt;RunLoopSource&lt;/code&gt; object’s scheduler function is called. This method receives the &lt;code class=&quot;highlighter-rouge&quot;&gt;RunLoopContext&lt;/code&gt; object provided by the &lt;code class=&quot;highlighter-rouge&quot;&gt;RunLoopSource&lt;/code&gt; object and adds it to its list of sources. This listing also shows the routine used to unregister the input source when it is removed from its run loop.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;为了使input source变得有用，需要操纵input source并从其他线程发出信号。输入源的全部要点是将线程休眠直到有事情做，这样的话就需要线程知道Input souce并与之沟通.&lt;/p&gt;

&lt;p&gt;告诉客户端关于input source的一种方法就是当input source第一次installed在runloop时放一个注册需求。你可以注册随意多的客户端，或者简单地注册到一个中央机构可以将input source转交给客户端。&lt;/p&gt;

&lt;p&gt;下面的代码显示了当调用RunloopSource对象的调度程序函数时，由程序delegate定义并调用的注册方法。这个方法接受RunLoopSource对象提供的RunLoopContext对象并将其添加到源列表里。代码还显示了当从runloop里移除input source时将其注销&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)registerSource:(RunLoopContext*)sourceInfo;
{
    [sourcesToPing addObject:sourceInfo];
}
 
- (void)removeSource:(RunLoopContext*)sourceInfo
{
    id    objToRemove = nil;
 
    for (RunLoopContext* context in sourcesToPing)
    {
        if ([context isEqual:sourceInfo])
        {
            objToRemove = context;
            break;
        }
    }
 
    if (objToRemove)
        [sourcesToPing removeObject:objToRemove];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;给input-source发出信号&quot;&gt;给input source发出信号&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;After it hands off its data to the input source, a client must signal the source and wake up its run loop. Signaling the source lets the run loop know that the source is ready to be processed. And because the thread might be asleep when the signal occurs, you should always wake up the run loop explicitly. Failing to do so might result in a delay in processing the input source.&lt;/p&gt;

  &lt;p&gt;Listing 3-9 shows the &lt;code class=&quot;highlighter-rouge&quot;&gt;fireCommandsOnRunLoop&lt;/code&gt; method of the &lt;code class=&quot;highlighter-rouge&quot;&gt;RunLoopSource&lt;/code&gt; object. Clients invoke this method when they are ready for the source to process the commands they added to the buffer&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在将数据交给input soure之后，客户端必须向souce发出信号并将runloop唤醒。向source发出信号让runloop知道source已可以被处理，并且因为线程有可能已经休眠，所以当信号发出的时候，你必须明确地唤醒runloop，否则会导致处理input source的延迟&lt;/p&gt;

&lt;p&gt;下面的代码显示了RunLoopSource对象的fireCommandsOnRunLoop方法，这个方法会在当客户端准备好source来处理添加到缓存区的命令时调用。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)fireCommandsOnRunLoop:(CFRunLoopRef)runloop
{
    CFRunLoopSourceSignal(runLoopSource);
    CFRunLoopWakeUp(runloop);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;二配置timer-sources&quot;&gt;二、配置Timer Sources&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;To create a timer source, all you have to do is create a timer object and schedule it on your run loop. In Cocoa, you use the &lt;code class=&quot;highlighter-rouge&quot;&gt;NSTimer&lt;/code&gt; class to create new timer objects, and in Core Foundation you use the &lt;code class=&quot;highlighter-rouge&quot;&gt;CFRunLoopTimerRef&lt;/code&gt; opaque type. Internally, the &lt;code class=&quot;highlighter-rouge&quot;&gt;NSTimer&lt;/code&gt; class is simply an extension of Core Foundation that provides some convenience features, like the ability to create and schedule a timer using the same method.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;创建一个timer source，你需要做的就是创建一个timer对象然后将其放入runloop，用NSTimer或者CFRunLoopTimerRef都可以。可以用下面的方法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:
scheduledTimerWithTimeInterval:invocation:repeats:
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;These methods create the timer and add it to the current thread’s run loop in the default mode (&lt;code class=&quot;highlighter-rouge&quot;&gt;NSDefaultRunLoopMode&lt;/code&gt;). You can also schedule a timer manually if you want by creating your &lt;code class=&quot;highlighter-rouge&quot;&gt;NSTimer&lt;/code&gt; object and then adding it to the run loop using the &lt;code class=&quot;highlighter-rouge&quot;&gt;addTimer:forMode:&lt;/code&gt; method of &lt;code class=&quot;highlighter-rouge&quot;&gt;NSRunLoop&lt;/code&gt;. Both techniques do basically the same thing but give you different levels of control over the timer’s configuration. For example, if you create the timer and add it to the run loop manually, you can do so using a mode other than the default mode. Listing 3-10 shows how to create timers using both techniques. The first timer has an initial delay of 1 second but then fires regularly every 0.1 seconds after that. The second timer begins firing after an initial 0.2 second delay and then fires every 0.2 seconds after that.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;上面的两个方法创建一个timer并且将它以默认模式NSDefaultRunLoopMode添加到当前线程的runloop。当然你也可以手动创建一个并用addTimer:forMode:添加进runloop.两种方法都是一样的，其中一个可以配置更多。下面的方法显示了两种方法的详细&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSRunLoop* myRunLoop = [NSRunLoop currentRunLoop];
 
// Create and schedule the first timer.
NSDate* futureDate = [NSDate dateWithTimeIntervalSinceNow:1.0];
NSTimer* myTimer = [[NSTimer alloc] initWithFireDate:futureDate
                        interval:0.1
                        target:self
                        selector:@selector(myDoFireTimer1:)
                        userInfo:nil
                        repeats:YES];
[myRunLoop addTimer:myTimer forMode:NSDefaultRunLoopMode];
 
// Create and schedule the second timer.
[NSTimer scheduledTimerWithTimeInterval:0.2
                        target:self
                        selector:@selector(myDoFireTimer2:)
                        userInfo:nil
                        repeats:YES];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下面这个是用Core Foundation来添加一个timer&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CFRunLoopRef runLoop = CFRunLoopGetCurrent();
CFRunLoopTimerContext context = {0, NULL, NULL, NULL, NULL};
CFRunLoopTimerRef timer = CFRunLoopTimerCreate(kCFAllocatorDefault, 0.1, 0.3, 0, 0,
                                        &amp;amp;myCFTimerCallback, &amp;amp;context);
 
CFRunLoopAddTimer(runLoop, timer, kCFRunLoopCommonModes);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;三配置一个port-based-input-source&quot;&gt;三、配置一个Port-Based Input Source&lt;/h3&gt;

&lt;h4 id=&quot;配置一个nsmachport对象&quot;&gt;配置一个NSMachPort对象&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;To establish a local connection with an &lt;code class=&quot;highlighter-rouge&quot;&gt;NSMachPort&lt;/code&gt; object, you create the port object and add it to your primary thread’s run loop. When launching your secondary thread, you pass the same object to your thread’s entry-point function. The secondary thread can use the same object to send messages back to your primary thread.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;要建立一个与NSMachPort对象的本地连接，你需要创建一个port对象然后将它添加到你的主要线程的runloop.当启动辅助线程时，将相同的对象传递给线程的entry-point函数。辅助线程可以使用相同的对象将消息返回主要线程&lt;/p&gt;

&lt;p&gt;下面代码显示了一个主要线程来启动一个辅助线程&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)launchThread
{
    NSPort* myPort = [NSMachPort port];
    if (myPort)
    {
        // This class handles incoming port messages.
        [myPort setDelegate:self];
 
        // Install the port as an input source on the current run loop.
        [[NSRunLoop currentRunLoop] addPort:myPort forMode:NSDefaultRunLoopMode];
 
        // Detach the thread. Let the worker release the port.
        [NSThread detachNewThreadSelector:@selector(LaunchThreadWithPort:)
               toTarget:[MyWorkerClass class] withObject:myPort];
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><author><name>Ted</name></author><summary type="html">其他两篇关于Runloop:</summary></entry></feed>