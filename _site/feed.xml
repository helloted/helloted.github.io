<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.5.1">Jekyll</generator><link href="http://www.helloted.com/feed.xml" rel="self" type="application/atom+xml" /><link href="http://www.helloted.com/" rel="alternate" type="text/html" /><updated>2017-09-21T14:01:16+08:00</updated><id>http://www.helloted.com/</id><title type="html">Helloted Blog</title><subtitle>Write your site description here. It will be used as your sites meta description as well!</subtitle><entry><title type="html">iOS设计模式</title><link href="http://www.helloted.com/2017/09/08/designPatten/" rel="alternate" type="text/html" title="iOS设计模式" /><published>2017-09-08T20:00:00+08:00</published><updated>2017-09-08T20:00:00+08:00</updated><id>http://www.helloted.com/2017/09/08/designPatten</id><content type="html" xml:base="http://www.helloted.com/2017/09/08/designPatten/">&lt;p&gt;部分代码位置&lt;a href=&quot;https://github.com/helloted/designpattern&quot;&gt;Github-设计模式&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;1单例模式singleton&quot;&gt;1、单例模式(Singleton)&lt;/h4&gt;

&lt;p&gt;概念理解：整个应用或系统只能有该类的一个实例&lt;/p&gt;

&lt;p&gt;iOS中几个常用的单例：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;UIApplication类提供了 ＋sharedAPplication方法创建和获取UIApplication单例&lt;/li&gt;
  &lt;li&gt;NSBundle类提供了 +mainBunle方法获取NSBundle单例&lt;/li&gt;
  &lt;li&gt;NSFileManager类提供了 ＋defaultManager方法创建和获得NSFileManager单例。（PS：有些时候我们得放弃使用单例模式，使用－init方法去实现一个新的实例，比如使用委托时）&lt;/li&gt;
  &lt;li&gt;NSNotificationCenter提供了 ＋defaultCenter方法创建和获取NSNotificationCenter单例（PS：该类还遵循了另一个重要的设计模式：观察者模式）&lt;/li&gt;
  &lt;li&gt;NSUserDefaults类提供了 ＋defaultUserDefaults方法去创建和获取NSUserDefaults单例&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们也可以自己去生成一个单例&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (SingleObject *)sharedSingleton{
    static SingleObject *_singleObj = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;amp;onceToken, ^{
        _singleObj = [[self alloc] init];
    });
    return _singleObj;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;2mvc模式&quot;&gt;2、MVC模式&lt;/h4&gt;

&lt;p&gt;MVC是Cocoa框架采用推荐的一种设计模式，也是iOS开发中最常用的一种模式，是由各种类型的设计模式组成的复合结构&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;M-Model:&lt;/code&gt; “模型”封装应用程序的数据，模型对象维护应用程序的数据，并定义操作数据的特定逻辑。模型对象可以复用，因为它表示的知识适用于特定问题的领域。理想状况下，模型对象同用于进行显示和编辑的用户界面之间不应有任何直接的关联。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;V-View&lt;/code&gt;: “视图”显示和编辑数据，视图对象可以响应用户操作。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;C-Controller&lt;/code&gt;: “控制器”处理前两者之间的逻辑关系。控制器对象作为中间人或者协调人，使视图得以知晓模型的变更而给予响应。控制器对象还可以作为管理其他对象的生命周期，进行设置和协调任务。&lt;/p&gt;

&lt;h4 id=&quot;3原型模式prototype&quot;&gt;3、原型模式(Prototype)&lt;/h4&gt;

&lt;p&gt;概念：使用原型实例指定对象的种类，并通过复制这个原型创建新的对象，原型模型也称为复制模式，此模式是生成对象的真实副本，以用作同一环境下其他相关事物的基础(原型)&lt;/p&gt;

&lt;p&gt;应用：NSObject的派生类提供了实现深复制的协议，其他类需要实现NSCopying协议及其方法&lt;code class=&quot;highlighter-rouge&quot;&gt;-(id)copyWithZone:(NSZone *)zone&lt;/code&gt;来实现&lt;code class=&quot;highlighter-rouge&quot;&gt;-(id)copy&lt;/code&gt;方法，否则会引发异常。思路是复制必需的成员变量与资源，传给此类的新实例。&lt;/p&gt;

&lt;h4 id=&quot;4简单工厂模式simple-factory&quot;&gt;4、简单工厂模式(Simple Factory)&lt;/h4&gt;

&lt;p&gt;概念：提供一个创建实例的接口，根据传入值不一样来获取不一样的类&lt;/p&gt;

&lt;p&gt;应用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AnimalFactory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;NSObject&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Animal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;createAnimalyWithType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;5工厂方法模式factory-method&quot;&gt;5、工厂方法模式(Factory Method)&lt;/h4&gt;

&lt;p&gt;概念：封装类中不变的部分，提取其中个性化善变的部分为独立类，通过依赖注入以达到解耦、复用和方便后期维护拓展的目的.定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中&lt;/p&gt;

&lt;p&gt;应用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AnimalFactory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;NSObject&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Animal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;createAnimal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DogFactory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;AnimalFactory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DogFactory&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Animal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;createAnimal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#Dog继承自Animal
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;retrurn&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dog&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CatFactory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;AnimalFactory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Cat&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Factory&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Animal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;createAnimal&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;retrurn&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cat&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;6抽象工厂模式abstract-factory&quot;&gt;6、抽象工厂模式(Abstract Factory)&lt;/h4&gt;

&lt;p&gt;概念：提供一个创建一系列相关或者相互依赖对象的接口，而无需指定它们具体的类&lt;/p&gt;

&lt;p&gt;应用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AnimalFactory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;NSObject&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dog&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;createDog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;createCat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Cocoa中的NSNumber也是如此，numberWithBool:和numberWithInt:分别返回的是NSCFBoolean、NSCFNumber类型&lt;/p&gt;

&lt;h4 id=&quot;7生成器模式builder&quot;&gt;7、生成器模式(Builder)&lt;/h4&gt;

&lt;p&gt;概念：将一个复杂对象的构建与它的表现分离，通过分层来构建对象。领导者-&amp;gt;生成者-&amp;gt;产品。领导者提供原料，生产者去实现加工成产品，不同的生产者提供不同等级的产品&lt;/p&gt;

&lt;p&gt;应用：&lt;a href=&quot;https://github.com/helloted/designpattern&quot;&gt;Github-设计模式&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;与抽象工厂模式的区别：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;生成器构建复杂对象，抽象工厂构建简单或者复杂对象；&lt;/li&gt;
  &lt;li&gt;生成器以多个步骤构建对象，抽象工厂以单一步骤构建对象；&lt;/li&gt;
  &lt;li&gt;生成器以多种方式构建对象昂，抽象工厂以单一步骤构建对象；&lt;/li&gt;
  &lt;li&gt;生成器在构建过程的最后一步返回产品，抽象工厂立刻返回产品；&lt;/li&gt;
  &lt;li&gt;生成器专注一个特定产品的不同等级，抽象工厂强调一套产品。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;8适配器模式adapter&quot;&gt;8、适配器模式(Adapter)&lt;/h4&gt;

&lt;p&gt;概念：有时也称为“包装器”(Wrapper)，用于连接两种不同种类的对象，使其毫无问题地协同工作，将一个类的接口转换成客户希望的另外一个接口&lt;/p&gt;

&lt;p&gt;应用：&lt;code class=&quot;highlighter-rouge&quot;&gt;-(void)laodData:(AModel*)model ;&lt;/code&gt;,我们的视图需要一个AModel，但此时有一个BModel，就需要一个适配器来适配BModel,&lt;code class=&quot;highlighter-rouge&quot;&gt;-(AModel *)adapterfrom(BModel *)model&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;优点：&lt;/p&gt;

&lt;p&gt;解耦合，让视图类不合数据类产生耦合，使视图类更加独立。  新增加数据类的时候不需要修改视图类。&lt;/p&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;p&gt;会新增加很多类，使系统更凌乱，代码可读性更弱了。&lt;/p&gt;

&lt;h4 id=&quot;9桥接模式bridge&quot;&gt;9、桥接模式(Bridge)&lt;/h4&gt;

&lt;p&gt;概念：桥接模式的目的是把抽象层次结构从其实现中分离出来，使其能够独立变更。抽象层定义了供客户端使用的上层的抽象接口。实现层定义了供抽象层使用的底层接口。实现类的引用被封装于抽象层的实例中，桥接就形成。（与外观模式有一定的相似之处）。&lt;/p&gt;

&lt;p&gt;应用：&lt;a href=&quot;https://github.com/helloted/designpattern/tree/master/Designpattern/DesignPattern/Bridge&quot;&gt;桥接模式-Bridge&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;优点：&lt;/p&gt;

&lt;p&gt;桥接模式使用聚合关系，解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。
提高了系统的可扩展性，可以独立地对抽象部分和实现部分进行扩展。
可减少子类的个数，这个在前面讲手机示例的时候进行分析了。&lt;/p&gt;

&lt;p&gt;缺点：桥接模式的引入会增加系统的理解与设计难度，由于聚合关系建立在抽象层，要求开发者针对抽象进行设计与编程。
桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。&lt;/p&gt;

&lt;h4 id=&quot;10外观模式facade&quot;&gt;10、外观模式(Facade)&lt;/h4&gt;

&lt;p&gt;概念：为系统中的一组接口提供一个统一的接口&lt;/p&gt;

&lt;p&gt;应用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Facade&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NSObject&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;createApp&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NSObject&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;instancetype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;init&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ios_dev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IosDev&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;andriod_dev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AndroidDev&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;server_dev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ServerDev&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;createApp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ios_dev&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ios&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;andriod_dev&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;android&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;server_dev&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;server&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;11中介者模式mediator&quot;&gt;11、中介者模式(Mediator)&lt;/h4&gt;

&lt;p&gt;概念：用一个对象来封装一系列对象的交互方式，中介者使各对象不需要显式地相互引用，从而使其耦合松散。&lt;/p&gt;

&lt;p&gt;应用：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_1/07.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_1/08.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/helloted/designpattern/tree/master/Designpattern/DesignPattern/Mediator&quot;&gt;中介者模式-Mediator&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;12观察者模式observer&quot;&gt;12、观察者模式(Observer)&lt;/h4&gt;

&lt;p&gt;概念：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新&lt;/p&gt;

&lt;p&gt;应用：Notification、KVO。&lt;/p&gt;

&lt;h4 id=&quot;13组合模式composite&quot;&gt;13、组合模式(Composite)&lt;/h4&gt;

&lt;p&gt;概念：把具有相同基类类型的对象组合到树形结构中，以表示“部分－整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。组合模式使得树形结构中的每个节点都具有相同的抽象接口，整个结构可作为一个统一的抽象结构使用，而不暴露其内部表示。每个节点的任何操作，可以通过抽象基类中定义的相同接口来进行。&lt;/p&gt;

&lt;p&gt;应用：UIView对象被组合成一个树形结构，UIView对象可以包含其他的UIView对象。这种组合方式便于统一用于事件处理，例如处理渲染事件时，事件会在父视图中被处理，然后在传递给子视图，因为他们都是相同的类型，事件可以传递到树形结构的每一视图。&lt;/p&gt;

&lt;p&gt;优点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可以使用简单的基本对象组合成较为复杂的组合对象，复杂组合对象又可以组合成更为复杂的对象，如此递归循环。但是使用简单对象和使用复杂组合对象是无差别的&lt;/li&gt;
  &lt;li&gt;简化客户单代码，同时使得创建同类型的复杂对象更简单。因为客户端不需要区分单个对象还是组合对象，所以不必写if-else之类的各种判断&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;14迭代器模式composite&quot;&gt;14、迭代器模式(Composite)&lt;/h4&gt;

&lt;p&gt;概念：提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示&lt;/p&gt;

&lt;p&gt;应用：NSEnumerator,&lt;code class=&quot;highlighter-rouge&quot;&gt;enumerateObjectsUsingBlock:(void(^)(id obj, NSUInteger idx, BOOL *stop))block&lt;/code&gt;  等等&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;NSObject&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;First&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BOOL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IsDone&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CurrentItem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;15访问者模式vistor&quot;&gt;15、访问者模式(Vistor)&lt;/h4&gt;

&lt;p&gt;概念：表示一个作用于表示一个作用于某对象结构中的各个元素的操作，它让我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作&lt;/p&gt;

&lt;p&gt;应用：这用于某个对象结构中的元素数目比较固定（基本不会变动），而对于这些元素的操作可能要变化（增加新操作），vistor提供了在某个状态下，对对象结构中各元素的不同操作的访问接口，对象中使用accept接口接受一个具体的访问者。符合open-close原则。&lt;/p&gt;

&lt;p&gt;访问者模式适用于数据结构相对稳定的系统，它把数据结构和作用于结构上的操作之间的耦合解开，使得操作集合可以相对自由地演化。&lt;/p&gt;

&lt;p&gt;访问者模式的优点就是增加新的操作很容易，因为增加新的操作就意味着增加一个新的访问者。访问者模式将有关的行为集中到一个访问者对象中。缺点是是增加新的数据结构变得复杂&lt;/p&gt;

&lt;h4 id=&quot;16装饰者模式decorator&quot;&gt;16、装饰者模式(Decorator)&lt;/h4&gt;

&lt;p&gt;概念：是面向对象编程领域中，一种动态地往一个类中添加新的行为的设计模式。就功能而言，修饰模式相比生成子类更为灵活，这样可以给某个对象而不是整个类添加一些功能&lt;/p&gt;

&lt;p&gt;应用：Category,Delegate&lt;/p&gt;

&lt;h4 id=&quot;17责任链模式chain-of-responsibility&quot;&gt;17、责任链模式(Chain of Responsibility)&lt;/h4&gt;

&lt;p&gt;概念：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间发生耦合。此模式将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。&lt;/p&gt;

&lt;p&gt;应用：响应者链条&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;降低耦合度。
可简化对象的相互连接。
增强给对象指派职责的灵活性。
增加新的请求处理类很方便。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;不能保证请求一定被接收。
系统性能将受到一定影响，而且在进行代码调试时不太方便（可能会造成循环调用）。&lt;/p&gt;

&lt;h4 id=&quot;18模板方法模式template-method&quot;&gt;18、模板方法模式(Template Method)&lt;/h4&gt;

&lt;p&gt;概念：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。核心思想就是通过把不变的行为搬移到超类，去除子类中的重复代码来体现它的优势。其实，模板方法模式就是提供了一个很好的代码复用平台。定义一个父类，有父类定义接口规范，然后不同的行为在子类中实现。这样一方面提高了代码的复用性，另一方面还可以利用面向对象的多态性，在运行时选择一种具体子类&lt;/p&gt;

&lt;p&gt;应用：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;模板模式和策略模式的不同点：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;（1）策略模式的应用场景:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;多个类的区别只是在于行为不同。&lt;/li&gt;
  &lt;li&gt;你需要行为的算法做很多变动。&lt;/li&gt;
  &lt;li&gt;客户端不知道算法使用的数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;（2）模板模式的使用场景：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;相同的算法放在一个类中（父类）将算法变化的部分放在子类中。&lt;/li&gt;
  &lt;li&gt;子类公共的算法放在一个公共类中，避免代码重复。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Ted</name></author><summary type="html">部分代码位置Github-设计模式</summary></entry><entry><title type="html">热修复=Runtime+Javascriptcore</title><link href="http://www.helloted.com/2017/05/30/hotfix/" rel="alternate" type="text/html" title="热修复=Runtime+Javascriptcore" /><published>2017-05-30T20:00:00+08:00</published><updated>2017-05-30T20:00:00+08:00</updated><id>http://www.helloted.com/2017/05/30/hotfix</id><content type="html" xml:base="http://www.helloted.com/2017/05/30/hotfix/">&lt;h3 id=&quot;一运行时&quot;&gt;一、运行时&lt;/h3&gt;

&lt;p&gt;热修复的基本原理就是Runtime运行时的方法替换，主要是下列几个方法&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;class_replaceMethod&lt;/code&gt;:方法替换&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;method_exchangeImplementations&lt;/code&gt;:IMP交换&lt;/p&gt;

&lt;p&gt;实例，当我们要对某个类的old_method方法以new_method方法替换掉，则新建一个Category，在其load类方法(Load方法每次APP加载都会调用)中实现以下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    static dispatch_once_t onceToken;
    dispatch_once(&amp;amp;onceToken, ^{
        Class class = [self class];
        
        SEL originalSelector = @selector(old_method);
        SEL swizzledSelector = @selector(new_method);
        
        Method originalMethod = class_getInstanceMethod(class, originalSelector);
        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);
        
        
        BOOL didAddMethod =
        class_addMethod(class,
                        originalSelector,
                        method_getImplementation(swizzledMethod),
                        method_getTypeEncoding(swizzledMethod));
        
        if (didAddMethod) {
            class_replaceMethod(class,
                                swizzledSelector,
                                method_getImplementation(originalMethod),
                                method_getTypeEncoding(originalMethod));
        } else {
            method_exchangeImplementations(originalMethod, swizzledMethod);
        }
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;二javascriptcore&quot;&gt;二、Javascriptcore&lt;/h3&gt;

&lt;p&gt;Javascriptcore是一个iOS原生框架，用于javascript与Objecive C语言进行相互调用，而我们热修改需要用到的就是javascript可以调用OC方法&lt;/p&gt;

&lt;p&gt;三、热修复&lt;/p&gt;</content><author><name>Ted</name></author><summary type="html">一、运行时</summary></entry><entry><title type="html">iOS之Runloop(3):应用</title><link href="http://www.helloted.com/2017/04/16/Runloop_3/" rel="alternate" type="text/html" title="iOS之Runloop(3):应用" /><published>2017-04-16T20:00:00+08:00</published><updated>2017-04-16T20:00:00+08:00</updated><id>http://www.helloted.com/2017/04/16/Runloop_3</id><content type="html" xml:base="http://www.helloted.com/2017/04/16/Runloop_3/">&lt;p&gt;其他两篇关于Runloop:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.helloted.com/2017/04/10/Runloop_1/&quot;&gt;iOS之Runloop(1):基础&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.helloted.com/2017/04/16/Runloop_2/&quot;&gt;iOS之Runloop(2):事件源&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;前：&lt;/p&gt;

&lt;p&gt;1、线程创建需要的内存和时间消耗都比较大，因此建议你的入口点函数做相当数量的工作，或建立一个Run Loops允许进行经常性的工作。
2、Run Loops可以让你使用最小的资源来创建长时间运行线程。因为run loop在没有任何事件处理的时候会把它的线程置于休眠状态，它消除了消耗CPU周期轮询，并防止处理器本身进入休眠状态并节省电源。&lt;/p&gt;

&lt;p&gt;RunLoop，就是一个循环，只是这个循环里加入很多特性。 首先循环体的开始需要检测是否有需要处理的事件，如果有则去处理，如果没有则进入睡眠以节省CPU时间。所以重点便是这个需要处理的事件，在RunLoop中，需要处理的事件分两类，一种是输入源，一种是定时器，定时器好理解就是那些需要定时执行的操作，输入源分三类：performSelector源，基于端口（Mach port）的源，以及自定义的源。编程的时候可以添加自己的源&lt;/p&gt;

&lt;h4 id=&quot;1autoreleasepool&quot;&gt;1、AutoreleasePool&lt;/h4&gt;

&lt;p&gt;App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。&lt;/p&gt;

&lt;p&gt;第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。&lt;/p&gt;

&lt;p&gt;第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。&lt;/p&gt;

&lt;p&gt;在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。&lt;/p&gt;

&lt;h4 id=&quot;2定时器&quot;&gt;2、定时器&lt;/h4&gt;

&lt;p&gt;NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。&lt;/p&gt;

&lt;p&gt;如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。&lt;/p&gt;

&lt;p&gt;CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。&lt;/p&gt;

&lt;h4 id=&quot;3performselector&quot;&gt;3、PerformSelector&lt;/h4&gt;

&lt;p&gt;当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。&lt;/p&gt;

&lt;p&gt;当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。&lt;/p&gt;

&lt;h4 id=&quot;4事件响应&quot;&gt;4、事件响应&lt;/h4&gt;

&lt;p&gt;苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。&lt;/p&gt;

&lt;p&gt;当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。&lt;/p&gt;

&lt;p&gt;_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。&lt;/p&gt;

&lt;h4 id=&quot;5手势识别&quot;&gt;5、手势识别&lt;/h4&gt;

&lt;p&gt;当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。&lt;/p&gt;

&lt;p&gt;苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。&lt;/p&gt;

&lt;p&gt;当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。&lt;/p&gt;

&lt;h4 id=&quot;6界面更新&quot;&gt;6、界面更新&lt;/h4&gt;

&lt;p&gt;当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。&lt;/p&gt;

&lt;p&gt;苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：&lt;/p&gt;

&lt;p&gt;_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()
    QuartzCore:CA::Transaction::observer_callback:
        CA::Transaction::commit();
            CA::Context::commit_transaction();
                CA::Layer::layout_and_display_if_needed();
                    CA::Layer::layout_if_needed();
                        [CALayer layoutSublayers];
                            [UIView layoutSubviews];
                    CA::Layer::display_if_needed();
                        [CALayer display];
                            [UIView drawRect];
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;7关于gcd&quot;&gt;7、关于GCD&lt;/h4&gt;

&lt;p&gt;实际上 RunLoop 底层也会用到 GCD 的东西。但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()&lt;/p&gt;

&lt;p&gt;当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 &lt;strong&gt;CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE&lt;/strong&gt;() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。&lt;/p&gt;

&lt;h4 id=&quot;8关于网络请求&quot;&gt;8、关于网络请求&lt;/h4&gt;

&lt;p&gt;iOS 中，关于网络请求的接口自下至上有如下几层:&lt;/p&gt;

&lt;p&gt;• CFSocket 是最底层的接口，只负责 socket 通信。&lt;/p&gt;

&lt;p&gt;• CFNetwork 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作于这一层。&lt;/p&gt;

&lt;p&gt;• NSURLConnection 是基于 CFNetwork 的更高层的封装，提供面向对象的接口，AFNetworking 工作于这一层。&lt;/p&gt;

&lt;p&gt;• NSURLSession 是 iOS7 中新增的接口，表面上是和 NSURLConnection 并列的，但底层仍然用到了 NSURLConnection 的部分功能 (比如com.apple.NSURLConnectionLoader 线程)，AFNetworking2 和 Alamofire 工作于这一层。&lt;/p&gt;

&lt;p&gt;下面主要介绍下 NSURLConnection 的工作过程。&lt;/p&gt;

&lt;p&gt;通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。&lt;/p&gt;

&lt;p&gt;当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。&lt;/p&gt;

&lt;p&gt;NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。&lt;/p&gt;</content><author><name>Ted</name></author><summary type="html">其他两篇关于Runloop:</summary></entry><entry><title type="html">iOS之Runloop(2):事件源</title><link href="http://www.helloted.com/2017/04/16/Runloop_2/" rel="alternate" type="text/html" title="iOS之Runloop(2):事件源" /><published>2017-04-16T20:00:00+08:00</published><updated>2017-04-16T20:00:00+08:00</updated><id>http://www.helloted.com/2017/04/16/Runloop_2</id><content type="html" xml:base="http://www.helloted.com/2017/04/16/Runloop_2/">&lt;p&gt;其他两篇关于Runloop:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.helloted.com/2017/04/10/Runloop_1/&quot;&gt;iOS之Runloop(2):基础&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.helloted.com/2017/04/16/Runloop_3/&quot;&gt;iOS之Runloop(3):应用&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;苹果官方文档：&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW7&quot;&gt;Run loops&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;一定义一个custom-input-source&quot;&gt;一、定义一个Custom Input Source&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Creating a custom input source involves defining the following:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;The information you want your input source to process.&lt;/li&gt;
    &lt;li&gt;A scheduler routine to let interested clients know how to contact your input source.&lt;/li&gt;
    &lt;li&gt;A handler routine to perform requests sent by any clients.&lt;/li&gt;
    &lt;li&gt;A cancellation routine to invalidate your input source.&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;Because you create a custom input source to process custom information, the actual configuration is designed to be flexible. The scheduler, handler, and cancellation routines are the key routines you almost always need for your custom input source. Most of the rest of the input source behavior, however, happens outside of those handler routines. For example, it is up to you to define the mechanism for passing data to your input source and for communicating the presence of your input source to other threads.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;创建一个自定义的input source需要涉及以下几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;需要input source处理的信息&lt;/li&gt;
  &lt;li&gt;调度程序让需要的端口知道怎么连接你的input source&lt;/li&gt;
  &lt;li&gt;可用的程序来处理任意端口发出的请求&lt;/li&gt;
  &lt;li&gt;有程序来取消input source&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因为创建一个自定义的input source来处理自定义信息，可配置的还是很灵活的，调度程序、处理程序和取消是关键。其他的input source就是在这些程序之外。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Figure shows a sample configuration of a custom input source. In this example, the application’s main thread maintains references to the input source, the custom command buffer for that input source, and the run loop on which the input source is installed. When the main thread has a task it wants to hand off to the worker thread, it posts a command to the command buffer along with any information needed by the worker thread to start the task. (Because both the main thread and the input source of the worker thread have access to the command buffer, that access must be synchronized.) Once the command is posted, the main thread signals the input source and wakes up the worker thread’s run loop. Upon receiving the wake up command, the run loop calls the handler for the input source, which processes the commands found in the command buffer&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下图展示了配置一个自定义input sources，主线程操控维护了input source的引用、input source的命令缓存区、input source安装在的那个runloop。当主线程有任务想要交给工作线程去处理，主线程发送命令到command buffer命令缓存区(命令带了工作线程工作所需的)。主线程和工作线程的input source都可以访问command buffer命令缓存区，所以这个访问必须是同步的。一旦命令发出，主线程通知input source并且唤醒工作线程的runloop。runloop一旦接到唤醒命令，runloop就会回调处理方法给input source，处理在command buffer命令缓存区里找到的命令。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Runloop/runloop_05.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RunLoopSource&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NSObject&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;CFRunLoopSourceRef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;runLoopSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;NSMutableArray&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;commands&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addToCurrentRunLoop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;invalidate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 
&lt;span class=&quot;c1&quot;&gt;// Handler method
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sourceFired&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 
&lt;span class=&quot;c1&quot;&gt;// Client interface for registering commands to process
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;addCommand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSInteger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;command&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;withData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;fireAllCommandsOnRunLoop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CFRunLoopRef&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;runloop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;RunLoopSource&lt;/code&gt; object manages a command buffer and uses that buffer to receive messages from other threads&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;RunLoopSource对象管理了一个command buffer并且用buffer来从其他线程接受信息。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// These are the CFRunLoopSourceRef callback functions.
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RunLoopSourceScheduleRoutine&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CFRunLoopRef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CFStringRef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RunLoopSourcePerformRoutine&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RunLoopSourceCancelRoutine&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CFRunLoopRef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CFStringRef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 
&lt;span class=&quot;c1&quot;&gt;// RunLoopContext is a container object used during registration of the input source.
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RunLoopContext&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NSObject&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;CFRunLoopRef&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;runLoop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;RunLoopSource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readonly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CFRunLoopRef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;runLoop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readonly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RunLoopSource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;initWithSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RunLoopSource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;src&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;andLoop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CFRunLoopRef&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RunLoopContext&lt;/code&gt; object, which is really just a container object used to pass a &lt;code class=&quot;highlighter-rouge&quot;&gt;RunLoopSource&lt;/code&gt; object and a run loop reference to the application’s main thread.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;RunLoopContext对象是一个容器，用来传递RunLoopSource对象和runloop引用给主线程。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The first of these functions is called when you actually attach the run loop source to your run loop，Because this input source has only one client (the main thread), it uses the scheduler function to send a message to register itself with the application delegate on that thread. When the delegate wants to communicate with the input source, it uses the information in &lt;code class=&quot;highlighter-rouge&quot;&gt;RunLoopContext&lt;/code&gt; object to do so&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当你把runloop source放入到runloop时，实际会调用下面这个函数。因为input source只有一个端口（主线程），input source使用调度函数来发送一个消息从而注册他本身到线程的delegate上，当delegate用&lt;code class=&quot;highlighter-rouge&quot;&gt;RunLoopContext&lt;/code&gt;与input source交流，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void RunLoopSourceScheduleRoutine (void *info, CFRunLoopRef rl, CFStringRef mode)
{
    RunLoopSource* obj = (RunLoopSource*)info;
    AppDelegate*   del = [AppDelegate sharedAppDelegate];
    RunLoopContext* theContext = [[RunLoopContext alloc] initWithSource:obj andLoop:rl];
 
    [del performSelectorOnMainThread:@selector(registerSource:)
                                withObject:theContext waitUntilDone:NO];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;One of the most important callback routines is the one used to process custom data when your input source is signaled. Listing 3-5 shows the perform callback routine associated with the &lt;code class=&quot;highlighter-rouge&quot;&gt;RunLoopSource&lt;/code&gt; object. This function simply forwards the request to do the work to the &lt;code class=&quot;highlighter-rouge&quot;&gt;sourceFired&lt;/code&gt; method, which then processes any commands present in the command buffer.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最重要之一的回调是当input sour发完信号时处理自定义的数据，下面的代码展示了RunLoopSource的处理回调。这个函数简单地将需求转发到sourceFired方法（处理任何在命令缓存池的命令）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void RunLoopSourcePerformRoutine (void *info)
{
    RunLoopSource*  obj = (RunLoopSource*)info;
    [obj sourceFired];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;f you ever remove your input source from its run loop using the &lt;code class=&quot;highlighter-rouge&quot;&gt;CFRunLoopSourceInvalidate&lt;/code&gt; function, the system calls your input source’s cancellation routine. You can use this routine to notify clients that your input source is no longer valid and that they should remove any references to it&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果你使用CFRunLoopSourceInvalidate这个函数来将input source移除，系统会调input source的移除例程函数，你可以用这个例程函数来通知客户端你的input source不再可用而且应该移除相关。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void RunLoopSourceCancelRoutine (void *info, CFRunLoopRef rl, CFStringRef mode)
{
    RunLoopSource* obj = (RunLoopSource*)info;
    AppDelegate* del = [AppDelegate sharedAppDelegate];
    RunLoopContext* theContext = [[RunLoopContext alloc] initWithSource:obj andLoop:rl];
 
    [del performSelectorOnMainThread:@selector(removeSource:)
                                withObject:theContext waitUntilDone:YES];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;将input-source放入runloop&quot;&gt;将input source放入runloop&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;Installation of the input source does not occur until the worker thread invokes the &lt;code class=&quot;highlighter-rouge&quot;&gt;addToCurrentRunLoop&lt;/code&gt; method, at which point the &lt;code class=&quot;highlighter-rouge&quot;&gt;RunLoopSourceScheduleRoutine&lt;/code&gt; callback function is called. Once the input source is added to the run loop, the thread can run its run loop to wait on it.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在工作线程调用addToCurrentRunLoop方法之前，input source并不会install，这个时候会调用RunLoopSourceScheduleRoutine回调函数，一旦input source被添加进runloop，线程就开始运行runloop.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (id)init
{
    CFRunLoopSourceContext    context = {0, self, NULL, NULL, NULL, NULL, NULL,
                                        &amp;amp;RunLoopSourceScheduleRoutine,
                                        RunLoopSourceCancelRoutine,
                                        RunLoopSourcePerformRoutine};
 
    runLoopSource = CFRunLoopSourceCreate(NULL, 0, &amp;amp;context);
    commands = [[NSMutableArray alloc] init];
 
    return self;
}
 
- (void)addToCurrentRunLoop
{
    CFRunLoopRef runLoop = CFRunLoopGetCurrent();
    CFRunLoopAddSource(runLoop, runLoopSource, kCFRunLoopDefaultMode);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;调度input-source的客户端&quot;&gt;调度input source的客户端&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;For your input source to be useful, you need to manipulate it and signal it from another thread. The whole point of an input source is to put its associated thread to sleep until there is something to do. That fact necessitates having other threads in your application know about the input source and have a way to communicate with it.&lt;/p&gt;

  &lt;p&gt;One way to notify clients about your input source is to send out registration requests when your input source is first installed on its run loop. You can register your input source with as many clients as you want, or you can simply register it with some central agency that then vends your input source to interested clients.&lt;/p&gt;

  &lt;p&gt;Listing 3-8 shows the registration method defined by the application delegate and invoked when the &lt;code class=&quot;highlighter-rouge&quot;&gt;RunLoopSource&lt;/code&gt; object’s scheduler function is called. This method receives the &lt;code class=&quot;highlighter-rouge&quot;&gt;RunLoopContext&lt;/code&gt; object provided by the &lt;code class=&quot;highlighter-rouge&quot;&gt;RunLoopSource&lt;/code&gt; object and adds it to its list of sources. This listing also shows the routine used to unregister the input source when it is removed from its run loop.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;为了使input source变得有用，需要操纵input source并从其他线程发出信号。输入源的全部要点是将线程休眠直到有事情做，这样的话就需要线程知道Input souce并与之沟通.&lt;/p&gt;

&lt;p&gt;告诉客户端关于input source的一种方法就是当input source第一次installed在runloop时放一个注册需求。你可以注册随意多的客户端，或者简单地注册到一个中央机构可以将input source转交给客户端。&lt;/p&gt;

&lt;p&gt;下面的代码显示了当调用RunloopSource对象的调度程序函数时，由程序delegate定义并调用的注册方法。这个方法接受RunLoopSource对象提供的RunLoopContext对象并将其添加到源列表里。代码还显示了当从runloop里移除input source时将其注销&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)registerSource:(RunLoopContext*)sourceInfo;
{
    [sourcesToPing addObject:sourceInfo];
}
 
- (void)removeSource:(RunLoopContext*)sourceInfo
{
    id    objToRemove = nil;
 
    for (RunLoopContext* context in sourcesToPing)
    {
        if ([context isEqual:sourceInfo])
        {
            objToRemove = context;
            break;
        }
    }
 
    if (objToRemove)
        [sourcesToPing removeObject:objToRemove];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;给input-source发出信号&quot;&gt;给input source发出信号&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;After it hands off its data to the input source, a client must signal the source and wake up its run loop. Signaling the source lets the run loop know that the source is ready to be processed. And because the thread might be asleep when the signal occurs, you should always wake up the run loop explicitly. Failing to do so might result in a delay in processing the input source.&lt;/p&gt;

  &lt;p&gt;Listing 3-9 shows the &lt;code class=&quot;highlighter-rouge&quot;&gt;fireCommandsOnRunLoop&lt;/code&gt; method of the &lt;code class=&quot;highlighter-rouge&quot;&gt;RunLoopSource&lt;/code&gt; object. Clients invoke this method when they are ready for the source to process the commands they added to the buffer&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在将数据交给input soure之后，客户端必须向souce发出信号并将runloop唤醒。向source发出信号让runloop知道source已可以被处理，并且因为线程有可能已经休眠，所以当信号发出的时候，你必须明确地唤醒runloop，否则会导致处理input source的延迟&lt;/p&gt;

&lt;p&gt;下面的代码显示了RunLoopSource对象的fireCommandsOnRunLoop方法，这个方法会在当客户端准备好source来处理添加到缓存区的命令时调用。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)fireCommandsOnRunLoop:(CFRunLoopRef)runloop
{
    CFRunLoopSourceSignal(runLoopSource);
    CFRunLoopWakeUp(runloop);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;二配置timer-sources&quot;&gt;二、配置Timer Sources&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;To create a timer source, all you have to do is create a timer object and schedule it on your run loop. In Cocoa, you use the &lt;code class=&quot;highlighter-rouge&quot;&gt;NSTimer&lt;/code&gt; class to create new timer objects, and in Core Foundation you use the &lt;code class=&quot;highlighter-rouge&quot;&gt;CFRunLoopTimerRef&lt;/code&gt; opaque type. Internally, the &lt;code class=&quot;highlighter-rouge&quot;&gt;NSTimer&lt;/code&gt; class is simply an extension of Core Foundation that provides some convenience features, like the ability to create and schedule a timer using the same method.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;创建一个timer source，你需要做的就是创建一个timer对象然后将其放入runloop，用NSTimer或者CFRunLoopTimerRef都可以。可以用下面的方法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:
scheduledTimerWithTimeInterval:invocation:repeats:
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;These methods create the timer and add it to the current thread’s run loop in the default mode (&lt;code class=&quot;highlighter-rouge&quot;&gt;NSDefaultRunLoopMode&lt;/code&gt;). You can also schedule a timer manually if you want by creating your &lt;code class=&quot;highlighter-rouge&quot;&gt;NSTimer&lt;/code&gt; object and then adding it to the run loop using the &lt;code class=&quot;highlighter-rouge&quot;&gt;addTimer:forMode:&lt;/code&gt; method of &lt;code class=&quot;highlighter-rouge&quot;&gt;NSRunLoop&lt;/code&gt;. Both techniques do basically the same thing but give you different levels of control over the timer’s configuration. For example, if you create the timer and add it to the run loop manually, you can do so using a mode other than the default mode. Listing 3-10 shows how to create timers using both techniques. The first timer has an initial delay of 1 second but then fires regularly every 0.1 seconds after that. The second timer begins firing after an initial 0.2 second delay and then fires every 0.2 seconds after that.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;上面的两个方法创建一个timer并且将它以默认模式NSDefaultRunLoopMode添加到当前线程的runloop。当然你也可以手动创建一个并用addTimer:forMode:添加进runloop.两种方法都是一样的，其中一个可以配置更多。下面的方法显示了两种方法的详细&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSRunLoop* myRunLoop = [NSRunLoop currentRunLoop];
 
// Create and schedule the first timer.
NSDate* futureDate = [NSDate dateWithTimeIntervalSinceNow:1.0];
NSTimer* myTimer = [[NSTimer alloc] initWithFireDate:futureDate
                        interval:0.1
                        target:self
                        selector:@selector(myDoFireTimer1:)
                        userInfo:nil
                        repeats:YES];
[myRunLoop addTimer:myTimer forMode:NSDefaultRunLoopMode];
 
// Create and schedule the second timer.
[NSTimer scheduledTimerWithTimeInterval:0.2
                        target:self
                        selector:@selector(myDoFireTimer2:)
                        userInfo:nil
                        repeats:YES];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下面这个是用Core Foundation来添加一个timer&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CFRunLoopRef runLoop = CFRunLoopGetCurrent();
CFRunLoopTimerContext context = {0, NULL, NULL, NULL, NULL};
CFRunLoopTimerRef timer = CFRunLoopTimerCreate(kCFAllocatorDefault, 0.1, 0.3, 0, 0,
                                        &amp;amp;myCFTimerCallback, &amp;amp;context);
 
CFRunLoopAddTimer(runLoop, timer, kCFRunLoopCommonModes);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;三配置一个port-based-input-source&quot;&gt;三、配置一个Port-Based Input Source&lt;/h3&gt;

&lt;h4 id=&quot;配置一个nsmachport对象&quot;&gt;配置一个NSMachPort对象&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;To establish a local connection with an &lt;code class=&quot;highlighter-rouge&quot;&gt;NSMachPort&lt;/code&gt; object, you create the port object and add it to your primary thread’s run loop. When launching your secondary thread, you pass the same object to your thread’s entry-point function. The secondary thread can use the same object to send messages back to your primary thread.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;要建立一个与NSMachPort对象的本地连接，你需要创建一个port对象然后将它添加到你的主要线程的runloop.当启动辅助线程时，将相同的对象传递给线程的entry-point函数。辅助线程可以使用相同的对象将消息返回主要线程&lt;/p&gt;

&lt;p&gt;下面代码显示了一个主要线程来启动一个辅助线程&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)launchThread
{
    NSPort* myPort = [NSMachPort port];
    if (myPort)
    {
        // This class handles incoming port messages.
        [myPort setDelegate:self];
 
        // Install the port as an input source on the current run loop.
        [[NSRunLoop currentRunLoop] addPort:myPort forMode:NSDefaultRunLoopMode];
 
        // Detach the thread. Let the worker release the port.
        [NSThread detachNewThreadSelector:@selector(LaunchThreadWithPort:)
               toTarget:[MyWorkerClass class] withObject:myPort];
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><author><name>Ted</name></author><summary type="html">其他两篇关于Runloop:</summary></entry><entry><title type="html">iOS之Runloop(1):基础</title><link href="http://www.helloted.com/2017/04/10/Runloop_1/" rel="alternate" type="text/html" title="iOS之Runloop(1):基础" /><published>2017-04-10T20:00:00+08:00</published><updated>2017-04-10T20:00:00+08:00</updated><id>http://www.helloted.com/2017/04/10/Runloop_1</id><content type="html" xml:base="http://www.helloted.com/2017/04/10/Runloop_1/">&lt;p&gt;其他两篇：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.helloted.com/2017/04/16/Runloop_2/&quot;&gt;iOS之Runloop(2):事件源&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.helloted.com/2017/04/16/Runloop_3/&quot;&gt;iOS之Runloop(3):应用&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;一简介&quot;&gt;一、简介&lt;/h3&gt;

&lt;p&gt;先看苹果官方文档：&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1&quot;&gt;Run loops&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Run loops are part of the fundamental infrastructure associated with threads. A runloop is an event processing loop that you use to schedule work and coordinate the receipt of incoming events. The purpose of a run loop is to keep your thread busy when there is work to do and put your thread to sleep when there is none.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Runloop是与线程相关联的基础架构的一部分，它用来接受循环事件和安排线程的工作，在有工作时让线程处于繁忙状态，没有事件需要处理时让线程休眠；&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Run loop management is not entirely automatic. You must still design your thread’s code to start the run loop at appropriate times and respond to incoming events.The app frameworks automatically set up and run the run loop on the main thread as part of the application startup process&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Runloop的管理并不是全自动的，你依然要操作线程代码在合适的时候开启Runloop然后回应传入的事件。但是主线程的例外，程序启动时，主线程的Runloop会自动开启。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A run loop is very much like its name sounds. It is a loop your thread enters and uses to run event handlers in response to incoming events.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Runloop的名字运行循环，顾名思义，是一个线程进入之后用来运行事件处理程序来响应传入的事件的循环。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Your code provides the control statements used to implement the actual loop portion of the run loop—in other words, your code provides the while or for loop that drives the run loop. Within your loop, you use a run loop object to “run” the event-processing code that receives events and calls the installed handlers.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;你的代码提供用于实现runloop的实际循环部分的控制语句 - 换句话说，你的代码提供while或for循环用于驱动Runloop。 在循环中，使用runloop对象来“运行”事件处理代码(接收事件并调用相应的事件处理方法)。&lt;/p&gt;

&lt;h3 id=&quot;二sources&quot;&gt;二、Sources&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;A run loop receives events from two different types of sources. &lt;em&gt;Input sources&lt;/em&gt; deliver asynchronous events, usually messages from another thread or from a different application. &lt;em&gt;Timer sources&lt;/em&gt; deliver synchronous events, occurring at a scheduled time or repeating interval. Both types of source use an application-specific handler routine to process the event when it arrives.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;RunLoop 接受的事件源有两种大类: &lt;em&gt;Input sources&lt;/em&gt;, &lt;em&gt;Timer sources&lt;/em&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;InputSources&lt;/strong&gt; : 传递递异步事件,通常消息来自另外的线程或者程序;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Timer sources&lt;/strong&gt;：传递同步事件，发生在预定时间或者是重复间隔；&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在事件传递到时，两种事件源都是用程序特定的例行程序来处理事件&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;从下图可以看到，&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Runloop/runloop_00.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The input sources deliver asynchronous events to the corresponding handlers and cause the &lt;em&gt;runUntilDate:&lt;/em&gt;  method (called on the thread’s associated &lt;em&gt;NSRunLoop&lt;/em&gt; object) to exit. Timer sources deliver events to their handler routines but do not cause the run loop to exit.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Input sources&lt;/em&gt; 传递异步事件给相应的方法处理，并且通过&lt;em&gt;runUntilDate:&lt;/em&gt;（由线程对应的&lt;em&gt;NSRunLoop&lt;/em&gt; 对象执行）来退出；&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Timer sources&lt;/em&gt; 传递同步事件给它们对应的例行程序来执行但是不会导致run loop退出。&lt;/p&gt;

&lt;h3 id=&quot;三input-sources&quot;&gt;三、Input Sources&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Input sources deliver events asynchronously to your threads. The source of the event depends on the type of the input source, which is generally one of two categories. Port-based input sources monitor your application’s Mach ports. Custom input sources monitor custom sources of events. As far as your run loop is concerned, it should not matter whether an input source is port-based or custom. The system typically implements input sources of both types that you can use as is. The only difference between the two sources is how they are signaled. Port-based sources are signaled automatically by the kernel, and custom sources must be signaled manually from another thread.&lt;/p&gt;

  &lt;p&gt;When you create an input source, you assign it to one or more modes of your run loop. Modes affect which input sources are monitored at any given moment. Most of the time, you run the run loop in the default mode, but you can specify custom modes too. If an input source is not in the currently monitored mode, any events it generates are held until the run loop runs in the correct mode&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Input sources&lt;/em&gt; 异步地传递事件到线程，而事件的源来至于其中一种：&lt;em&gt;Port-based input sources&lt;/em&gt;、&lt;em&gt;Custom input sources&lt;/em&gt; 这两种souces的实现处理方式都一样，区别&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Port-based input sources&lt;/em&gt; :监听程序的Mach ports，kernel自动发信号&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Custom input sources&lt;/em&gt; ：监听自定义的活动，在其他线程手动的发信号&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;Cocoa Perform Selector Sources&lt;/em&gt; : &lt;em&gt;Cocoa&lt;/em&gt; 框架定义的&lt;em&gt;Custom input sources&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;配置input-sources&quot;&gt;配置Input Sources&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Port-Based Sources通过内置的端口相关的对象和函数，配置基于端口的Input source。 (比如在主线程创建子线程时传入一个NSPort对象,主线程和子线程就可以进行通讯。NSPort对象会负责自己创建和配置Input source。)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Custom Input Sources我们可以使用Core Foundation里面的CFRunLoopSourceRef类型相关的函数来创建custom input source,系统也有提供一些方法。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Cocoa框架为我们定义了一些Custom Input Sources，允许我们在线程中执行一系列selector方法，这些在NSThread类里面。和Port-Based Sources一样，这些selector的请求会在目标线程中序列化，以减缓线程中多个方法执行带来的同步问题。和Port-Based Sources不一样的是，一个selector方法执行完之后会自动从当前Run Loop中移除。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;performSelectorOnMainThread:withObject:waitUntilDone:
performSelectorOnMainThread:withObject:waitUntilDone:modes:

performSelector:onThread:withObject:waitUntilDone:
performSelector:onThread:withObject:waitUntilDone:modes:

performSelector:withObject:afterDelay:
performSelector:withObject:afterDelay:inModes:

cancelPreviousPerformRequestsWithTarget:
cancelPreviousPerformRequestsWithTarget:selector:object:
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;四timer-sources&quot;&gt;四、Timer Sources&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Timer sources deliver events synchronously to your threads at a preset time in the future. Timers are a way for a thread to notify itself to do something.&lt;/p&gt;

  &lt;p&gt;Although it generates time-based notifications, a timer is not a real-time mechanism. Like input sources, timers are associated with specific modes of your run loop. If a timer is not in the mode currently being monitored by the run loop, it does not fire until you run the run loop in one of the timer’s supported modes. Similarly, if a timer fires when the run loop is in the middle of executing a handler routine, the timer waits until the next time through the run loop to invoke its handler routine. If the run loop is not running at all, the timer never fires.&lt;/p&gt;

  &lt;p&gt;You can configure timers to generate events only once or repeatedly. A repeating timer reschedules itself automatically based on the scheduled firing time, not the actual firing time. For example, if a timer is scheduled to fire at a particular time and every 5 seconds after that, the scheduled firing time will always fall on the original 5 second time intervals, even if the actual firing time gets delayed. If the firing time is delayed so much that it misses one or more of the scheduled firing times, the timer is fired only once for the missed time period. After firing for the missed period, the timer is rescheduled for the next scheduled firing time.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Timer sources 在未来的特定时间同步地传递事件给线程，Timer是一种提醒线程做事的方式。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;尽管Timer是一种基于时间的通知，但是并不是实时机制，如果不是对应的Mode,timer并不会被fire除非切换到对应的Mode.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;如果timer的fire时间，runloop正在处理其他事件，等待超过tolerance，那么这一次fire就会错过，等待下一次来执行，如果runloop退出，那么timer就再也不会fire了。&lt;/li&gt;
  &lt;li&gt;间隔时间是跟上一次之后的间隔，是timer自己调度的，所以可能并不是跟实际时间完全吻合(因为存在等待，这些需要叠加)。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;timer应用&quot;&gt;Timer应用&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;除了scheduledTimerWithTimeInterval开头的方法创建的Timer都需要手动添加到当前Run Loop中。（scheduledTimerWithTimeInterval 创建的timer会自动以Default Mode加载到当前Run Loop中。）&lt;/li&gt;
  &lt;li&gt;Timer在选择使用一次后，在执行完成时，会从Run Loop中移除。选择循环时，会一直保存在当前Run Loop中，直到调用invalidated方法。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;五runloop-mode&quot;&gt;五、Runloop Mode&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;A &lt;em&gt;run loop mode&lt;/em&gt; is a collection of input sources and timers to be monitored and a collection of run loop observers to be notified&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一个&lt;em&gt;run loop mode&lt;/em&gt;是一个集合（&lt;em&gt;input sources&lt;/em&gt; 和 &lt;em&gt;timers&lt;/em&gt;被监测，&lt;em&gt;observers&lt;/em&gt;接受通知）&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Each time you run your run loop, you specify (either explicitly or implicitly) a particular “mode” in which to run. During that pass of the run loop, only sources associated with that mode are monitored and allowed to deliver their events. (Similarly, only observers associated with that mode are notified of the run loop’s progress.) Sources associated with other modes hold on to any new events until subsequent passes through the loop in the appropriate mode.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;每次开启runloop都要指定一个mode来运行，在运行期间，只有该mode下对应的事件源才会被监测以及允许传递事件（同样的，该mode对应的observers才能接受runloop进程的通知）,其他mode下的事件源的事件将会等待直到切换到对应的mode.更改mode只能重新开启runloop，&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;You use modes to filter out events from unwanted sources during a particular pass through your run loop. Most of the time, you will want to run your run loop in the system-defined “default” mode. A modal panel, however, might run in the “modal” mode. While in this mode, only sources relevant to the modal panel would deliver events to the thread.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在设置Run Loop Mode后，你的Run Loop会自动过滤和其他Mode相关的事件源，而只监视和当前设置Mode相关的源(通知相关的观察者)。大多数时候，Run Loop都是运行在系统定义的默认模式上。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;NSDefaultRunLoopMode&lt;/em&gt;: 大多数工作中默认的运行方式。&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;NSConnectionReplyMode&lt;/em&gt;: 使用这个Mode去监听NSConnection对象的状态，我们很少需要自己使用这个Mode。&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;NSModalPanelRunLoopMode&lt;/em&gt;: 使用这个Mode在Model Panel情况下去区分事件(OS X开发中会遇到)。&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;UITrackingRunLoopMode&lt;/em&gt;: 使用这个Mode去跟踪来自用户交互的事件（比如UITableView上下滑动）。&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;GSEventReceiveRunLoopMode&lt;/em&gt;: 用来接受系统事件，内部的Run Loop Mode。&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;NSRunLoopCommonModes&lt;/em&gt;:这是一个伪模式，其为一组run loop mode的集合。如果将Input source加入此模式，意味着关联Input source到Common Modes中包含的所有模式下。在iOS系统中NSRunLoopCommonMode包含NSDefaultRunLoopMode、NSTaskDeathCheckMode、UITrackingRunLoopMode.可使用CFRunLoopAddCommonMode方法向Common Modes中添加自定义mode。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Run Loop运行时只能以一种固定的Mode运行，只会监控这个Mode下添加的Timer source和Input source。如果这个Mode下没有添加事件源，Run Loop会立刻返回。&lt;/p&gt;

&lt;p&gt;Run Loop并不是在运行在NSRunLoopCommonModes，因为NSRunLoopCommonModes是个Mode集合，而不是一个具体的Mode。我们可以在添加事件源的时候使用NSRunLoopCommonModes，只要Run Loop运行在NSRunLoopCommonModes中任何一个Mode，这个事件源都可以被触发。类似地也可以自定义Mode集合&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;You can define custom modes by simply specifying a custom string for the mode name. Although the names you assign to custom modes are arbitrary, the contents of those modes are not. You must be sure to add one or more input sources, timers, or run-loop observers to any modes you create for them to be useful.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;自定义Mode的时候，一定要确保该Mode下有sources以及Obsevers&lt;/p&gt;

&lt;h3 id=&quot;六runloop的observer&quot;&gt;六、Runloop的Observer&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;In addition to handling sources of input, run loops also generate notifications about the run loop’s behavior.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在处理事件源时，runloop会产生关于这些行为的通知，可以往Run Loop中加入自己的观察者以便监控Run Loop的运行过程。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;In contrast to sources, which fire when an appropriate asynchronous or synchronous event occurs, run loop observers fire at special locations during the execution of the run loop itself. You might use run loop observers to prepare your thread to process a given event or to prepare the thread before it goes to sleep. You can associate run loop observers with the following events in your run loop:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;The entrance to the run loop.&lt;/li&gt;
    &lt;li&gt;When the run loop is about to process a timer.&lt;/li&gt;
    &lt;li&gt;When the run loop is about to process an input source.&lt;/li&gt;
    &lt;li&gt;When the run loop is about to go to sleep.&lt;/li&gt;
    &lt;li&gt;When the run loop has woken up, but before it has processed the event that woke it up.&lt;/li&gt;
    &lt;li&gt;The exit from the run loop.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;一个合适的同步或者异步事件引发soureces启动，跟soureces相反，Runloop Observers在本身循环执行期间的某个特殊位置启动，也许你需要用runloop obsevers去准备你的线程去处理某个事件或者在线程休眠之前准备好线程。&lt;/p&gt;

&lt;p&gt;Run Loop Observer会与以下事件相关联：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;kCFRunLoopEntry – 进入runloop循环&lt;/li&gt;
  &lt;li&gt;kCFRunLoopBeforeTimers — runloop即将处理一个timer&lt;/li&gt;
  &lt;li&gt;kCFRunLoopBeforeSources – runloop即将处理input sources的事件&lt;/li&gt;
  &lt;li&gt;kCFRunLoopBeforeWaiting – runloop即将休眠&lt;/li&gt;
  &lt;li&gt;kCFRunLoopAfterWaiting – runloop已经唤醒，但是唤醒runloop的是事件还没有处理。&lt;/li&gt;
  &lt;li&gt;kCFRunLoopExit – 退出runloop&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Similar to timers, run-loop observers can be used once or repeatedly. A one-shot observer removes itself from the run loop after it fires, while a repeating observer remains attached. You specify whether an observer runs once or repeatedly when you create it.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;和Timer一样，Run Loop Observers也可以使用一次或者选择repeat。如果只使用一次，Observer会在它被执行后自己从Run Loop中移除。而循环的Observer会一直保存在Run Loop中。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Each time you run it, your thread’s run loop processes pending events and generates notifications for any attached observers. The order in which it does this is very specific and is as follows:&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;Notify observers that the run loop has been entered.&lt;/li&gt;
    &lt;li&gt;Notify observers that any ready timers are about to fire.&lt;/li&gt;
    &lt;li&gt;Notify observers that any input sources that are not port based are about to fire.&lt;/li&gt;
    &lt;li&gt;Fire any non-port-based input sources that are ready to fire.&lt;/li&gt;
    &lt;li&gt;If a port-based input source is ready and waiting to fire, process the event immediately. Go to step 9.&lt;/li&gt;
    &lt;li&gt;Notify observers that the thread is about to sleep.&lt;/li&gt;
    &lt;li&gt;Put the thread to sleep until one of the following events occurs:
      &lt;ul&gt;
        &lt;li&gt;An event arrives for a port-based input source.&lt;/li&gt;
        &lt;li&gt;A timer fires.&lt;/li&gt;
        &lt;li&gt;The timeout value set for the run loop expires.&lt;/li&gt;
        &lt;li&gt;The run loop is explicitly woken up.&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;Notify observers that the thread just woke up.&lt;/li&gt;
    &lt;li&gt;Process the pending event.
      &lt;ul&gt;
        &lt;li&gt;If a user-defined timer fired, process the timer event and restart the loop. Go to step 2.&lt;/li&gt;
        &lt;li&gt;If an input source fired, deliver the event.&lt;/li&gt;
        &lt;li&gt;If the run loop was explicitly woken up but has not yet timed out, restart the loop. Go to step 2.&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;Notify observers that the run loop has exited.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;一旦runloop跑起来，线程的runloop就会处理等待的事件并且给observer发送通知&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Runloop/runloop_03.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;int32_t __CFRunLoopRun()
{
    // 通知即将进入runloop
  	//创建AutoreleasePool: _objc_autoreleasePoolPush();
    __CFRunLoopDoObservers(KCFRunLoopEntry);
    
    do
    {
        // 通知将要处理timer和source
        __CFRunLoopDoObservers(kCFRunLoopBeforeTimers);
        __CFRunLoopDoObservers(kCFRunLoopBeforeSources);
        
        // 处理非延迟的主线程调用
        __CFRunLoopDoBlocks();
        // 处理UIEvent事件
        __CFRunLoopDoSource0();
        
        // GCD dispatch main queue
        CheckIfExistMessagesInMainDispatchQueue();
        
        // 即将进入休眠
      	//释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();
        __CFRunLoopDoObservers(kCFRunLoopBeforeWaiting);
        
        // 等待内核mach_msg事件
        mach_port_t wakeUpPort = SleepAndWaitForWakingUpPorts();
        
        // Zzz...
        
        // 从等待中醒来
        __CFRunLoopDoObservers(kCFRunLoopAfterWaiting);
                
        if (wakeUpPort == timerPort){// 处理因timer的唤醒
          __CFRunLoopDoTimers();
        }else if (wakeUpPort == mainDispatchQueuePort){// 处理异步方法唤醒,如dispatch_async
          __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()
        } else{// UI刷新,动画显示
          __CFRunLoopDoSource1();
        }   
        // 再次确保是否有同步的方法需要调用
        __CFRunLoopDoBlocks();
        
    } while (!stop &amp;amp;&amp;amp; !timeout);
    
    // 通知即将退出runloop
  	//释放AutoreleasePool: _objc_autoreleasePoolPop();
    __CFRunLoopDoObservers(CFRunLoopExit);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/img/Runloop/runloop_04.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Because observer notifications for timer and input sources are delivered before those events actually occur, there may be a gap between the time of the notifications and the time of the actual events. If the timing between these events is critical, you can use the sleep and awake-from-sleep notifications to help you correlate the timing between the actual events.&lt;/p&gt;

  &lt;p&gt;Because timers and other periodic events are delivered when you run the run loop, circumventing that loop disrupts the delivery of those events. The typical example of this behavior occurs whenever you implement a mouse-tracking routine by entering a loop and repeatedly requesting events from the application. Because your code is grabbing events directly, rather than letting the application dispatch those events normally, active timers would be unable to fire until after your mouse-tracking routine exited and returned control to the application.&lt;/p&gt;

  &lt;p&gt;A run loop can be explicitly woken up using the run loop object. Other events may also cause the run loop to be woken up. For example, adding another non-port-based input source wakes up the run loop so that the input source can be processed immediately, rather than waiting until some other event occurs.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;timer和input source的通知会在这些事件处理之前就传递(通知时间和发生时间会有小差距)，如果事件处理之间的时间很重要，你可以利用休眠和唤醒的通知来关联这些时间处理的时间&lt;/p&gt;

&lt;p&gt;因为timer和其他周期性事件在运行runloop时传递，如果规避了循环(不再循环)，会打断这些事件的传递。举个例子，如果你实现了鼠标追踪：在进入了runloop之后就不断地从应用抓取轨迹（循环停止了），这个时候timer就会失效直到你的鼠标追踪结束，将控制圈交还应用，继续循环。&lt;/p&gt;

&lt;p&gt;runloop对象可以唤醒runloop.其他的事件也可以唤醒，比如，添加了一个其他的non-port-based input source就能唤醒runloop从而可以让这个input source可以马上被处理，而不是等着直到其他活动发生。&lt;/p&gt;

&lt;h3 id=&quot;七什么时候才需要使用runloop&quot;&gt;七、什么时候才需要使用runloop&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;The only time you need to run a run loop explicitly is when you create secondary threads for your application. The run loop for your application’s main thread is a crucial piece of infrastructure. As a result, the app frameworks provide the code for running the main application loop and start that loop automatically. The run method of UIApplication in iOS (or NSApplication in OS X) starts an application’s main loop as part of the normal startup sequence. If you use the Xcode template projects to create your application, you should never have to call these routines explicitly.&lt;/p&gt;

  &lt;p&gt;For secondary threads, you need to decide whether a run loop is necessary, and if it is, configure and start it yourself. You do not need to start a thread’s run loop in all cases. For example, if you use a thread to perform some long-running and predetermined task, you can probably avoid starting the run loop. Run loops are intended for situations where you want more interactivity with the thread. For example, you need to start a run loop if you plan to do any of the following:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;Use ports or custom input sources to communicate with other threads.&lt;/li&gt;
    &lt;li&gt;Use timers on the thread.&lt;/li&gt;
    &lt;li&gt;Use any of the performSelector … methods in a Cocoa application.&lt;/li&gt;
    &lt;li&gt;Keep the thread around to perform periodic tasks.&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;If you do choose to use a run loop, the configuration and setup is straightforward. As with all threaded programming though, you should have a plan for exiting your secondary threads in appropriate situations. It is always better to end a thread cleanly by letting it exit than to force it to terminate. Information on how to configure and exit a run loop is described in &lt;a href=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW5&quot;&gt;Using Run Loop Objects&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;只有在你开启了子线程的情况下才需要运行runloop，主线程的runloop是框架基础，框架提供了代码来运行runloop并且自动开启。应用启动时主线程的runloop就会跟随运行。&lt;/p&gt;

&lt;p&gt;对于子线程，是否需要运行runloop取决于实际需要，并不是所有的子线程都需要运行runloop。如果子线程要跑一个确定的而且长的任务，就没必要开启runloop。runloop更适合当你需要与线程更多交互的情景。以下情景需要开启runloop:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用ports或者自定义input sources与其他线程联通&lt;/li&gt;
  &lt;li&gt;在线程上使用Timer&lt;/li&gt;
  &lt;li&gt;使用&lt;em&gt;performSelector&lt;/em&gt;这类方法&lt;/li&gt;
  &lt;li&gt;保持线程执行定期周期任务&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果你在子线程运行了runloop，你要准备好在合适的时候退出该子线程，因为相比于强制让runloop终止，通过让线程终止来让runloop退出更好。&lt;/p&gt;

&lt;h3 id=&quot;八使用runloop&quot;&gt;八、使用Runloop&lt;/h3&gt;

&lt;h4 id=&quot;获得runloop&quot;&gt;获得runloop&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;To get the run loop for the current thread, you use one of the following:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;In a Cocoa application, use the &lt;em&gt;currentRunLoop&lt;/em&gt;  class method of NSRunLoop to retrieve an NSRunLoop object.&lt;/li&gt;
    &lt;li&gt;Use the &lt;em&gt;CFRunLoopGetCurrent&lt;/em&gt; function.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;要获得runloop，你可以使用&lt;em&gt;currentRunLoop&lt;/em&gt;或者&lt;em&gt;CFRunLoopGetCurrent&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Before you run a run loop on a secondary thread, you must add at least one input source or timer to it. If a run loop does not have any sources to monitor, it exits immediately when you try to run it&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在子线程运行runloop之前，你必须添加至少一个input source或者timer。如果runloop没有一个source来监测，会马上退出。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;- (void)threadMain
{
    // The application uses garbage collection, so no autorelease pool is needed.
    NSRunLoop* myRunLoop = [NSRunLoop currentRunLoop];
 
    // Create a run loop observer and attach it to the run loop.
    CFRunLoopObserverContext  context = {0, self, NULL, NULL, NULL};
    CFRunLoopObserverRef    observer = CFRunLoopObserverCreate(kCFAllocatorDefault,
            kCFRunLoopAllActivities, YES, 0, &amp;amp;myRunLoopObserver, &amp;amp;context);
 
    if (observer)
    {
        CFRunLoopRef    cfLoop = [myRunLoop getCFRunLoop];
        CFRunLoopAddObserver(cfLoop, observer, kCFRunLoopDefaultMode);
    }
 
    // Create and schedule the timer.
    [NSTimer scheduledTimerWithTimeInterval:0.1 target:self
                selector:@selector(doFireTimer:) userInfo:nil repeats:YES];
 
    NSInteger    loopCount = 10;
    do
    {
        // Run the run loop 10 times to let the timer fire.
        [myRunLoop runUntilDate:[NSDate dateWithTimeIntervalSinceNow:1]];
        loopCount--;
    }
    while (loopCount);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;When configuring the run loop for a long-lived thread, it is better to add at least one input source to receive messages. Although you can enter the run loop with only a timer attached, once the timer fires, it is typically invalidated, which would then cause the run loop to exit. Attaching a repeating timer could keep the run loop running over a longer period of time, but would involve firing the timer periodically to wake your thread, which is effectively another form of polling. By contrast, an input source waits for an event to happen, keeping your thread asleep until it does.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当配置一个长活线程的runloop，最好添加至少一个input source来接受信息，尽管重复的timer也可以让runloop长时间跑着，但是这涉及到不断定时启动timer来唤醒线程，这实际上是另外一种轮询。相对的，一个input source可以让runloop先休眠等着事件发生再唤醒。&lt;/p&gt;

&lt;h4 id=&quot;开启runloop&quot;&gt;开启Runloop&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;Starting the run loop is necessary only for the secondary threads in your application. A run loop must have at least one input source or timer to monitor. If one is not attached, the run loop exits immediately.&lt;/p&gt;

  &lt;p&gt;There are several ways to start the run loop, including the following:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;Unconditionally&lt;/li&gt;
    &lt;li&gt;With a set time limit&lt;/li&gt;
    &lt;li&gt;In a particular mode&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;Entering your run loop unconditionally is the simplest option, but it is also the least desirable. Running your run loop unconditionally puts the thread into a permanent loop, which gives you very little control over the run loop itself. You can add and remove input sources and timers, but the only way to stop the run loop is to kill it. There is also no way to run the run loop in a custom mode.&lt;/p&gt;

  &lt;p&gt;Instead of running a run loop unconditionally, it is better to run the run loop with a timeout value. When you use a timeout value, the run loop runs until an event arrives or the allotted time expires. If an event arrives, that event is dispatched to a handler for processing and then the run loop exits. Your code can then restart the run loop to handle the next event. If the allotted time expires instead, you can simply restart the run loop or use the time to do any needed housekeeping.&lt;/p&gt;

  &lt;p&gt;In addition to a timeout value, you can also run your run loop using a specific mode. Modes and timeout values are not mutually exclusive and can both be used when starting a run loop. Modes limit the types of sources that deliver events to the run loop and are described in more detail in &lt;a href=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW12&quot;&gt;Run Loop Modes&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;子线程的runloop是要手动开启的，一个runloop必须有至少一个input source或者timer去监听，否则会立即退出。&lt;/p&gt;

&lt;p&gt;有以下几个方式来进入runloop:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;无条件进入：无条件进入runloop是一个简单的选项，但同时也是一个不太可取的选项，意味着使线程进入了一个固定的循环，相比于runloop本身，你只有很少的控制权，你可以添加和移除input source和timers，但是唯一路径来停止runloop就是杀死它，也没有办法来让runloop在自定义Mode运行。&lt;/li&gt;
  &lt;li&gt;设定时限：如果设置了一个时间，runloop运行直到事件到达或者时间到期，如果事件到达，那事件就被分配去处理然后runloop退出。你的代码可以重启runloop来处理下一个事件。如果分配的时间到期，你可以简单地重启runloop或者用这个时间来做其他需要处理的。&lt;/li&gt;
  &lt;li&gt;特定Mode：特定也可以运行runloop，Modes和时限并不是互斥可以同时运行一个runloop。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;runloop框架&quot;&gt;Runloop框架&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)skeletonThreadMain
{
    // Set up an autorelease pool here if not using garbage collection.
    BOOL done = NO;
 
    // Add your sources or timers to the run loop and do any other setup.
 
    do
    {
        // Start the run loop but return after each source is handled.
        SInt32    result = CFRunLoopRunInMode(kCFRunLoopDefaultMode, 10, YES);
 
        // If a source explicitly stopped the run loop, or if there are no
        // sources or timers, go ahead and exit.
        if ((result == kCFRunLoopRunStopped) || (result == kCFRunLoopRunFinished))
            done = YES;
 
        // Check for any other exit conditions here and set the
        // done variable as needed.
    }
    while (!done);
 
    // Clean up code here. Be sure to release any allocated autorelease pools.
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;The key portion of this example shows the basic structure of a run loop. In essence, you add your input sources and timers to the run loop and then repeatedly call one of the routines to start the run loop. Each time the run loop routine returns, you check to see if any conditions have arisen that might warrant exiting the thread.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;以上示例展示了runloop的最基本结构，实质上，你把input sources和modes添加进了runloop之后，就不断地调一个例程就开启runloop，每次runloop例程返回时，都会检查一下是否有需要退出线程的条件，&lt;/p&gt;

&lt;h4 id=&quot;退出runloop&quot;&gt;退出runloop&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;There are two ways to make a run loop exit before it has processed an event:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;Configure the run loop to run with a timeout value.&lt;/li&gt;
    &lt;li&gt;Tell the run loop to stop.&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;Using a timeout value is certainly preferred, if you can manage it. Specifying a timeout value lets the run loop finish all of its normal processing, including delivering notifications to run loop observers, before exiting.&lt;/p&gt;

  &lt;p&gt;Stopping the run loop explicitly with the &lt;em&gt;CFRunLoopStop&lt;/em&gt; function produces a result similar to a timeout. The run loop sends out any remaining run-loop notifications and then exits. The difference is that you can use this technique on run loops you started unconditionally.&lt;/p&gt;

  &lt;p&gt;Although removing a run loop’s input sources and timers may also cause the run loop to exit, this is not a reliable way to stop a run loop. Some system routines add input sources to a run loop to handle needed events. Because your code might not be aware of these input sources, it would be unable to remove them, which would prevent the run loop from exiting.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;退出runloop有两种方式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;给runloop设置一个超时时间&lt;/li&gt;
  &lt;li&gt;告诉runloop停止&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果可以的话，设置超时时间是首选，指定超时时间可以让runloop在退出之前，完成所有正常处理包含，传递runloop的通知；&lt;/p&gt;

&lt;p&gt;用&lt;em&gt;CFRunLoopStop&lt;/em&gt;来停止runloop和超时效果差不多，runloop会发送完剩余的通知然后退出，不同的是你可以在无条件开启runloop时用这种方式来退出；&lt;/p&gt;

&lt;p&gt;尽管移除runloop的input source和timers也可以让runloop退出，但这并不是一种可靠的方式。因为你的代码有时候并不能移除某些系统的input source。这样就不能够退出了。&lt;/p&gt;

&lt;h4 id=&quot;线程安全&quot;&gt;线程安全&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;Thread safety varies depending on which API you are using to manipulate your run loop. The functions in Core Foundation are generally thread-safe and can be called from any thread. If you are performing operations that alter the configuration of the run loop, however, it is still good practice to do so from the thread that owns the run loop whenever possible.&lt;/p&gt;

  &lt;p&gt;The Cocoa NSRunLoop class is not as inherently thread safe as its Core Foundation counterpart. If you are using the NSRunLoop class to modify your run loop, you should do so only from the same thread that owns that run loop. Adding an input source or timer to a run loop belonging to a different thread could cause your code to crash or behave in an unexpected way&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;线程安全性取决于使用runloop的API。 Core Foundation中的功能通常是线程安全的，可以从任何线程调用。 但是，如果您想更改runloop的配置，那么尽可能从拥有runloop的线程执行此操作。&lt;/p&gt;

&lt;p&gt;Cocoa NSRunLoop类并不像Core Foundation对象那样固有线程安全。 如果您正在使用NSRunLoop类来修改runloop，那你最好在同一线程执行这个操作。 将input sources或timers添加到属于不同线程的runloop可能会导致崩溃或者其他意外结果。&lt;/p&gt;</content><author><name>Ted</name></author><summary type="html">其他两篇：</summary></entry><entry><title type="html">iOS图形</title><link href="http://www.helloted.com/2017/01/10/draw/" rel="alternate" type="text/html" title="iOS图形" /><published>2017-01-10T20:00:00+08:00</published><updated>2017-01-10T20:00:00+08:00</updated><id>http://www.helloted.com/2017/01/10/draw</id><content type="html" xml:base="http://www.helloted.com/2017/01/10/draw/">&lt;p&gt;&lt;img src=&quot;/img/draw/01.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;一概念&quot;&gt;一、概念&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Core Graphics Framework&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Core Graphics Framework 是一套基于C的API框架，使用了Quartz作为绘图引擎。它提供了低级别、轻量级、高保真度的2D渲染。该框架可以用于基于路径的绘图、变换、颜色管理、脱屏渲染，模板、渐变、遮蔽、图像数据管理、图像的创建、遮罩以及PDF文档的创建、显示和分析&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Graphics Context&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Graphics Context是一个数据类型(CGContextRef)、Quartz绘制图像到输出设备的信息都保存在其中，Graphics Context定义了基本的绘制属性，如颜色、裁减区域、线条宽度和样式信息、字体信息、混合模式等&lt;/p&gt;

&lt;p&gt;使用UiKit，你只能在&lt;strong&gt;当前上下文中&lt;/strong&gt;绘图，所以如果你当前处于&lt;strong&gt;UIGraphicsBeginImageContextWithOptions&lt;/strong&gt;函数或&lt;strong&gt;drawRect&lt;/strong&gt;：方法中，你就可以直接使用UIKit提供的方法进行绘图。如果你持有一个context：参数，那么使用UIKit提供的方法之前，必须将该上下文参数转化为当前上下文。幸运的是，调用&lt;strong&gt;UIGraphicsPushContext&lt;/strong&gt; 函数可以方便的将context：参数转化为当前上下文，记住最后别忘了调用&lt;strong&gt;UIGraphicsPopContext函数&lt;/strong&gt;恢复上下文环境。&lt;/p&gt;

&lt;p&gt;通过调用UIGraphicsGetCurrentContext()方法可以获取当前的Graphics Context&lt;/p&gt;

&lt;h3 id=&quot;二五种绘图方式&quot;&gt;二、五种绘图方式&lt;/h3&gt;

&lt;p&gt;用六种方式来画下面这个圆&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/draw/03.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;所有的代码可以&lt;a href=&quot;https://github.com/helloted/drawdemo&quot;&gt;Github-五种绘图方式&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;1uiviewdrawrectuibezierpath&quot;&gt;1、UIView+drawRect+UIBezierPath&lt;/h4&gt;

&lt;p&gt;重写drawRect能够自动生成Context，所以可以在drawRect方法里面画图形&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;- (void)drawRect:(CGRect)rect{
    UIBezierPath *p = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(100,100,100,100)];
    [[UIColor orangeColor] setFill];
    [p fill];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;2uiviewdrawrectcontext&quot;&gt;2、UIView+drawRect+context&lt;/h4&gt;

&lt;p&gt;获取到drawRect自动生成的context,在context里画图形&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;- (void)drawRect:(CGRect)rect{
    CGContextRef context = UIGraphicsGetCurrentContext();
    CGContextAddEllipseInRect(context, CGRectMake(100,100,100,100));
    CGContextSetFillColorWithColor(context, [UIColor orangeColor].CGColor);
    CGContextFillPath(context);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;3uiviewdrawlayer-incontext&quot;&gt;3、UIView+drawLayer: inContext:&lt;/h4&gt;

&lt;p&gt;注意要显式调用[view.layer setNeedsDisplay]这个方法才起作用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx{
    CGContextAddEllipseInRect(ctx, CGRectMake(100,100,100,100));
    CGContextSetFillColorWithColor(ctx, [UIColor orangeColor].CGColor);
    CGContextFillPath(ctx);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx{
    UIGraphicsPushContext(ctx);
    UIBezierPath* p = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(100,100,100,100)];
    [[UIColor orangeColor] setFill];
    [p fill];
    UIGraphicsPopContext();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;4calayerdrawincontext&quot;&gt;4、CALayer+drawInContext&lt;/h4&gt;

&lt;p&gt;插入Layer层，注意插入Layer层时，要显式调用setNeedsDisplay，这样就会调用drawInContext&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;    DrawLayer *layer = [[DrawLayer alloc]init];
    layer.frame = self.view.bounds;
    [layer setNeedsDisplay];
    [self.view.layer addSublayer:layer];
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;@implementation DrawLayer

- (void)drawInContext:(CGContextRef)ctx{
    CGContextAddEllipseInRect(ctx, CGRectMake(100,100,100,100));
    CGContextSetFillColorWithColor(ctx, [UIColor orangeColor].CGColor);
    CGContextFillPath(ctx);
}
@end
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;5uigraphicsbeginimagecontextwithoptions&quot;&gt;5、UIGraphicsBeginImageContextWithOptions&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;- (void)drawImage{
    UIGraphicsBeginImageContextWithOptions(CGSizeMake(100,100), NO, 0);
    CGContextRef con = UIGraphicsGetCurrentContext();
    CGContextAddEllipseInRect(con, CGRectMake(0,0,100,100));
    CGContextSetFillColorWithColor(con, [UIColor orangeColor].CGColor);
    CGContextFillPath(con);
    UIImage* image = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    UIImageView  *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
    [imageView setImage:image];
    [self.view addSubview:imageView];    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;    UIGraphicsBeginImageContextWithOptions(CGSizeMake(100,100), NO, 0);
    UIBezierPath* p = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(0,0,100,100)];
    [[UIColor blueColor] setFill];
    [p fill];
    UIImage* image = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    UIImageView  *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
    [imageView setImage:image];
    [self.view addSubview:imageView];
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;三上下文切换&quot;&gt;三、上下文切换&lt;/h3&gt;

&lt;h4 id=&quot;1cgcontextsavegstatecgcontextrestoregstate&quot;&gt;1、CGContextSaveGState/CGContextRestoreGState&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[[UIColor redColor] setStroke]; //画笔红色
CGContextSaveGState(UIGraphicsGetCurrentContext()); //记录上下文的当前状态
[[UIColor blackColor] setStroke]; //画笔黑色
CGContextRestoreGState(UIGraphicsGetCurrentContext()); //恢复之前记录的上下文状态
UIRectFill(CGRectMake(10, 10, 100, 100)); //绘制红色矩形
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;2uigraphicspushcontextuigraphicspopcontext&quot;&gt;2、UIGraphicsPushContext/UIGraphicsPopContext&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;当前正在使用CoreGraphics绘制图形A，想要使用UIKit绘制完全不同的图形B，此时就希望保存当前绘图context及已绘制内容。&lt;/li&gt;
  &lt;li&gt;使用UIGraphicsPushContext切换到一个全新的绘图context。&lt;/li&gt;
  &lt;li&gt;使用UIKit绘制图形B。&lt;/li&gt;
  &lt;li&gt;使用UIGraphicsPopContext恢复之前的绘图context，继续使用CoreGraphics绘制图形A。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx{
    UIGraphicsPushContext(ctx);
    UIBezierPath* p = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(100,100,100,100)];
    [[UIColor orangeColor] setFill];
    [p fill];
    UIGraphicsPopContext();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;3uigraphicsbeginimagecontextuigraphicsendimagecontext&quot;&gt;3、UIGraphicsBeginImageContext/UIGraphicsEndImageContext&lt;/h4&gt;

&lt;p&gt;如果想在切换绘图context后，继续使用CoreGraphics绘图（而非UIKit），则不需要使用UIGraphicsPushContext/UIGraphicsPopContext。因为CoreGraphics已将绘图context视为参数。使用场景是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;当前正在绘制图形A。&lt;/li&gt;
  &lt;li&gt;使用UIGraphicsBeginImageContext将旧的绘图context入栈，创建新的绘图context并使用。&lt;/li&gt;
  &lt;li&gt;绘制图形B。&lt;/li&gt;
  &lt;li&gt;结束绘制图形B之后，使用UIGraphicsEndImageContext恢复到之前的绘图context，继续绘制图形A。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 绘图中
UIGraphicsBeginImageContext(CGSizeMake(200, 200));
[self.view drawViewHierarchyInRect:self.view.bounds afterScreenUpdates:YES];
UIImage *snapshot = UIGraphicsGetImageFromCurrentImageContext();
UIGraphicsEndImageContext();
imageView.image = snapshot;
// 继续绘图
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;四calayer与uiview&quot;&gt;四、CALayer与UIView&lt;/h3&gt;

&lt;p&gt;视图即UIView，并不是直接显示在屏幕上，而是在创建视图对象的时候视图对象会自动创建一个层，而视图对象把要显示的东西绘制在层上，待到需要显示时硬件将所有的层拷贝，然后按Z轴的高低合成最终的显示结果&lt;/p&gt;

&lt;p&gt;view的完整显示过程&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;view.layer会准备一个Layer Graphics Contex(图层类型的上下文)&lt;/li&gt;
  &lt;li&gt;调用view.layer.delegate(view)的drawLayer:inContext:,并传入刚才准备好的上下文&lt;/li&gt;
  &lt;li&gt;view的drawLayer:inContext:方法内部又会调用view的drawRect:方法&lt;/li&gt;
  &lt;li&gt;view就可以在drawRect:方法中实现绘图代码, 所有东西最终都绘制到view.layer上面&lt;/li&gt;
  &lt;li&gt;系统再将view.layer的内容拷贝到屏幕, 于是完成了view的显示&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Ted</name></author><summary type="html"></summary></entry><entry><title type="html">CoreData简介以及第三方框架MagicRecord源码解析</title><link href="http://www.helloted.com/2016/12/01/coredata/" rel="alternate" type="text/html" title="CoreData简介以及第三方框架MagicRecord源码解析" /><published>2016-12-01T20:00:00+08:00</published><updated>2016-12-01T20:00:00+08:00</updated><id>http://www.helloted.com/2016/12/01/coredata</id><content type="html" xml:base="http://www.helloted.com/2016/12/01/coredata/">&lt;h3 id=&quot;一coredata结构&quot;&gt;一、CoreData结构&lt;/h3&gt;

&lt;p&gt;可以用两张图来表示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/coredata/00.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/coredata/01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;nsmanagedobject&quot;&gt;NSManagedObject&lt;/h4&gt;

&lt;p&gt;数据库对象，一个&lt;code class=&quot;highlighter-rouge&quot;&gt;NSManagedObject&lt;/code&gt;对应一张表，&lt;code class=&quot;highlighter-rouge&quot;&gt;NSManagedObject&lt;/code&gt;的一个属性对应数据表的一个字段。数据库的增删查改就是操作&lt;code class=&quot;highlighter-rouge&quot;&gt;NSManagedObject&lt;/code&gt;，通过&lt;em&gt;xCode-&amp;gt;Editor-&amp;gt;Create NSManagedObject Subclass…&lt;/em&gt;来创建对应表的对象model&lt;/p&gt;

&lt;h4 id=&quot;nsmanagedobjectcontext&quot;&gt;NSManagedObjectContext&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSManagedObject&lt;/code&gt;操作的上下文，&lt;code class=&quot;highlighter-rouge&quot;&gt;NSManagedObject&lt;/code&gt;的操作会先缓存在上下文中，还未存到磁盘中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;- (NSManagedObjectContext *)managedObjectContext{
    if (__managedObjectContext != nil) {
        return __managedObjectContext;
    }
    NSPersistentStoreCoordinator *coordinator = [self persistentStoreCoordinator];
    if (coordinator != nil) {
        __managedObjectContext = [[NSManagedObjectContext alloc] init];
        [__managedObjectContext setPersistentStoreCoordinator:coordinator];
    }
    return __managedObjectContext;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成&lt;code class=&quot;highlighter-rouge&quot;&gt;NSManagedObjectContext&lt;/code&gt;时需要设置&lt;code class=&quot;highlighter-rouge&quot;&gt;NSPersistentStoreCoordinator&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;有三种类型&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;NSConfinementConcurrencyType (或者不加参数，默认就是这个)&lt;/li&gt;
  &lt;li&gt;NSMainQueueConcurrencyType (表示只会在主线程中执行)&lt;/li&gt;
  &lt;li&gt;NSPrivateQueueConcurrencyType (表示可以在子线程中执行)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过 setParentContext 方法，可以设置另外一个 NSManagedObjectContext 为自己的父级，这个时候子级可以访问父级下所有的对象，而且子级 NSManagedObjectContext 的内容变化后，如果执行save方法，会自动的 merge 到父级 NSManagedObjectContext 中，也就是子级save后，变动会同步到父级 NSManagedObjectContext。当然这个时候父级也必须再save一次，如果父级没有父级了，那么就会直接向NSPersistentStoreCoordinator中写入，如果有就会接着向再上一层的父级冒泡……&lt;/p&gt;

&lt;h4 id=&quot;nspersistentstorecoordinator&quot;&gt;NSPersistentStoreCoordinator&lt;/h4&gt;

&lt;p&gt;用来管理保存数据到磁盘这个操作&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;- (NSPersistentStoreCoordinator *)persistentStoreCoordinator{
    if (__persistentStoreCoordinator != nil) {
        return __persistentStoreCoordinator;
    }
    NSURL *storeURL = [[self applicationDocumentsDirectory] URLByAppendingPathComponent:@&quot;HelloApp.sqlite&quot;];
    NSError *error = nil;
    __persistentStoreCoordinator = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:[self managedObjectModel]];
    if (![__persistentStoreCoordinator addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:storeURL options:nil error:&amp;amp;error]) {
        NSLog(@&quot;Unresolved error %@, %@&quot;, error, [error userInfo]);
        abort();
    }    
    return __persistentStoreCoordinator;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成&lt;code class=&quot;highlighter-rouge&quot;&gt;NSPersistentStoreCoordinator&lt;/code&gt;需要参数：文件保存路径、&lt;code class=&quot;highlighter-rouge&quot;&gt;NSManagedObjectModel&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;nsmanagedobjectmodel&quot;&gt;NSManagedObjectModel&lt;/h4&gt;

&lt;p&gt;生成这个类的来源就是在 xCode 里的.xcdatamodeld文件，我们可以可视化的对这个文件进行操作，实际上这个文件也就相当于数据库的 schema，这个文件编译后就是.momd或.mom文件。&lt;/p&gt;

&lt;p&gt;Model Vesion：版本升级，Editor-&amp;gt;Add Model Version，生成新的momd文件来进行版本升级，并且重新生成相关类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;- (NSManagedObjectModel *)managedObjectModel{
    if (__managedObjectModel != nil) {
        return __managedObjectModel;
    }
    NSURL *modelURL = [[NSBundle mainBundle] URLForResource:@&quot;HelloApp&quot; withExtension:@&quot;momd&quot;];
    __managedObjectModel = [[NSManagedObjectModel alloc] initWithContentsOfURL:modelURL];
    return __managedObjectModel;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;二多线程里的coredata&quot;&gt;二、多线程里的CoreData&lt;/h3&gt;

&lt;p&gt;在多线程中，每个线程都会有一个上下文&lt;code class=&quot;highlighter-rouge&quot;&gt;NSManagedObjectContext&lt;/code&gt;，而&lt;code class=&quot;highlighter-rouge&quot;&gt;NSManagedObjectContext&lt;/code&gt;可以共享一个&lt;code class=&quot;highlighter-rouge&quot;&gt;NSPersistentStoreCoordinator&lt;/code&gt;或者，每个&lt;code class=&quot;highlighter-rouge&quot;&gt;NSManagedObjectContext&lt;/code&gt;都对应一个&lt;code class=&quot;highlighter-rouge&quot;&gt;NSPersistentStoreCoordinator&lt;/code&gt;，所以会有以下几种方式:&lt;/p&gt;

&lt;h4 id=&quot;1&quot;&gt;1、&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/coredata/02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这种方式，最简单明了，在子线程的privatecontext里操作完数据库对象后，将操作缓存merger到主线程的maincontext，再由maincontext通过&lt;code class=&quot;highlighter-rouge&quot;&gt;NSPersistentStoreCoordinator&lt;/code&gt;存到本地磁盘。但是存到本地磁盘中是一个耗时的IO操作，对于主线程来说，这是不能忍的，所以不能用这种方式&lt;/p&gt;

&lt;h4 id=&quot;2&quot;&gt;2、&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/coredata/03.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个方式在跟第一个方式的区别在于，主线程上的maincontext与&lt;code class=&quot;highlighter-rouge&quot;&gt;NSPersistentStoreCoordinator&lt;/code&gt;交互之家再插了一层子线程的privatecontext，context之间的传递是很快的，这样可以有效地避免IO阻塞主线程，而且childContext调用save方法，其parentContext不用任何merge操作，CoreData自动将数据merge到parentContext当中，这样可以保证每个context的数据同步&lt;/p&gt;

&lt;h4 id=&quot;3&quot;&gt;3、&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/coredata/04.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这种情况下，privatecontext与maincontext共同连接&lt;code class=&quot;highlighter-rouge&quot;&gt;NSPersistentStoreCoordinator&lt;/code&gt;，子线程中创建privateContext，进行数据增删改查操作，直接save到本地数据库，同时发出通知&lt;code class=&quot;highlighter-rouge&quot;&gt;NSManagedObjectContextDidSaveNotification&lt;/code&gt;,在主线程mainContext的&lt;code class=&quot;highlighter-rouge&quot;&gt;mergeChangesFromContextDidSaveNotification:notification&lt;/code&gt;方法，将所有的数据变动merge到mainContext中，这样就保持了两个Context中的数据同步。由于大部分的操作都是privateContext在子线程中操作的，所以这种设计是UI线程耗时最少的一种设计，但是它的代价是需要多写mergeChanges的方法。&lt;/p&gt;

&lt;h3 id=&quot;三magicrecord源码解析&quot;&gt;三、MagicRecord源码解析&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;+ (void) setupCoreDataStackWithStoreAtURL:(NSURL *)storeURL
{
    if ([NSPersistentStoreCoordinator MR_defaultStoreCoordinator] != nil) return;
    
    NSPersistentStoreCoordinator *coordinator = [NSPersistentStoreCoordinator MR_coordinatorWithSqliteStoreAtURL:storeURL];
    [NSPersistentStoreCoordinator MR_setDefaultStoreCoordinator:coordinator];
    
    [NSManagedObjectContext MR_initializeDefaultContextWithCoordinator:coordinator];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先生成一个默认的NSPersistentStoreCoordinator，再生成默认的context，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;+ (void) MR_initializeDefaultContextWithCoordinator:(NSPersistentStoreCoordinator *)coordinator;
{
    NSAssert(coordinator, @&quot;Provided coordinator cannot be nil!&quot;);
    if (MagicalRecordDefaultContext == nil)
    {
      	// NSPrivateQueueConcurrencyType
        NSManagedObjectContext *rootContext = [self MR_contextWithStoreCoordinator:coordinator];
        [self MR_setRootSavingContext:rootContext];
		
        //NSMainQueueConcurrencyType
        NSManagedObjectContext *defaultContext = [self MR_newMainQueueContext];
        [self MR_setDefaultContext:defaultContext];

        [defaultContext setParentContext:rootContext];
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MagicRecord生成了两个context:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;rootContext:NSPrivateQueueConcurrencyType，用以保存数据的上下文&lt;/li&gt;
  &lt;li&gt;defaultContext:NSMainQueueConcurrencyType，用以主线程的上下文&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;defaultContext的父context是rootContext：RootSavingContext，可以看出MagicRecord默认用的是第二种模式，很简单就可以新建一个NSManagedObject并且保存&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        NSManagedObjectContext *current_context = [NSManagedObjectContext MR_contextWithParent:[NSManagedObjectContext MR_defaultContext]];
        Person *person = [Person MR_createEntityInContext:current_context];
        person.name = @&quot;jack&quot;;
        [current_context MR_saveToPersistentStoreWithCompletion:^(BOOL contextDidSave, NSError * _Nullable error) {
            NSLog(@&quot;finish save&quot;);
        }];
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2016-07-25 20:26:29.454 MagicR[19718:3903431] Created new private queue context: &amp;lt;NSManagedObjectContext: 0x6100001da220&amp;gt;
2016-07-25 20:26:29.454 MagicR[19718:3903443] → Saving &amp;lt;NSManagedObjectContext (0x6100001da220): Untitled Context&amp;gt; on a background thread
2016-07-25 20:26:29.460 MagicR[19718:3903375] → Saving &amp;lt;NSManagedObjectContext (0x6080001daa90): MagicalRecord Default Context&amp;gt; on the main thread
2016-07-25 20:26:29.462 MagicR[19718:3903431] → Saving &amp;lt;NSManagedObjectContext (0x6180001da6d0): MagicalRecord Root Saving Context&amp;gt; on a background thread
2016-07-25 20:26:29.466 MagicR[19718:3903375] finish save
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;从MagicRecord的日志就可以看出来，整个过程如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在子线程新建了一个current_context，并且设置他的父context为主线程的context(default context),然后Person在子线程context改变&lt;/li&gt;
  &lt;li&gt;将current_context的变动merge到父线程的context也就是defaultcontext，主线程的context同样merge到父线程的也就是rootcontext&lt;/li&gt;
  &lt;li&gt;rootcontext在子线程将变动保存到磁盘&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果想用第三种方式的话可以这样：在修改之后发出&lt;code class=&quot;highlighter-rouge&quot;&gt;NSManagedObjectContextDidSaveNotification&lt;/code&gt;通知主线程的context。而主线程的context通过&lt;code class=&quot;highlighter-rouge&quot;&gt;mergeChangesFromContextDidSaveNotification&lt;/code&gt;来合并修改&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        NSManagedObjectContext *current_context = [NSManagedObjectContext MR_newPrivateQueueContext];
        [current_context setPersistentStoreCoordinator:[NSPersistentStoreCoordinator MR_defaultStoreCoordinator]];
        Person *person = [Person MR_createEntityInContext:current_context];
        person.name = @&quot;jack&quot;;
        [[NSNotificationCenter defaultCenter] addObserver:self
                                                 selector:@selector(contextChanged:)
                                                     name:NSManagedObjectContextDidSaveNotification
                                                   object:current_context];
        [current_context MR_saveToPersistentStoreWithCompletion:^(BOOL contextDidSave, NSError * _Nullable error) {
            NSLog(@&quot;finish save&quot;);
        }];
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)contextChanged:(NSNotification*)notification{
    [[NSManagedObjectContext MR_newPrivateQueueContext] mergeChangesFromContextDidSaveNotification:notification];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样就能保证子线程的Context与主线程的context内容修改可以同步&lt;/p&gt;</content><author><name>Ted</name></author><summary type="html">一、CoreData结构</summary></entry><entry><title type="html">OC对象模型</title><link href="http://www.helloted.com/2016/10/15/objectmodel/" rel="alternate" type="text/html" title="OC对象模型" /><published>2016-10-15T20:00:00+08:00</published><updated>2016-10-15T20:00:00+08:00</updated><id>http://www.helloted.com/2016/10/15/objectmodel</id><content type="html" xml:base="http://www.helloted.com/2016/10/15/objectmodel/">&lt;p&gt;先看OC关于NSObject的源码&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://opensource.apple.com/source/objc4/objc4-532.2/runtime/NSObject.mm&quot;&gt;NSObject源码&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;一alloc与init&quot;&gt;一、alloc与init&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;NSObject *obj = [NSObject alloc]init];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;alloc与init发生了什么呢？&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;alloc&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_objc_rootAlloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_objc_rootAlloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#if 0  &amp;amp;&amp;amp;  __OBJC2__
    // Skip over the +allocWithZone: call if the class doesn't override it.
    // fixme not - this breaks ObjectAlloc
    if (! ((class_t *)cls)-&amp;gt;isa-&amp;gt;hasCustomAWZ()) {
        return class_createInstance(cls, 0);
    }
#endif
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cls&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;allocWithZone&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;class_createInstance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;extraBytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_class_createInstanceFromZone&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;extraBytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_class_createInstanceFromZone&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;extraBytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zone&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cxxConstruct&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;outAllocatedSize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cls&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;instanceSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;extraBytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;calloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;initInstanceIsa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hasCxxDtor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看出，alloc类方法是开辟了一块内存，生成了一个实例对象，并且对实例对象进行了初始化&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;init&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_objc_rootInit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_objc_rootInit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// In practice, it will be hard to rely on this function.
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// Many classes do not properly chain -init calls.
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;init方法只是返回了该实例对象&lt;/p&gt;

&lt;h3 id=&quot;二nsobject与class&quot;&gt;二、NSObject与Class&lt;/h3&gt;

&lt;h4 id=&quot;1对象&quot;&gt;1、对象&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;NSObject&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;@interface NSObject &amp;lt;NSObject&amp;gt;
{
    Class isa;
}
@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每一个NSObject里都有一个Class（isa指针），表明这个类的类别Class&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;id类型&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;typedef struct objc_object { 
    Class isa; 
} *id; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面可以看出id类型里面也有一个Class&lt;/p&gt;

&lt;h4 id=&quot;2class&quot;&gt;2、Class&lt;/h4&gt;

&lt;p&gt;Class的定义&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;typedef struct objc_class *Class;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;objc_class&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct objc_class {
    Class isa;

#if !__OBJC2__
    Class super_class                                        OBJC2_UNAVAILABLE;
    const char *name                                         OBJC2_UNAVAILABLE;
    long version                                             OBJC2_UNAVAILABLE;
    long info                                                OBJC2_UNAVAILABLE;
    long instance_size                                       OBJC2_UNAVAILABLE;
    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;
    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;
    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;
    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;
#endif
} OBJC2_UNAVAILABLE;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;isa指针指向哪里？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ojx0q9o9x.bkt.clouddn.com/Runtime_00.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从图上的虚线箭头就能看出，实例对象的isa指向类，类的isa指向元类(meta)，元类的isa指向Root元类&lt;/p&gt;

&lt;h3 id=&quot;三iskindofclass与ismemberofclass&quot;&gt;三、isKindOfClass与isMemberOfClass&lt;/h3&gt;

&lt;h4 id=&quot;1获取class&quot;&gt;1、获取class&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;+ (Class)class {
    return self;
}

- (Class)class {
    return object_getClass(self);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;static inline Class _object_getClass(id obj)
{
#if SUPPORT_TAGGED_POINTERS
    if (OBJC_IS_TAGGED_PTR(obj)) {
        uint8_t slotNumber = ((uint8_t) (uint64_t) obj) &amp;amp; 0x0F;
        Class isa = _objc_tagged_isa_table[slotNumber];
        return isa;
    }
#endif
    if (obj) return obj-&amp;gt;isa;
    else return Nil;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面可以看到，class类方法和实例方法都是获取当前Class也就是isa指针&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;实例方法调用时，通过对象的 isa 在类中获取方法的实现&lt;/li&gt;
  &lt;li&gt;类方法调用时，通过类的 isa 在元类中获取方法的实现&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2ismemberofclass&quot;&gt;2、isMemberOfClass&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;isMemberOfClass: Returns a Boolean value that indicates whether the receiver is an instance of a given class.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;+ (BOOL)isMemberOfClass:(Class)cls {
    return object_getClass((id)self) == cls;
}

- (BOOL)isMemberOfClass:(Class)cls {
    return [self class] == cls;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，isMemberOfClass是判断当前实例/类是否是那个类型&lt;/p&gt;

&lt;h4 id=&quot;3iskindofclass&quot;&gt;3、isKindOfClass&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;isKindOfClass: Returns a Boolean value that indicates whether the receiver is an instance of given class or an instance of any class that inherits from that class.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;+ (BOOL)isKindOfClass:(Class)cls {
    for (Class tcls = object_getClass((id)self); tcls; tcls = class_getSuperclass(tcls)) {
        if (tcls == cls) return YES;
    }
    return NO;
}

- (BOOL)isKindOfClass:(Class)cls {
    for (Class tcls = [self class]; tcls; tcls = class_getSuperclass(tcls)) {
        if (tcls == cls) return YES;
    }
    return NO;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;isKindOfClass是用来判断实例/类是否是那个类型，或者继承自那个类。&lt;/p&gt;

&lt;h3 id=&quot;四kvo与kvc&quot;&gt;四、KVO与KVC&lt;/h3&gt;

&lt;h4 id=&quot;1kvokey-value-observing&quot;&gt;1、KVO(Key-Value Observing)&lt;/h4&gt;

&lt;p&gt;先看看官方文档&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Key-Value Observing Implementation Details
Automatic key-value observing is implemented using a technique called isa-swizzling.
The isa pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.
When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.
You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;KVO运用了一个isa-swizzling的机制，runtime还有一个method-swizzling的机制，称为’黑魔法’。&lt;/p&gt;

&lt;p&gt;当某个类的对象第一次被观察时，系统就会在运行期动态地创建该类的一个&lt;em&gt;派生类&lt;/em&gt;，在这个&lt;em&gt;派生类&lt;/em&gt;中重写基类中任何被观察属性的 setter 方法。然后在派生类的setter方法里实现通知机制。&lt;/p&gt;

&lt;p&gt;同时派生类还重写了 class 方法以“欺骗”外部调用者它就是起初的那个类。然后系统将这个对象的 isa 指针指向这个新诞生的派生类，因此这个对象就成为该派生类的对象了，因而在该对象上对 setter 的调用就会调用重写的 setter，从而激活键值通知机制。此外，派生类还重写了 dealloc 方法来释放资源。&lt;/p&gt;

&lt;p&gt;当没有observer观察任何一个property时，删除动态创建的子类。&lt;/p&gt;

&lt;p&gt;简单而言：实例对象在被观察时，生成派生类，派生类在setter方法中valuewillchange方法和valuesdidchanged方法里发出通知，并且通过isa-swizzling，从而使实例对象成为派生类的对象，所以实例对象在setter属性时可以产生通知。达到观察的目的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_1/04.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;2kvckey-value-coding&quot;&gt;2、KVC(Key Value Coding)&lt;/h4&gt;

&lt;p&gt;KVC是是一种可以通过字符串的名字（key）来访问类属性的机制。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;修改值&lt;/strong&gt;
setValue:forKey:
setValue:forKeyPath:
setValue:forUnderfinedKey:
setNilValueForKey: 对非类对象属性设置nil时调用，默认抛出异常。&lt;/p&gt;

&lt;p&gt;1、首先搜索setKey:方法。（key指成员变量名，首字母大写）&lt;/p&gt;

&lt;p&gt;2、上面的setter方法没找到，如果类方法accessInstanceVariablesDirectly返回YES。那么按 _key，_isKey，key，iskey的顺序搜索成员名。（NSKeyValueCodingCatogery中实现的类方法，默认实现为返回YES）&lt;/p&gt;

&lt;p&gt;3、如果没有找到成员变量，调用setValue:forUnderfinedKey:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;获取值&lt;/strong&gt;
valueForKey: 传入NSString属性的名字。
valueForKeyPath: 属性的路径，xx.xx
valueForUndefinedKey 默认实现是抛出异常，可重写这个函数做错误处理&lt;/p&gt;

&lt;p&gt;1、首先按getKey，key，isKey的顺序查找getter方法，找到直接调用。如果是BOOL、int等内建值类型，会做NSNumber的转换。&lt;/p&gt;

&lt;p&gt;2、上面的getter没找到，查找countOfKey、objectInKeyAtindex、KeyAtindexes格式的方法。如果countOfKey和另外两个方法中的一个找到，那么就会返回一个可以响应NSArray所有方法的代理集合的NSArray消息方法。&lt;/p&gt;

&lt;p&gt;3、还没找到，查找countOfKey、enumeratorOfKey、memberOfKey格式的方法。如果这三个方法都找到，那么就返回一个可以响应NSSet所有方法的代理集合。
4、还是没找到，如果类方法accessInstanceVariablesDirectly返回YES。那么按 _key，_isKey，key，iskey的顺序搜索成员名。&lt;/p&gt;

&lt;p&gt;5、再没找到，调用valueForUndefinedKey。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;原理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;isa指针（is kind of 的意思）指向维护分发表的对象的类，该分发表实际上包含了指向实现类中的方法的指针和其他数据。比如说如下的一行KVC代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[site setValue:@&quot;sitename&quot; forKey:@&quot;name&quot;];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;//会被编译器处理成&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SEL sel = sel_get_uid(setValue:forKey);
IMP method = objc_msg_loopup(site-&amp;gt;isa,sel);
method(site,sel,@&quot;sitename&quot;,@&quot;name&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;每个类都有一张方法表，是一个hash表，值是还书指针IMP，SEL的名称就是查表时所用的键。&lt;/p&gt;

&lt;p&gt;SEL数据类型：查找方法表时所用的键。定义成char*，实质上可以理解成int值。&lt;/p&gt;

&lt;p&gt;IMP数据类型：他其实就是一个编译器内部实现时候的函数指针。当Objective-C编译器去处理实现一个方法的时候，就会指向一个IMP对象，这个对象是C语言表述的类型。&lt;/p&gt;

&lt;h3 id=&quot;五self与super&quot;&gt;五、Self与Super&lt;/h3&gt;

&lt;h4 id=&quot;1self-class与super-class&quot;&gt;1、[self class]与[super class]&lt;/h4&gt;

&lt;p&gt;有一个有意思的题目，有一个Son类继承自Father类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;    @implementation Son : Father
    - (id)init
    {
        self = [super init];
        if (self) {
            NSLog(@&quot;%@&quot;, NSStringFromClass([self class]));
            NSLog(@&quot;%@&quot;, NSStringFromClass([super class]));
        }
        return self;
    }
    @end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最终结果都是Son，为什么呢？&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;官方文档中self相关解释&lt;/strong&gt;
Whenever you’re writing a method implementation, you have access to an important hidden value, self. Conceptually, self is a way to refer to “the object that’s received this message.” It’s apointer, just like the greeting value above, and can be used to call a method on the current receiving object.
&lt;strong&gt;super解释&lt;/strong&gt;
There’s anotherimportant keyword available to you in Objective-C, called super. Sending a message to super is a way to call through to a method implementation defined by a superclass further up the inheritance chain. The most common use of super is when overriding a method.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简而言之是self调用自己方法，super调用父类方法&lt;/p&gt;

&lt;p&gt;但是底层原理呢？我们知道，OC的消息转发机制，当self时，方法转换成&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;id objc_msgSend(id receiver, SEL theSelector, ...)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;​	objc_msgSend sends a message with a simple return value to an instance of a class&lt;/p&gt;

&lt;p&gt;而super关键字调用方法则转换成&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;id objc_msgSendSuper(struct objc_super *super, SEL op, ...)

struct objc_super {
  id receiver;
  Class superClass;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;​	objc_msgSendSuper sends a message with a simple return value to the superclass of an instance of a class.&lt;/p&gt;

&lt;p&gt;可以看到objc_msgSendSuper的receiver还是son。&lt;/p&gt;

&lt;p&gt;objc_msgSend与objc_msgSendSuperd都去查找class的Seletor，一直查到NSObject类才查到class方法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (Class)class {
    return object_getClass(self);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;也就是说，最终都是调用的receiver也就是son，获取到了Class.&lt;/p&gt;

&lt;h4 id=&quot;2self--super-init&quot;&gt;2、self = [super init]&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;If a class does implement an initializer, it should invoke an initializer of its superclass as the first step. This requirement ensures a series of initializations for an object down the inheritance chain, starting with the root object. The &lt;code class=&quot;highlighter-rouge&quot;&gt;NSObject&lt;/code&gt; class declares the &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; method as the default object initializer, so it is always invoked last but returns first.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_1/05.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;所以标准的初始化代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (id)init {
    if (self = [super init]) { // equivalent to &quot;self does not equal nil&quot;
        self ...
    }
    return self;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;六属性与变量property--instance-variable&quot;&gt;六、属性与变量(property &amp;amp; instance variable)&lt;/h3&gt;

&lt;p&gt;在ios5以后我们使用@property来声明属性变量，编译器会自动(@syntheszie var = _var)为我们生成对应的一个以下 划线加属性名 命名的实例变量，还有其对应的getter、setter&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 
&lt;span class=&quot;o&quot;&gt;------------------&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;等效分割线&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;------------------&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_var&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_var&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setVar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_var&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样一来我们就可以看出通过self.var和_var访问实例变量的区别，在.m文件中可以通过_var来访问实例变量，但是getter、setter不会被调用，而来自外部的访问，需要通过getter、setter。&lt;/p&gt;

&lt;p&gt;注意，使用readonly关键字修饰后，编译器只会为我们生成getter。&lt;/p&gt;

&lt;p&gt;假如一个属性被关键字@dynamic所修饰，则编译器不会自动生成其对应的getter、setter，然而如果开发者没有自行创造getter、setter，将不会在编译期提醒，运行时触发则会发生crash。
顺便一提@dynamic还能帮助我们替换掉某类中本来就存在的，而我们又想自己创造的property。&lt;/p&gt;</content><author><name>Ted</name></author><summary type="html">先看OC关于NSObject的源码</summary></entry><entry><title type="html">漫谈iOS安全</title><link href="http://www.helloted.com/2016/10/11/safety/" rel="alternate" type="text/html" title="漫谈iOS安全" /><published>2016-10-11T20:00:00+08:00</published><updated>2016-10-11T20:00:00+08:00</updated><id>http://www.helloted.com/2016/10/11/safety</id><content type="html" xml:base="http://www.helloted.com/2016/10/11/safety/">&lt;h3 id=&quot;一前言&quot;&gt;一、前言&lt;/h3&gt;

&lt;p&gt;经常都能听到大家说，iOS很安全，iPhone比安卓手机安全。那么为什么iOS会安全，难道仅仅是因为iOS是闭源然后安卓是开源的，开源的就一定比闭源安全？前段时间著名的&lt;em&gt;Xcode Ghost&lt;/em&gt; 事件也让人觉得iOS好像并不是那么地安全，今天就随便说说iOS的安全。&lt;/p&gt;

&lt;h3 id=&quot;二沙盒机制&quot;&gt;二、沙盒机制&lt;/h3&gt;

&lt;h4 id=&quot;沙盒简介&quot;&gt;沙盒简介&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;Complex systems will always have vulnerabilities, and software complexity only increases over time. No matter how carefully you adopt secure coding practices and guard against bugs, attackers only need to get through your defenses once to succeed. While App Sandbox doesn’t prevent attacks against your app, it does minimize the harm a successful one can cause.&lt;/p&gt;

  &lt;p&gt;A non-sandboxed app has the full rights of the user who is running that app, and can access any resources that the user can access. If that app or any framework it is linked against contain security holes, an attacker can potentially exploit those holes to take control of that app, and in doing so, the attacker gains the ability to do anything that the user can do.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;复杂系统始终都会存在漏洞，软件复杂性只会随着时间的推移而增加。 无论你采取安全的编码方式多么谨慎来避免错误，攻击者只需要击穿一次防御就能成功。 虽然应用程序沙盒不能防止对您的应用程序的攻击，但它确实最大限度地减少了可能导致的危害。&lt;/p&gt;

&lt;p&gt;非沙盒应用程序具有正在运行该应用程序的用户的完全权限，并且可以访问用户可以访问的任何资源。 如果该应用程序或任何框架被链接到一些安全漏洞，攻击者可能潜在地利用这些漏洞来控制该应用程序，并且在这样做时，攻击者可以执行任何用户可以执行的操作。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Designed to mitigate this problem, the App Sandbox strategy is twofold:&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;App Sandbox enables you to describe how your app interacts with the system. The system then grants your app the access it needs to get its job done, and no more.&lt;/li&gt;
    &lt;li&gt;App Sandbox allows the user to transparently grant your app additional access by way of Open and Save dialogs, drag and drop, and other familiar user interactions.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;为了解决上面的问题，沙盒策略有两个方面：&lt;/p&gt;

&lt;p&gt;应用程序沙盒允许您描述应用程序如何与系统进行交互。 系统然后授予您的应用程序所需的访问权限，以完成其工作，不会赋予更多的权限。
应用程序沙盒允许用户通过打开和保存对话框，拖放和其他熟悉的用户交互方式透明地授予您的应用程序附加访问权限。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/safety/safety_01.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;ios的沙盒&quot;&gt;iOS的沙盒&lt;/h4&gt;

&lt;p&gt;来看看iOS的沙盒结构图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/safety/safety_00.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;iOS应用程序只能在为该改程序创建的文件系统中读取文件，不可以去其它地方访问，此区域被成为沙盒，所以所有的非代码文件都要保存在此，例如图像，图标，声音，映像，属性列表，文本文件等。&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;每个应用程序都有自己的存储空间&lt;/li&gt;
    &lt;li&gt;应用程序不能翻过自己的围墙去访问别的存储空间的内容&lt;/li&gt;
    &lt;li&gt;应用程序请求的数据都要通过权限检测，假如不符合条件的话，不会被放行。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/img/safety/safety_02.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;三https&quot;&gt;三、HTTPS&lt;/h3&gt;

&lt;p&gt;这是对网络数据传输过程中的加密。&lt;/p&gt;

&lt;p&gt;其实HTTPS从最终的数据解析的角度，与HTTP没有任何的区别，HTTPS就是将HTTP协议数据包放到SSL/TSL层加密后，在TCP/IP层组成IP数据报去传输，以此保证传输数据的安全；而对于接收端，在SSL/TSL将接收的数据包解密之后，将数据传给HTTP协议层，就是普通的HTTP数据。HTTP和SSL/TSL都处于OSI模型的应用层。从HTTP切换到HTTPS是一个非常简单的过程。&lt;/p&gt;

&lt;p&gt;可参考这篇博文&lt;a href=&quot;http://www.helloted.com/2016/09/13/Http/&quot;&gt;Http与Https&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;四app加固&quot;&gt;四、APP加固&lt;/h3&gt;

&lt;h4 id=&quot;1字符串混淆&quot;&gt;1、字符串混淆&lt;/h4&gt;

&lt;p&gt;我们在代码中有时候会用到一些静态字符串，比如像一些SDK的key、网络加密使用的“盐”等字符串，不能使用明文保存，需要对这些静态字符串进行加密，以防止在APP被反编译后泄露。然后在需要使用字符串的地方进行解密。通常我们使用异或加密来加密字符串.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;异或的运算方法是一个二进制运算：
1^1=0
0^0=0
1^0=1
0^1=1&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;两者相等为0,不等为1.&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;对于一个字符来说,都可以用二进制码来表示.如A:01000001，字符的异或就是对每一位进行二进制运算.
用于加密算法时,假设你要加密的内容为A,密钥为B,则可以用&lt;/p&gt;

  &lt;p&gt;异或加密:C=A^B
在数据中保存加密后的C就行了.
用的时候:A=B^C
即可取得原加密A的内容,所以只要知道密钥,就可以完成加密和解密.&lt;/p&gt;

  &lt;p&gt;异或加密和解密的方法一致，运算一次就是加密，再运算一次就是解密。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (NSString *)xorStr:(NSString *)xorStr withKey:(NSString *)key{
    NSData  *strData = [xorStr dataUsingEncoding:NSUTF8StringEncoding];
    NSData *keyData = [key dataUsingEncoding:NSUTF8StringEncoding];
    Byte *keyBytes = (Byte *)[keyData bytes];   //取关键字的Byte数组, keyBytes一直指向头部
    Byte *sourceDataPoint = (Byte *)[strData bytes];  //取需要异或的数据的Byte数组
    for (long i = 0; i &amp;lt; [strData length]; i++) {
        sourceDataPoint[i] = sourceDataPoint[i] ^ keyBytes[(i % [keyData length])]; //然后按位进行异或运算
    }
    NSString *outStr = [[NSString alloc]initWithData:strData encoding:NSUTF8StringEncoding];
    return outStr;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;类名、方法名混淆&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;对应用程序的方法名和方法体进行混淆，保证源码被逆向后很难明白它的真正功能。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;程序结构混淆加密&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;对应用程序逻辑结构进行打乱混排，保证源码可读性降到最低。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;反调试、反注入等一些主动保护策略&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;这是一些主动保护策略，增大破解者调试、分析APP的门槛。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>Ted</name></author><summary type="html">一、前言</summary></entry><entry><title type="html">监测APP卡顿</title><link href="http://www.helloted.com/2016/10/06/smoothMonitor/" rel="alternate" type="text/html" title="监测APP卡顿" /><published>2016-10-06T20:00:00+08:00</published><updated>2016-10-06T20:00:00+08:00</updated><id>http://www.helloted.com/2016/10/06/smoothMonitor</id><content type="html" xml:base="http://www.helloted.com/2016/10/06/smoothMonitor/">&lt;h3 id=&quot;一简介&quot;&gt;一、简介&lt;/h3&gt;

&lt;p&gt;我们说的卡顿，一般指操作某个功能时，UI界面无及时反应，这种卡顿日常测试一般难以追踪以及重现，所以除了工程师开发测试的时候发现卡顿，还有一个重要的渠道就是从用户实际体验来监测卡顿，但是我们又不能拿到用户的手机或者让用户来回馈问题，所以一个完整的监测体系就很有必要了。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;监测卡顿：开一个子线程，利用Runloop来监测卡顿；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;收集堆栈：将卡顿时的堆栈收集起来；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;上传记录：将卡顿上传到后台或自定义；&lt;/p&gt;

    &lt;p&gt;这里我引用一张微信开发团队的监测流程图：&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/img/Smooth/smooth_01.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;二监测卡顿&quot;&gt;二、监测卡顿&lt;/h3&gt;

&lt;p&gt;首先我们来看一个Runloop的运行方式，如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;int32_t __CFRunLoopRun()
{
    // 通知即将进入runloop
  	//创建AutoreleasePool: _objc_autoreleasePoolPush();
    __CFRunLoopDoObservers(KCFRunLoopEntry);
    
    do
    {
        // 通知将要处理timer和source
        __CFRunLoopDoObservers(kCFRunLoopBeforeTimers);
        __CFRunLoopDoObservers(kCFRunLoopBeforeSources);
        
        // 处理非延迟的主线程调用
        __CFRunLoopDoBlocks();
        // 处理UIEvent事件
        __CFRunLoopDoSource0();
        
        // GCD dispatch main queue
        CheckIfExistMessagesInMainDispatchQueue();
        
        // 即将进入休眠
      	//释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();
        __CFRunLoopDoObservers(kCFRunLoopBeforeWaiting);
        
        // 等待内核mach_msg事件
        mach_port_t wakeUpPort = SleepAndWaitForWakingUpPorts();
        
        // Zzz...
        
        // 从等待中醒来
        __CFRunLoopDoObservers(kCFRunLoopAfterWaiting);
                
        if (wakeUpPort == timerPort){// 处理因timer的唤醒
          __CFRunLoopDoTimers();
        }else if (wakeUpPort == mainDispatchQueuePort){// 处理异步方法唤醒,如dispatch_async
          __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()
        } else{// UI刷新,动画显示
          __CFRunLoopDoSource1();
        }   
        // 再次确保是否有同步的方法需要调用
        __CFRunLoopDoBlocks();
        
    } while (!stop &amp;amp;&amp;amp; !timeout);
    
    // 通知即将退出runloop
  	//释放AutoreleasePool: _objc_autoreleasePoolPop();
    __CFRunLoopDoObservers(CFRunLoopExit);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;UI更新一般&lt;font color=&quot;gray&quot;&gt;kCFRunLoopBeforeSources&lt;/font&gt;和&lt;font color=&quot;gray&quot;&gt;kCFRunLoopBeforeWaiting&lt;/font&gt;之间，所以我们监测他们之间的时间段就能知道UI是否卡顿了&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)startMoniter{
	//添加监听
    CFRunLoopObserverContext context = {0,(__bridge void*)self,NULL,NULL};
    _observer = CFRunLoopObserverCreate(kCFAllocatorDefault,
                                        kCFRunLoopAllActivities,
                                        YES,
                                        0,
                                        &amp;amp;runLoopObserverCallBack,
                                        &amp;amp;context);
    CFRunLoopAddObserver(CFRunLoopGetMain(), _observer, kCFRunLoopCommonModes);
    
    // 创建信号
    _semaphore = dispatch_semaphore_create(0);
    
    // 在子线程监控时长
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        while (YES)
        {
            NSLog(@&quot;smooth--monitering&quot;);
            //100ms则将堆栈记录下来
            long st = dispatch_semaphore_wait(_semaphore, dispatch_time(DISPATCH_TIME_NOW, 100*NSEC_PER_MSEC));
            if (st != 0)
            {
                if (_activity==kCFRunLoopBeforeSources || _activity==kCFRunLoopAfterWaiting)
                {
                    [self logStack];
                }
            }
        }
    });
}

static void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)
{
    SmoothMoniter *instrance = [SmoothMoniter sharedInstance];
    instrance.activity = activity;
    dispatch_semaphore_t semaphore = instrance.semaphore;
    dispatch_semaphore_signal(semaphore);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;三收集堆栈&quot;&gt;三、收集堆栈&lt;/h3&gt;

&lt;p&gt;收集堆栈信息以用来分析卡顿引起的代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &amp;lt;libkern/OSAtomic.h&amp;gt;
#import &amp;lt;execinfo.h&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)logStack{
    void* callstack[128];
    int frames = backtrace(callstack, 128);
    char **strs = backtrace_symbols(callstack, frames);
    int i;
    NSMutableArray *backtrace = [NSMutableArray arrayWithCapacity:frames];
    for ( i = 0 ; i &amp;lt; frames ; i++ ){
        [backtrace addObject:[NSString stringWithUTF8String:strs[i]]];
    }
    free(strs);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以得到类似于下方的堆栈记录&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Smooth/smooth_02.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;四上传记录&quot;&gt;四、上传记录&lt;/h3&gt;

&lt;p&gt;1、频率以及流量：是否所有的用户都要做统计？上传的频率？文件压缩以减少流量？这些问题都要根据实际情况作好准备。&lt;/p&gt;

&lt;p&gt;2、上传位置，一种是自己建立后台来统计这些卡顿，嫌麻烦的话是利用第三方平台、如友盟（统计崩溃比较多）、听云、OneApm、博睿，都大同小异。&lt;/p&gt;

&lt;h3 id=&quot;五代码&quot;&gt;五、代码&lt;/h3&gt;

&lt;p&gt;上面的代码可以在&lt;a href=&quot;https://github.com/helloted/smoothMonitor&quot;&gt;smoothMonitor&lt;/a&gt; 下载&lt;/p&gt;</content><author><name>Ted</name></author><summary type="html">一、简介</summary></entry></feed>