<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://www.helloted.com/feed.xml" rel="self" type="application/atom+xml" /><link href="http://www.helloted.com/" rel="alternate" type="text/html" /><updated>2024-07-12T19:02:04+08:00</updated><id>http://www.helloted.com/feed.xml</id><title type="html">Helloted Blog</title><subtitle>曹浩之Helloted的技术博客，用于记录一些技术成长过程中的技术分享，包括客户端iOS/Android，后台Pyhon/Java，跨平台开发Flutter</subtitle><entry><title type="html">数据库事务</title><link href="http://www.helloted.com/%E6%95%B0%E6%8D%AE%E5%BA%93/2022/11/01/transaction/" rel="alternate" type="text/html" title="数据库事务" /><published>2022-11-01T20:00:00+08:00</published><updated>2022-11-01T20:00:00+08:00</updated><id>http://www.helloted.com/%E6%95%B0%E6%8D%AE%E5%BA%93/2022/11/01/transaction</id><content type="html" xml:base="http://www.helloted.com/%E6%95%B0%E6%8D%AE%E5%BA%93/2022/11/01/transaction/">&lt;h3 id=&quot;1什么是事务&quot;&gt;1、什么是事务&lt;/h3&gt;

&lt;p&gt;所谓事务是用户定义的一个数据库操作序列， 这些操作要么全做，要么全不做，是一个不可分割的工作单位。&lt;/p&gt;

&lt;p&gt;在关系型数据库中，一个事务可以是一条 SQL 语句，一组 SQL 语句或者是整个程序，事务的开始和结束由用户显示控制，如果用户没有显式定义事务，则由 DBMS 按默认规定自动划分事务，如在 MySQL 中默认 autocommit 为 ON 则开启事务自动提交，每条没有显式定义事务的 SQL 语句都会被当作一个单独的事务并自动提交(隐式事务)。&lt;/p&gt;

&lt;p&gt;数据库事务可以确保该事务范围内的所有操作都可以全部成功或者全部失败。如果事务失败，那么效果就和没有执行这些SQL一样，不会对数据库数据有任何改动。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;显式和隐式：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;单条SQL语句，数据库系统自动将其作为一个事务执行，这种事务被称为隐式事务。&lt;/li&gt;
  &lt;li&gt;多条SQL语句作为一个事务执行，使用BEGIN/START TRANSACTION;开启一个事务，使用COMMIT提交一个事务，这种事务被称为显式事务。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;COMMIT和RollBack&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;COMMIT是指提交事务，即试图把事务内的所有SQL所做的修改永久保存。&lt;/li&gt;
  &lt;li&gt;ROLLBACK是对之前的事务操作进行回滚；回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；&lt;/li&gt;
  &lt;li&gt;如果COMMIT失败了，会自动调用ROLLBACK，也就是之前的操作会回滚。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2acid四个特性&quot;&gt;2、ACID四个特性&lt;/h3&gt;

&lt;p&gt;数据库事务具有ACID这4个特性：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A：Atomicity，原子性，将所有SQL作为原子工作单元执行，要么全部执行，要么全部不执行；&lt;/li&gt;
  &lt;li&gt;C：Consistency，一致性，事务完成后，所有数据的状态都是一致的，即A账户只要减去了100，B账户则必定加上了100；&lt;/li&gt;
  &lt;li&gt;I：Isolation，隔离性，如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离；&lt;/li&gt;
  &lt;li&gt;D：Durability，持久性，即事务完成后，对数据库数据的修改被持久化存储。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3并发事务导致&quot;&gt;3、并发事务导致&lt;数据不一致&gt;&lt;/数据不一致&gt;&lt;/h3&gt;

&lt;p&gt;并发事务可能导致以下几种数据不一致的情况：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;脏读（Dirty Read）： 脏读指的是一个事务读取了另一个事务尚未提交的数据。如果后续事务回滚，那么之前读取的数据就是无效的，导致数据不一致。&lt;/li&gt;
  &lt;li&gt;不可重复读（Non-repeatable Read）： 不可重复读指的是在同一个事务中，多次读取同一数据时，得到的结果不一致。这是因为在事务执行期间，其他事务修改了该数据。&lt;/li&gt;
  &lt;li&gt;幻读（Phantom Read）： 幻读指的是在同一个事务中，多次查询同一范围的数据时，得到的结果不一致。这是因为在事务执行期间，其他事务插入或删除了符合查询条件的数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些数据不一致的情况是由于并发事务之间的交互和修改操作导致的。&lt;/p&gt;

&lt;p&gt;不同的隔离级别可以控制事务之间的相互影响，从而避免或减少这些数据不一致的问题。较高的隔离级别可以提供更强的数据一致性，但可能会降低并发性能。&lt;/p&gt;

&lt;p&gt;为了保证数据的一致性，需要在设计数据库架构和事务处理时，合理选择隔离级别，并使用适当的并发控制机制：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;LBCC（Lock-Base Concurrency Control）基于锁的并发控制；&lt;/li&gt;
  &lt;li&gt;MVCC（Multiversion Concurrency Control）多版本并发控制；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4隔离级别&quot;&gt;4、隔离级别&lt;/h3&gt;

&lt;p&gt;数据库的隔离级别是指多个并发事务之间的隔离程度，用于控制事务之间的相互影响和数据一致性的要求。&lt;/p&gt;

&lt;p&gt;隔离级别定义了一个事务在读取和修改数据时能够看到其他事务的哪些变化。 常见的数据库隔离级别包括：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;读未提交（Read Uncommitted）： 最低的隔离级别，这种级别实际上是没有做隔离，事务可以读取其他事务尚未提交的数据。这种隔离级别可能导致脏读（Dirty Read），即读取到未提交的数据。&lt;/li&gt;
  &lt;li&gt;读已提交（Read Committed）： 事务只能读取已经提交的数据，避免了脏读。但是在同一个事务中，多次读取同一数据可能会看到不同的结果，因为其他事务可能在事务执行期间修改了数据。&lt;/li&gt;
  &lt;li&gt;可重复读（Repeatable Read）： 事务在执行期间保持一致的快照视图，即事务开始时读取的数据将保持不变。其他事务对数据的修改不会影响当前事务的读取结果。这种隔离级别可以避免脏读和不可重复读（Non-repeatable Read），是MySQL默认级别。&lt;/li&gt;
  &lt;li&gt;串行化（Serializable）： 最高的隔离级别，这种级别实际上是完全隔离，将并发执行的事务串行化。这种隔离级别可以避免脏读、不可重复读和幻读（Phantom Read），但会降低并发性能。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;不同的隔离级别提供了不同的数据一致性和并发性能权衡。较低的隔离级别可以提高并发性能，但可能导致数据不一致。较高的隔离级别可以保证数据一致性，但可能降低并发性能。&lt;/p&gt;

&lt;h3 id=&quot;5这四种隔离级别具体是如何实现的呢&quot;&gt;5、这四种隔离级别具体是如何实现的呢？&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;对于最低级的「读未提交」隔离级别的事务来说，这是没有隔离；&lt;/li&gt;
  &lt;li&gt;对于最高级的「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；&lt;/li&gt;
  &lt;li&gt;对于中间的「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同。
    &lt;ul&gt;
      &lt;li&gt;「读已提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，&lt;/li&gt;
      &lt;li&gt;「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;隔离级别只是定义了在不同的级别下应该保证哪些一致性，具体实现这些隔离级别的方法有很多，如传统的基于锁的并发控制（LBCC），还有一些无锁并发控制方案，如时间戳（timestamp), 乐观控制法（scheduler），多版本并发控制（MVCC）等。&lt;/p&gt;

&lt;h3 id=&quot;6并发控制&quot;&gt;6、并发控制&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;LBCC（Lock-Base Concurrency Control）基于锁的并发控制；&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;所谓封锁就是事务在某个数据对象进行操作之前先申请锁，对该对象加锁后，该事务就拥有了一定的对该对象的控制，在该事务释放该锁前，其他事务不能操作此数据对象。 从锁的模式来看，锁可以分为共享锁和排它锁，共享锁又称为读锁（S 锁），排它锁又称为写锁（X锁）。&lt;/p&gt;

&lt;p&gt;X 锁：若事务 T 对数据对象 A 加上了 X 锁，则只允许 T 读取和修改 A， 其他任何事务不得再对 A加任何类型的锁，直到 T 释放锁，。&lt;/p&gt;

&lt;p&gt;S 锁：若事务 T 对数据对象 A 加上了 S 锁，则 T 和其他事务都可以可以读 A，同时其他事务可以继续申请 A 的 S 锁，但是直到所有事务都释放 A 的 S 锁为止（所有事务并不包括自己），A 是不允许修改的。这就意味着如果只有一个事务对 A 添加了 S 锁，那他自己是可以修改数据的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MVCC（Multiversion Concurrency Control）多版本并发控制&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通过 LBCC， 我们可以解决所有的并发不一致问题，那为什么还会有其他并发控制方案呢？归根结底还是基于性能的考虑， LBCC 只是实现了允许并发读，但对于并发读写，写写操作只能串行执行，在读写都很频繁的场景下，并发性能将大大降低，因此，人们才提出各种无锁并发控制方案，MVCC 就属于其中一种。&lt;/p&gt;

&lt;p&gt;MVCC 的大概思路是每一个事务都有一个唯一的ID，当某一个事务要修改某行数据时，先将这一行原来的数据做一个快照保存下来，当有其他并发事务也要操作这个事务时，可以操作之前的版本，这样，最新的版本只被写事务维持，不会干扰到读事务，以此实现隔离，MVCC 并没有一个统一的标准，不同 DBS 的实现也不尽相同。&lt;/p&gt;</content><author><name>Ted</name></author><category term="数据库" /><summary type="html">1、什么是事务</summary></entry><entry><title type="html">数据库事务之MVCC机制</title><link href="http://www.helloted.com/%E6%95%B0%E6%8D%AE%E5%BA%93/2022/10/10/mvvc/" rel="alternate" type="text/html" title="数据库事务之MVCC机制" /><published>2022-10-10T20:00:00+08:00</published><updated>2022-10-10T20:00:00+08:00</updated><id>http://www.helloted.com/%E6%95%B0%E6%8D%AE%E5%BA%93/2022/10/10/mvvc</id><content type="html" xml:base="http://www.helloted.com/%E6%95%B0%E6%8D%AE%E5%BA%93/2022/10/10/mvvc/">&lt;h4 id=&quot;1并发事务的四种场景&quot;&gt;&lt;strong&gt;1、并发事务的四种场景&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;并发事务中又会分为四种情况，分别是读-读、写-写、读-写、写-读，这四种情况分别对应并发事务执行时的四种场景。&lt;/p&gt;

&lt;h5 id=&quot;11读-读场景&quot;&gt;1.1、读-读场景&lt;/h5&gt;

&lt;p&gt;读-读场景即是指多个事务/线程在一起读取一个相同的数据，比如事务T1正在读取ID=88的行记录，事务T2也在读取这条记录，两个事务之间是并发执行的。读-读场景不存在任何数据竞争问题，不需要并发控制。&lt;/p&gt;

&lt;h5 id=&quot;12写-写场景&quot;&gt;1.2、写-写场景&lt;/h5&gt;

&lt;p&gt;写-写场景也比较简单，也就是指多个事务之间一起对同一数据进行写操作，比如事务T1对ID=88的行记录做修改操作，事务T2则对这条数据做删除操作，事务T1提交事务后想查询看一下，结果连这条数据都不见了，这也是所谓的脏写问题，也被称为更新覆盖问题，对于这个问题在所有数据库、所有隔离级别中都是零容忍的存在，最低的隔离级别也要解决这个问题。&lt;/p&gt;

&lt;h5 id=&quot;13读-写写-读场景&quot;&gt;1.3、读-写、写-读场景&lt;/h5&gt;

&lt;p&gt;读-写、写-读实际上从宏观角度来看，可以理解成同一种类型的操作，但从微观角度而言则是两种不同的情况，&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;读-写是指一个事务先开始读，然后另一个事务则过来执行写操作，&lt;/li&gt;
  &lt;li&gt;写-读则相反，主要是读、写发生的前后顺序的区别。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;并发事务中同时存在读、写两类操作时，这是最容易出问题的场景，脏读、不可重复读、幻读都出自于这种场景中，当有一个事务在做写操作时，读的事务中就有可能出现这一系列问题，因此数据库才会引入各种机制解决。&lt;/p&gt;

&lt;h5 id=&quot;14各场景下解决问题的方案&quot;&gt;1.4、各场景下解决问题的方案&lt;/h5&gt;

&lt;p&gt;在《锁机制》中，对于写-写、读-写、写-读这三类场景，都是利用加锁的方案确保线程安全，但是，加锁会导致部分事务串行化，因此效率会下降，而MVCC机制的诞生则解决了这个问题。写-写场景必须要加锁才能保障安全，因此先将该场景排除在外。&lt;/p&gt;

&lt;p&gt;基于读-写并存的场景，推出了MVCC机制，在线程安全问题和加锁串行化之间做了一定取舍，让两者之间达到了很好的平衡，即防止了脏读、不可重复读及幻读问题的出现，又无需对并发读-写事务加锁处理。&lt;/p&gt;

&lt;h5 id=&quot;总结&quot;&gt;总结&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;读-读：无需并发控制&lt;/li&gt;
  &lt;li&gt;写-写：必须加锁执行串行&lt;/li&gt;
  &lt;li&gt;读-写、写-读：可以引入MVCC机制，在不加锁的情况下，保证并发安全，提升效率&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2mvcc是什么&quot;&gt;&lt;strong&gt;2、MVCC是什么？&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;MVCC，全称是多版本并发控制（Multi-Version Concurrency Control），是一种常用的并发控制方法。它通过在每个读取的数据行中创建数据行的“快照” —— 即该行在事务处理开始时的精确副本，来解决读-写冲突的问题。这样，每个事务读取的都是一致的行数据快照，而不是最新的行版本。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MVCC的目的&lt;/strong&gt;：用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MVCC如何保证并发安全&lt;/strong&gt;：MVCC通过对数据进行多版本保存，根据比较版本号来控制数据是否展示，从而达到读取数据时无需加锁就可以实现事务的隔离性。&lt;/p&gt;

&lt;p&gt;MySQL 是怎么解决幻读的？&lt;/p&gt;

&lt;p&gt;MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了，解决的方案有两种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;针对&lt;strong&gt;快照读&lt;/strong&gt;（普通 select 语句），是&lt;strong&gt;通过 MVCC 方式解决了幻读&lt;/strong&gt;，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。&lt;/li&gt;
  &lt;li&gt;针对&lt;strong&gt;当前读&lt;/strong&gt;（select … for update 等语句），是&lt;strong&gt;通过 next-key lock（记录锁+间隙锁）方式解决了幻读&lt;/strong&gt;，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;3mvcc的实现原理&quot;&gt;&lt;strong&gt;3、MVCC的实现原理&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;MVCC的实现原理主要包括以下几个步骤：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;版本号&lt;/strong&gt;：每个事务开始时，都会被分配一个唯一的事务ID，这个ID同时也是该事务的版本号。对于每一行数据，都会有两个版本号，
    &lt;ul&gt;
      &lt;li&gt;一个是创建版本号，表示创建这行数据的事务的版本号；&lt;/li&gt;
      &lt;li&gt;另一个是删除版本号，表示删除这行数据的事务的版本号。初始时，删除版本号为空。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;读操作&lt;/strong&gt;：当一个事务要读取一行数据时，会检查这行数据的创建版本号和删除版本号。只有当创建版本号小于等于当前事务的版本号，并且删除版本号要么为空，要么大于当前事务的版本号，这行数据才会被当前事务读取。这样可以确保每个事务都是在一致的快照上进行操作。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;写操作&lt;/strong&gt;：当一个事务要修改一行数据时，不会直接覆盖原数据，而是会复制一份新的数据行，然后修改这份新的数据行。新的数据行的创建版本号为当前事务的版本号，删除版本号为空。同时，原数据行的删除版本号会被设置为当前事务的版本号。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;提交事务&lt;/strong&gt;：当一个事务提交时，所有由该事务创建的新数据行的删除版本号都会被设置为无穷大，表示这些数据行现在是可见的。同时，所有被该事务删除的原数据行的删除版本号会被设置为当前事务的版本号，表示这些数据行现在是不可见的。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;垃圾回收&lt;/strong&gt;：为了防止数据版本过多导致的性能问题，需要定期进行垃圾回收。垃圾回收的原则是，只有当没有任何事务会访问到某个数据版本时，这个数据版本才会被回收。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;MVCC的优点是读操作不会被写操作阻塞，写操作也不会被读操作阻塞，大大提高了数据库的并发性能。但是，MVCC也有一些缺点，比如版本链过长会影响读性能，以及需要定期进行垃圾回收等。&lt;/p&gt;

&lt;h5 id=&quot;如何实现&quot;&gt;如何实现？&lt;/h5&gt;

&lt;p&gt;MVCC机制主要通过隐藏字段、Undo-log日志、ReadView这三个东西实现的，其中的多版本主要依赖Undo-log日志来实现，而并发控制则通过表的隐藏字段+ReadView快照来实现。&lt;/p&gt;

&lt;h5 id=&quot;31--undo-log&quot;&gt;3.1  undo log&lt;/h5&gt;

&lt;p&gt;Undo log主要用于事务回滚时恢复原来的数据。mysql在执行sql时，会将一天逻辑相反的日志保存到undo log中。因此，undo log中记录的也是逻辑日志。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;执行Insert语句时，会在undo log日志中记录本次插入的主键id。等事务回滚时，delete删除此id。&lt;/li&gt;
  &lt;li&gt;执行update语句时，MySQL会将修改前的数据保存在undo log中。等事务回滚时，再执行一次update，得到原来的数据。&lt;/li&gt;
  &lt;li&gt;执行delete语句时，会在undo log中保存删除前的数据。等事务回滚时，再执行insert，插入原来的数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ReadView要通过undo log链条找到合适自己读取的记录。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.2 隐藏字段&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在数据库的每行上，除了存放真实的数据以外，还存在3个隐藏的列：row_id、trx_id和roll_pointerrow_id，&lt;/p&gt;

&lt;p&gt;row_id，行号：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果当前表有整数类型的主键，那么row_id的值就是主键的值&lt;/li&gt;
  &lt;li&gt;如果没有整数类型的主键，则MySQL会按照字段的顺序选择一个非空的整数类型的唯一索引为row_id&lt;/li&gt;
  &lt;li&gt;如果都没有找到，则会创建一个自动增长的整数作为row_id&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;trx_id，是哪个事务记录的这条log：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当一个事务开始执行前，MySQL就会为这个事务分配一个全局自增的事务id。&lt;/li&gt;
  &lt;li&gt;之后该事务对当前进行的增、改、删除等操作时，都会将自己的事务ID记录到trx_id中，表明是哪个事务修改的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;roll_pointer，回滚指针：undo日志中指向修改之前的的一行记录。当一直有事务对该行改动时，就会一直生成undo log，最终将会形成undo log版本链。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.3&lt;/strong&gt; &lt;strong&gt;ReadView&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ReadView可以被理解为一个过滤器或者说是一个视图，它定义了在当前事务中，哪些数据版本是可见的，哪些数据版本是不可见的。&lt;/p&gt;

&lt;p&gt;具体来说，ReadView包含以下几个重要的信息：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;creator_trx_id：当前事务id&lt;/li&gt;
  &lt;li&gt;m_ids：这是一个列表，包含了在当前事务开始时，所有活跃（即还未提交）的事务的ID。&lt;/li&gt;
  &lt;li&gt;min_trx_id：这是m_ids&lt;strong&gt;列表中&lt;/strong&gt;的最小事务ID。这个ID表示了在当前事务开始时，系统中最早开始的尚未提交的事务ID。&lt;/li&gt;
  &lt;li&gt;max_trx_id：表示生成readview时，系统中应该分配给下一个事务的id值&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;4mvcc如何是运作的&quot;&gt;4、MVCC如何是运作的&lt;/h4&gt;

&lt;p&gt;根据undo log的链中的每一条trx_id与min_trx_id和max_trx_id进行对比：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果小于min_trx_id，说明这个trx_id的log记录就已经事务已经提交过了，完成的事务，创建本事务之前就已经存在的日志，当然可以读。&lt;/li&gt;
  &lt;li&gt;如果大于max_trx_id说明这个版本的数据log是在创建RV之后生成的，不可读。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果是在这之间，查看trx_id是否包含m_ids列表之中：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;不包含说明创建RV之前这个事务已经被提交了，那么是可读的。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;包含说明创建RV的时候，还是活跃（没提交）事务。那么是不可读的，有可能脏读；到了这里说明这条数据的变更版本在RV之内，则要查看creator_trx_id与trx_id是否一致：&lt;/p&gt;
        &lt;ul&gt;
          &lt;li&gt;一致说明就是当前事务创建的；允许使用；&lt;/li&gt;
          &lt;li&gt;否则说明是当前RV的其他事务操作的，不能使用;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;41-可重复读是如何工作的&quot;&gt;&lt;strong&gt;4.1 可重复读是如何工作的？&lt;/strong&gt;&lt;/h5&gt;

&lt;p&gt;一旦创建是不可变的，即便其他事务提交了，也不会影响当前事务创建的ReadView，你可以理解为一个副本快照。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.2 读已提交是如何工作的？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;读已提交隔离级别是在每次读取数据时，都会生成一个新的Read View。&lt;/p&gt;</content><author><name>Ted</name></author><category term="数据库" /><summary type="html">1、并发事务的四种场景</summary></entry><entry><title type="html">数据库架构</title><link href="http://www.helloted.com/%E6%95%B0%E6%8D%AE%E5%BA%93/2022/09/19/mysql/" rel="alternate" type="text/html" title="数据库架构" /><published>2022-09-19T20:00:00+08:00</published><updated>2022-09-19T20:00:00+08:00</updated><id>http://www.helloted.com/%E6%95%B0%E6%8D%AE%E5%BA%93/2022/09/19/mysql</id><content type="html" xml:base="http://www.helloted.com/%E6%95%B0%E6%8D%AE%E5%BA%93/2022/09/19/mysql/">&lt;h3 id=&quot;一mysql架构&quot;&gt;一、MySQL架构&lt;/h3&gt;

&lt;p&gt;MySQL 的架构共分为两层：&lt;strong&gt;Server 层、存储引擎层：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Server 层负责建立连接、分析和执行 SQL。MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Server 层实现。&lt;/li&gt;
  &lt;li&gt;存储引擎层负责数据的存储和提取。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。现在最常用的存储引擎是 InnoDB，从 MySQL 5.5 版本开始， InnoDB 成为了 MySQL 的默认存储引擎。我们常说的索引数据结构，就是由存储引擎层实现的，不同的存储引擎支持的索引类型也不相同，比如 InnoDB 支持索引类型是 B+树 ，且是默认使用，也就是说在数据表中创建的主键索引和二级索引默认使用的是 B+ 树索引。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;执行一条 SQL 查询语句，期间发生了什么？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;连接器：建立连接，管理连接、校验用户身份；&lt;/li&gt;
  &lt;li&gt;查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；&lt;/li&gt;
  &lt;li&gt;解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；&lt;/li&gt;
  &lt;li&gt;执行 SQL：执行 SQL 共有三个阶段：
    &lt;ul&gt;
      &lt;li&gt;预处理阶段：检查表或字段是否存在；将 select * 中的 * 符号扩展为表上的所有列。&lt;/li&gt;
      &lt;li&gt;优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；&lt;/li&gt;
      &lt;li&gt;执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/53.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;1连接器&quot;&gt;&lt;strong&gt;1、连接器&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;MySQL 是基于 TCP 协议进行传输的。&lt;/p&gt;

&lt;p&gt;连接器的工作：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;与客户端进行 TCP 三次握手建立连接；&lt;/li&gt;
  &lt;li&gt;校验客户端的用户名和密码，如果用户名或密码不对，则会报错；&lt;/li&gt;
  &lt;li&gt;如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限；&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;如何查看 MySQL 服务被多少个客户端连接了？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;可以执行 show processlist 命令进行查看。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;空闲连接会一直占用着吗？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;MySQL 定义了空闲连接的最大空闲时长，由 wait_timeout 参数控制的，默认值是 8 小时（28880秒），如果空闲连接超过了这个时间，连接器就会自动将它断开。&lt;/p&gt;

&lt;p&gt;手动断开空闲的连接，使用的是 kill connection + id 的命令。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;MySQL 的连接数有限制吗？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;MySQL 服务支持的最大连接数由 max_connections 参数控制，比如我的 MySQL 服务默认是 151 个,超过这个值，系统就会拒绝接下来的连接请求，并报错提示“Too many connections”。&lt;/p&gt;

&lt;p&gt;长连接和短连接、连接池&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;短连接&lt;/strong&gt;就是我们开发的应用程序需要访问数据库时候，需要建立数据连接，执行SQL操作，关闭连接。简单讲就是每一次操作数据库，都要执行一次上述操作。它的弊端就是：如果网络速度不是很理想的情况下，短连接的会消耗大量的系统资源，在生产环境中，业务很多的话，可能 1 秒内几千个连接，如果都是短连接，且 sql 处理慢的话，连接关闭不及时，那么资源耗尽速度可能发生在几分钟甚至几秒，所以我们系统不大可能一直是短连接。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;长连接&lt;/strong&gt;是指我们的程序和数据库连接之后，就一直打开，后面程序来访问相同数据库就复用该连接，使用长连接主要是考虑到减少短连接连接的开销，但是从服务器端来看，维持一个连接会占用服务器内存，如果所有程序都是长连接，肯定会有部分连接处于闲置状态，但是无论什么状态连接，都占用内存，这会造成服务器端的资源浪费，也显得不是很高效。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;连接池&lt;/strong&gt;，它是一个预先创建的连接缓冲池，考虑到某些数据进行连接之后，处理时间过长，而不想它闲置，允许给其他线程使用。一般现在的应用服务器都带有连接池组件，允许应用程序，客户端来连接，应用服务器维护着连接池的整个生命周期。数据库连接池技术的思想非常简单，将数据库连接作为对象存储在一个Vector对象中，一旦数据库连接建立后，不同的数据库访问请求就可以共享这些连接，这样，通过复用这些已经建立的数据库连接，可以克服无论长连接和短连接缺点，极大地节省系统资源和时间&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;怎么解决长连接占用内存的问题？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;定期断开长连接。既然断开连接后就会释放连接占用的内存资源，那么我们可以定期断开长连接。&lt;/li&gt;
  &lt;li&gt;客户端主动重置连接。&lt;/li&gt;
  &lt;li&gt;连接池&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2查询缓存&quot;&gt;&lt;strong&gt;2、查询缓存&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;MySQL 8.0 版本之后没有查询缓存这一步了。&lt;/p&gt;

&lt;p&gt;连接器得工作完成后，客户端就可以向 MySQL 服务发送 SQL 语句了，MySQL 服务收到 SQL 语句后，就会解析出 SQL 语句的第一个字段，看看是什么类型的语句。&lt;/p&gt;

&lt;p&gt;如果 SQL 是查询语句（select 语句），MySQL 就会先去查询缓存（ Query Cache ）里查找缓存数据，看看之前有没有执行过这一条命令，这个查询缓存是以 key-value 形式保存在内存中的，key 为 SQL 查询语句，value 为 SQL 语句查询的结果。如果查询的语句命中查询缓存，那么就会直接返回 value 给客户端。如果查询的语句没有命中查询缓存中，那么就要往下继续执行，等执行完后，查询的结果就会被存入查询缓存中。&lt;/p&gt;

&lt;p&gt;真实情况是查询缓存挺鸡肋的。对于更新比较频繁的表，查询缓存的命中率很低的，因为只要一个表有更新操作，那么这个表的查询缓存就会被清空。如果刚缓存了一个查询结果很大的数据，还没被使用的时候，刚好这个表有更新操作，查询缓冲就被清空了，相当于缓存了个寂寞。&lt;/p&gt;

&lt;p&gt;所以，MySQL 8.0 版本直接将查询缓存删掉了，也就是说 MySQL 8.0 开始，执行一条 SQL 查询语句，不会再走到查询缓存这个阶段了。这里说的查询缓存是 server 层的，也就是 MySQL 8.0 版本移除的是 server 层的查询缓存，并不是 Innodb 存储引擎中的 buffer pool。&lt;/p&gt;

&lt;h4 id=&quot;3解析-sql&quot;&gt;&lt;strong&gt;3、解析 SQL&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;在正式执行 SQL 查询语句之前， MySQL 会先对 SQL 语句做解析，这个工作交由「解析器」来完成。&lt;/p&gt;

&lt;p&gt;解析器会做如下两件事情。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;词法分析。MySQL 会根据你输入的字符串识别出关键字出来&lt;/li&gt;
  &lt;li&gt;语法分析。根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法，如果没问题就会构建出 SQL 语法树，这样方便后面模块获取 SQL 类型、表名、字段名、 where 条件等等&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;4执行-sql&quot;&gt;&lt;strong&gt;4、执行 SQL&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;经过解析器后，接着就要进入执行 SQL 查询语句的流程了，每条SELECT 查询语句流程主要可以分为下面这三个阶段：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;prepare 阶段，也就是预处理阶段；&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;检查 SQL 查询语句中的表或者字段是否存在；&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;将 select * 中的 * 符号，扩展为表上的所有列；&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;optimize 阶段，也就是优化阶段：优化器主要负责将 SQL 查询语句的执行方案确定下来，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。&lt;/li&gt;
  &lt;li&gt;execute 阶段，也就是执行阶段：真正开始执行语句了，这个工作是由「执行器」完成的。在执行的过程中，执行器就会和存储引擎交互了，交互是以记录为单位的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;二innodb架构&quot;&gt;二、InnoDB架构&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/52.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;InnoDB整体也分为三层：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;内存结构&lt;/strong&gt;(In-Memory Structure)，这一层在MySQL服务进程内；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;OS Cache&lt;/strong&gt;，这一层属于内核态内存；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;磁盘结构&lt;/strong&gt;(On-Disk Structure)，这一层在文件系统上；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这三层的交互有两类：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;直接O_Direct落地数据（长途中，长箭头）：Buffer Pool的数据与磁盘数据；&lt;/li&gt;
  &lt;li&gt;通过OS Cache落地数据（上图中，两个短箭头）：Log Buffer；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;内存区域&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;InnoDB内存结构包含&lt;strong&gt;四大核心组件&lt;/strong&gt;，分别是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;缓冲池&lt;/strong&gt;(Buffer Pool):加速&lt;strong&gt;读&lt;/strong&gt;请求，避免每次数据访问都进行磁盘IO，起到Redis缓存的作用。涉及的技术点包括：预读，局部性原理，LRU，预读失败+缓冲池污染，新生代老生代双链LRU&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;更改缓冲区&lt;/strong&gt;(Change Buffer)：为了插入或者更新次要索引而存在，是Buffer Pool的一部分，当辅助索引页不在缓冲池中时，更改缓冲区负责缓存对这些页的更改。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;自适应哈希索引&lt;/strong&gt;(Adaptive Hash Index)：用于优化某些读取选项的性能。它旨在通过提供快速的内存查找机制来加速对频繁查询的索引页的访问，&lt;strong&gt;加速读请求&lt;/strong&gt;，减少索引查询的寻路路径。涉及的技术点包括：&lt;strong&gt;聚集索引，普通索引，哈希索引&lt;/strong&gt;；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;日志缓冲区&lt;/strong&gt;(Log Buffer)：保存要写入事务日志的更改的内存区域，日志缓冲区通过在定期将日志刷新到磁盘上的重做日志之前将日志写入内存来提高性能，并提供了高并发与强一致性的折衷方案。涉及的技术点包括：&lt;strong&gt;redo log作用，流程，三层架构，随机写优化为顺序写，次次写优化为批量写&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;文件区域:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;系统表空间(System tablespace)&lt;/strong&gt;：用作更改缓冲区的存储区域。InnoDB 使用一个或多个数据文件作为系统表空间。ibdata1默认情况下，MySQL在数据目录中创建该文件。启动选项innodb_data_file_path决定系统表空间数据文件的大小和数量。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;每表文件表空间(File-per-table tablespaces)&lt;/strong&gt;:存储 InnoDB 表的实际数据。当您使用 InnoDB 存储引擎创建新表时，InnoDB 将每个表及其关联索引存储在一个扩展名为 file-per-tablespace 的文件中.ibd。例如，如果您创建一个名为tbl_name的表，InnoDB 将在数据目录中tbl_name创建一个相应的 file-per-tablespace 数据文件。tbl_name.idb&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;通用表空间(General tablespaces)&lt;/strong&gt;：可以存储多个表的共享表空间。通用表空间都是使用该CREATE TABLESPACE语句创建的。当多个表共享相同的通用表空间时，通用表空间有助于减少内存中表空间元数据的重复。因此，与每表文件表空间相比，通用表空间具有潜在的内存优势。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Undo表空间(Undo tablespaces):&lt;/strong&gt;存储撤消日志，其中包含撤消事务的最新更改的信息。MySQL 有两个默认的撤消表空间文件innodb_undo_001 和innodb_undo_002.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;临时表空间(Temporary tablespaces):&lt;/strong&gt;当您创建临时表时，InnoDB 将它们存储在临时表空间中，更具体地说是会话临时表空间中。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;双写缓冲区(Doublewrite buffer)：&lt;/strong&gt;InnoDB 使用 Doublewrite Buffer 来存储在实际写入 InnoDB 数据文件之前已从缓冲池中刷新的页面。允许 InnoDB 检索可靠的页面副本，以便在发生存储问题时进行恢复。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;重做日志(Redo log)&lt;/strong&gt;：用于存储对表所做的更改。InnoDB在崩溃恢复期间使用重做日志来纠正不完整事务写入的数据。例如，当您执行更改数据库的 SQL 语句（例如INSERT、UPDATE和DELETE ）时，重做日志会将请求存储在重做日志文件中。如果发生崩溃，MySQL 会重播重做日志中在接受连接之前未完成的修改。InnoDB 使用一组重做日志文件（ib_logfile0、iblogfile1、 …）来存储对表数据的更改。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;撤消日志(Undo logs)&lt;/strong&gt;：存储回滚操作所需的信息。例如，如果您执行一个事务并决定回滚它，InnoDB将利用撤消日志来撤销该事务期间所做的更改。InnoDB 使用一组撤消日志文件（通常命名为undo_001.ibd、udo_002.ibd等）来存储日志。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Ted</name></author><category term="数据库" /><summary type="html">一、MySQL架构</summary></entry><entry><title type="html">外接纹理显示图片1：问题篇</title><link href="http://www.helloted.com/flutter/2022/06/09/texture_1/" rel="alternate" type="text/html" title="外接纹理显示图片1：问题篇" /><published>2022-06-09T20:00:00+08:00</published><updated>2022-06-09T20:00:00+08:00</updated><id>http://www.helloted.com/flutter/2022/06/09/texture_1</id><content type="html" xml:base="http://www.helloted.com/flutter/2022/06/09/texture_1/">&lt;h3 id=&quot;1flutter列表中多图加载的问题&quot;&gt;1、Flutter列表中多图加载的问题&lt;/h3&gt;

&lt;p&gt;在社交或者资讯类App中，经常会使用到Feeds流页面，Feeds流页面的列表一般结构繁杂，单行资讯内就可能有多张图片；&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
&lt;img src=&quot;/img/Simple_6/28.png&quot; alt=&quot;Image&quot; align=&quot;middle&quot; style=&quot;zoom:30%;&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;Flutter 通过 Image.asset，Image.file，Image.network 等方法创建一个 Image Widget 来加载显示本地或者网络图片。&lt;/p&gt;

&lt;p&gt;而使用Image控件加载多图，会出现一些问题&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;内存过载&lt;/strong&gt;：列表中图片过多时，内存占用很轻松的飙升到了七八百MB，如果手机的配置不够，很可能就会导致页面空白甚至是Crash；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;内存峰值高&lt;/strong&gt;：图片加载的过程中，加载前期阶段会内存峰值很高；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;没有磁盘缓存&lt;/strong&gt;：Flutter原生的图片缓存机制，缓存到的是内存中，没有磁盘缓存，每次重新打开APP或者缓存被清理都会再次进行网络请求。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_6/29.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2flutter图片加载过程&quot;&gt;2、Flutter图片加载过程&lt;/h3&gt;

&lt;p&gt;Flutter中图片主要有4个类：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Image&lt;/strong&gt; &lt;strong&gt;：&lt;/strong&gt;显示图⽚的Widget，通过ImageState管理ImageProvider的⽣命周期；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ImageProvider&lt;/strong&gt;：图⽚的抽象概念（如NetworkImage、FileImage等），约定图⽚唯⼀性(key)、获取图⽚字节数据(load)，创建ImageStream⽤于监听结果；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ImageStream&lt;/strong&gt;：图⽚的加载对象，通过 ImageStreamCompleter 最后会返回⼀个 ImageInfo,⽽ImageInfo 中的ui.Image是RenderObject的⽬标绘制对象；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ImageCache&lt;/strong&gt;：缓存单例PaintingBinding.instance.imageCache，只用于内存缓存；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;加载流程：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Image 通过 ImageProvider 得到 ImageStream 对象&lt;/li&gt;
  &lt;li&gt;_ImageState 利用 ImageStream 添加监听，等待图片数据&lt;/li&gt;
  &lt;li&gt;.ImageProvider 通过 load 方法去加载并返回 ImageStreamCompleter 对象&lt;/li&gt;
  &lt;li&gt;ImageStream 会关联 ImageStreamCompleter&lt;/li&gt;
  &lt;li&gt;ImageStreamCompleter 会通过 http 下载图片，再经过 PaintingBinding 编码转化后，得到 ui.Codec 可绘制对象，并封装成 ImageInfo 返回&lt;/li&gt;
  &lt;li&gt;ImageInfo 回调到 ImageStream 的监听，设置给 _ImageState build 的 RawImage 对象。&lt;/li&gt;
  &lt;li&gt;RawImage 的 RenderImage 通过 paint 绘制 ImageInfo 中的 ui.Codec&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_6/30.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3内存大的原因&quot;&gt;3、内存大的原因&lt;/h3&gt;

&lt;p&gt;图片要显示在移动终端一般会经历加载、解码和渲染三个步骤，其中解码阶段是内存消耗最多的过程，解码是一个计算量较大的任务，主要需要CPU来执行；并且解码出来的图片所占内存与图片的宽高正相关，而与图片原来的大小无关。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_6/31.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们以Image Widget为例，Image Widget 要显示在屏幕上的时候，需要以Image作为数据源，Image持有的数据DataBuffer是未解码的压缩数据，能节省较多的内存和加快存储。&lt;/p&gt;

&lt;p&gt;当DataBuffer数据被赋值给Image Widget时，图像数据会被解码为Image Buffer，变成代表RGB的颜色数据。&lt;/p&gt;

&lt;p&gt;解压图片需要的内存算法为：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;图⽚所占内存⼤⼩ = 图⽚⻓度（像素）* 图⽚宽度（像素）* ⼀个像素所占内存空间4字节(RGBA)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当我们业务场景中需要加载一张游戏图片（3000*4000像素大小），解码内存大小占用为 45.77MB。&lt;/p&gt;

&lt;h3 id=&quot;4优化措施&quot;&gt;4、优化措施&lt;/h3&gt;

&lt;p&gt;根据以上的内存原因，我们可以总结一些在Flutter原生上的优化措施&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;优化下载项&lt;/strong&gt;：利用云端压缩缩略图功能，在云端压缩切割图片&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;降低采样率：&lt;/strong&gt;设置合适的采样大小，减小解码内存大小。追踪源码，我们发现，cacheWidth和cacheHeight能够影响到ImageDescriptor，可以降低内存&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;磁盘缓存&lt;/strong&gt;：通过Chanel桥接，将下载好的图片进行磁盘缓存，Flutter侧进行图片加载的时候，如果内存没有命中，就去磁盘缓存中进行二次搜索。如果都没有命中才会走网络请求。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_6/32.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;优化措施后有以下效果&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;减小图片下载量，加快加载速度&lt;/li&gt;
  &lt;li&gt;内存平均水平显著降低&lt;/li&gt;
  &lt;li&gt;磁盘缓存，网络图片无需重复下载&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;5依然存在的问题&quot;&gt;5、依然存在的问题&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;峰值内存高依然存在&lt;/strong&gt;：原因：先直接decode 原始的image，此时消耗的内存就与图片原始尺寸成正比, 而后再做rasterize时这个时候的内存消耗大小才与设置大小成正比，设置cacheWidth和cacheHeight没有解决峰值问题。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;cacheWidth&lt;/strong&gt;和&lt;strong&gt;cacheHeight&lt;/strong&gt;设置问题，与原图宽高⽐例不⼀致易出现图⽚模糊、变形(可以等图片下载之后再去设置，这需要hook，去改动framework）；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;图片解码无法复用：&lt;/strong&gt;dispose之后Flutter 会立刻回收解码后的内存，即 Flutter 仅对图片的原始压缩数据进行存储，并不缓存 pixel buffer，用空间换时间；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;磁盘缓存的效率问题：&lt;/strong&gt;由于我们的磁盘缓存文件是通过Channel来通信，而Flutter定义的channel机制，从本质上说是提供了一个消息传送机制，用于图像等数据的传输必然引起内存和CPU的巨大消耗。无论是用ffi还是普通channel传输，都会导致FPS下降；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在Flutter 端做的优化目前看来并没有能支撑我们解决图片引起的OOM问题，对于内存峰值和内存及时释放，Flutter 端都无法给出完美的方案。&lt;/p&gt;</content><author><name>Ted</name></author><category term="Flutter" /><summary type="html">1、Flutter列表中多图加载的问题</summary></entry><entry><title type="html">Objective-C代码规范检测</title><link href="http://www.helloted.com/ios/2021/07/15/ocCheck/" rel="alternate" type="text/html" title="Objective-C代码规范检测" /><published>2021-07-15T20:00:00+08:00</published><updated>2021-07-15T20:00:00+08:00</updated><id>http://www.helloted.com/ios/2021/07/15/ocCheck</id><content type="html" xml:base="http://www.helloted.com/ios/2021/07/15/ocCheck/">&lt;h4 id=&quot;1抽象语法树ast&quot;&gt;1、抽象语法树AST&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/30.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在编译过程中，第三步&lt;strong&gt;语义分析(Semantic Analysis)&lt;/strong&gt;：验证语法是否正确，然后将所有节点组成抽象语法树 AST 。&lt;/p&gt;

&lt;p&gt;抽象语法树（abstract syntax code，AST）是源代码的抽象语法结构的树状表示，树上的每个节点都表示源代码中的一种结构，之所以说是抽象的，是因为抽象语法树并不会表示出真实语法出现的每一个细节，比如说，嵌套括号被隐含在树的结构中，并没有以节点的形式呈现。抽象语法树并不依赖于源语言的语法，也就是说语法分析阶段所采用的上下文无关文法，因为在写文法时，经常会对文法进行等价的转换（消除左递归，回溯，二义性等），这样会给文法分析引入一些多余的成分，对后续阶段造成不利影响，甚至会使合个阶段变得混乱。因些，很多编译器经常要独立地构造语法分析树，为前端，后端建立一个清晰的接口。基于AST的不依赖具体文法和不依赖语言细节的特点，使得其在很多领域有广泛的应用，比如浏览器，智能编辑器，编译器。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;while &lt;/span&gt;b &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; 0
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;a &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; b
         a &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; a-b
     &lt;span class=&quot;k&quot;&gt;else
         &lt;/span&gt;b &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; b-a
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;return &lt;/span&gt;a
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的一个while循环，经过Clang分析所产生的AST如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/39.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过上面的语法树可以看到其描述代码的具体结构，而在Clang对代码编译时会进入一个语法树的解析阶段，则这个阶段中语法树的每个节点都会被遍历到，因此借助此阶段可以检测程序中所有代码的书写格式是否符合规范，甚至是对代码编写的质量作出分析。&lt;/p&gt;

&lt;h4 id=&quot;2oc语言的语法树&quot;&gt;2、OC语言的语法树&lt;/h4&gt;

&lt;p&gt;创建一个简单的类HelloAST&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@interface HelloAST : NSObject

@end

@implementation HelloAST

- (void)hello{
    [self print:@&quot;hello!&quot;];
}

- (void)print:(NSString *)msg{
    NSLog(@&quot;%@&quot;,msg);
}

@end                                                  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以通过以下命令查看它的语法树结构&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;clang -fmodules -fsyntax-only -Xclang -ast-dump HelloAST.m
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/40.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们可以看到自己的类定义、方法定义、方法调用在 AST 中所对应的节点。&lt;/p&gt;

&lt;p&gt;其中第一个框为类定义，可以看到该节点名称为 &lt;a href=&quot;https://link.juejin.cn?target=https%3A%2F%2Fclang.llvm.org%2Fdoxygen%2Fclassclang_1_1ObjCInterfaceDecl.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ObjCInterfaceDecl&lt;/code&gt;&lt;/a&gt;，该类型节点为 objc 类定义（声明）。
第二个框名称为 &lt;a href=&quot;https://link.juejin.cn?target=https%3A%2F%2Fclang.llvm.org%2Fdoxygen%2Fclassclang_1_1ObjCMethodDecl.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ObjCMethodDecl&lt;/code&gt;&lt;/a&gt;，说明该节点定义了一个    objc 方法（包含类、实例方法，包含普通方法和协议方法）。
第三个框名称为 &lt;a href=&quot;https://link.juejin.cn?target=https%3A%2F%2Fclang.llvm.org%2Fdoxygen%2Fclassclang_1_1ObjCMessageExpr.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ObjCMessageExpr&lt;/code&gt;&lt;/a&gt;，说明该节点是一个标准的 objc 消息发送表达式（[obj foo]）。&lt;/p&gt;

&lt;p&gt;在&lt;a href=&quot;https://clang.llvm.org/doxygen/namespaceclang.html&quot;&gt;clang-namespaceclang&lt;/a&gt;官网可以查询到这些&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;节点&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ObjcCategoryDecl&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;分类声明节点&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ObjcCategoryImplDecl&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;分类实现节点&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ObjcImplementationDecl&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;类实现节点&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ObjcInterfaceDecl&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;类声明节点&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ObjcIvarDecl&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;实例变量声明节点&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ObjcMethodDecl&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;实例方法声明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ObjcPropertyDecl&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;属性声明节点&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ObjcProtocolDecl&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;协议声明节点&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ParmVarDecl&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;参数节点&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;…&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;…&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;3添加访问节点的插件&quot;&gt;3、添加访问节点的插件&lt;/h4&gt;

&lt;p&gt;要实现自定义的clang插件(以C++ API为例)，应按照以下步骤:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;自定义继承自
&lt;code class=&quot;highlighter-rouge&quot;&gt;clang::PluginASTAction&lt;/code&gt;(基于consumer的抽象语法树(Abstract Syntax Tree/AST)前端Action抽象基类)
&lt;code class=&quot;highlighter-rouge&quot;&gt;clang::ASTConsumer&lt;/code&gt;(用于客户读取抽象语法树的抽象基类)，
&lt;code class=&quot;highlighter-rouge&quot;&gt;clang::RecursiveASTVisitor&lt;/code&gt;(前序或后续地深度优先搜索整个抽象语法树，并访问每一个节点的基类)等基类。&lt;/li&gt;
  &lt;li&gt;根据自身需要重载
&lt;code class=&quot;highlighter-rouge&quot;&gt;PluginASTAction::CreateASTConsumer&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;PluginASTAction::ParseArgs&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;ASTConsumer::HandleTranslationUnit&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;RecursiveASTVisitor::VisitDecl&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;RecursiveASTVisitor::VisitStmt&lt;/code&gt;
等方法，实现自定义的分析逻辑。&lt;/li&gt;
  &lt;li&gt;注册插件
&lt;code class=&quot;highlighter-rouge&quot;&gt;static FrontendPluginRegistry::Add&amp;lt;MyPlugin&amp;gt; X(&quot;my-plugin- name&quot;, &quot;my-plugin-description&quot;);&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;添加一个简单的测试插件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &quot;clang/Frontend/FrontendPluginRegistry.h&quot;
#include &quot;clang/AST/AST.h&quot;
#include &quot;clang/AST/ASTConsumer.h&quot;
#include &quot;clang/Frontend/CompilerInstance.h&quot;

using namespace clang;

namespace
{
    class MyPluginConsumer : public ASTConsumer
    {
    CompilerInstance &amp;amp;Instance;
    std::set&amp;lt;std::string&amp;gt; ParsedTemplates;
    public:
        MyPluginConsumer(CompilerInstance &amp;amp;Instance,
                               std::set&amp;lt;std::string&amp;gt; ParsedTemplates)
        : Instance(Instance), ParsedTemplates(ParsedTemplates) {}
    };
    
    class MyPluginASTAction : public PluginASTAction
    {
    std::set&amp;lt;std::string&amp;gt; ParsedTemplates;
    protected:
        std::unique_ptr&amp;lt;ASTConsumer&amp;gt; CreateASTConsumer(CompilerInstance &amp;amp;CI,
                                                       llvm::StringRef) override
        {
            return llvm::make_unique&amp;lt;MyPluginConsumer&amp;gt;(CI, ParsedTemplates);
        }
        
        bool ParseArgs(const CompilerInstance &amp;amp;CI,
                       const std::vector&amp;lt;std::string&amp;gt; &amp;amp;args) override {
            
            DiagnosticsEngine &amp;amp;D = ci.getDiagnostics();
            D.Report(D.getCustomDiagID(DiagnosticsEngine::Error,
                                       &quot;OCCheck Test AST Error&quot;));
            return true;
        }
    };
}

static clang::FrontendPluginRegistry::Add&amp;lt;MyPluginASTAction&amp;gt;
X(&quot;VisitAST&quot;, &quot;My plugin&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;clang::PluginASTAction&lt;/code&gt;是一个基于consumer的AST前端Action抽象基类。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;clang::ASTConsumer&lt;/code&gt;则是用于客户读取AST的抽象基类。它们之间的关系是&lt;code class=&quot;highlighter-rouge&quot;&gt;clang::PluginASTAction&lt;/code&gt;作为一个关于AST的插件，同时也是访问&lt;code class=&quot;highlighter-rouge&quot;&gt;clang::ASTConsumer&lt;/code&gt;的入口；而&lt;code class=&quot;highlighter-rouge&quot;&gt;clang::ASTConsumer&lt;/code&gt;则是用于定义如何取得AST相关内容。&lt;/p&gt;

&lt;p&gt;定义继承于&lt;code class=&quot;highlighter-rouge&quot;&gt;clang::PluginASTAction&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;clang::ASTConsumer&lt;/code&gt;类的子类后，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;static clang::FrontendPluginRegistry::Add&amp;lt;MyPluginASTAction&amp;gt; X(&quot;VisitAST&quot;, &quot;My plugin”);&lt;/code&gt;就可以把插件注册到Clang中。&lt;/p&gt;

&lt;p&gt;Build之后能够得到VisitAST插件，可以添加到我们的项目配置中。配置方式参考前面文章Pass配置&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/42.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个Plugin的作用是在编译过程中报一个Error。由此可见，我们可以在编译过程中插入一些我们的逻辑。&lt;/p&gt;

&lt;h4 id=&quot;4实现编译时语法检测&quot;&gt;4、实现编译时语法检测&lt;/h4&gt;

&lt;p&gt;添加一个入口&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;c1&quot;&gt;// 入口&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CodeCheckASTAction&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PluginASTAction&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ParsedTemplates&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;unique_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ASTConsumer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CreateASTConsumer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CompilerInstance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StringRef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unique_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CodeCheckASTConsumer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CodeCheckASTConsumer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//使用自定义的处理工具&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        
        &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ParseArgs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CompilerInstance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//            DiagnosticsEngine &amp;amp;D = ci.getDiagnostics();&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//            D.Report(D.getCustomDiagID(DiagnosticsEngine::Error,&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//                                       &quot;OCCheck Test AST Error&quot;));&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;添加自定义工具&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;c1&quot;&gt;//自定义的处理工具&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CodeCheckASTConsumer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ASTConsumer&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;MatchFinder&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;matcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;CodeCheckHandler&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//调用CreateASTConsumer方法后就会加载Consumer里面的方法&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;CodeCheckASTConsumer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CompilerInstance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;matcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addMatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objcInterfaceDecl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ObjCInterfaceDecl&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;matcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addMatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objcMethodDecl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ObjCMethodDecl&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;matcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addMatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objcPropertyDecl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ObjcPropertyDecl&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        
        &lt;span class=&quot;c1&quot;&gt;//遍历完一次语法树就会调用一次下面方法&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HandleTranslationUnit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ASTContext&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;matcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;matchAST&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在MatchFinder的run方法中，可以找到对应的节点进行处理&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 自定义 handler
class CodeCheckHandler : public MatchFinder::MatchCallback {
private:
    CompilerInstance &amp;amp;ci;//编译器实例
public:
    CodeCheckHandler(CompilerInstance &amp;amp;ci) :ci(ci) {}
            //主要方法，分配 类、方法、属性 做不同处理
    void run(const MatchFinder::MatchResult &amp;amp;Result) {
    // 类
				const ObjCInterfaceDecl *interfaceDecl = Result.Nodes.getNodeAs&amp;lt;ObjCInterfaceDecl&amp;gt;(&quot;ObjCInterfaceDecl&quot;);
        // 属性
				const ObjCPropertyDecl *propertyDecl = Result.Nodes.getNodeAs&amp;lt;ObjCPropertyDecl&amp;gt;(&quot;ObjcPropertyDecl&quot;);
        // 方法
				const ObjCMethodDecl *methodDecl = Result.Nodes.getNodeAs&amp;lt;ObjCMethodDecl&amp;gt;(&quot;ObjCMethodDecl&quot;);
      // 变量
       const VarDecl var = Result.Nodes.getNodeAs&amp;lt;VarDecl&amp;gt;(&quot;var&quot;)
    }
} 举例，检测类名是否是小写
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
  检测类名是否存在小写开头

  @param decl 类声明
 */&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;checkClassNameForLowercaseName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ObjCInterfaceDecl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;decl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;StringRef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;className&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;decl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        
      &lt;span class=&quot;c1&quot;&gt;//类名称必须以大写字母开头&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;className&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isLowercase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
           &lt;span class=&quot;c1&quot;&gt;//修正提示&lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tempName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;className&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;tempName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;toUppercase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;StringRef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;replacement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tempName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;SourceLocation&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nameStart&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;decl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getLocation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;SourceLocation&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nameEnd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nameStart&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getLocWithOffset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;className&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;FixItHint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fixItHint&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FixItHint&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CreateReplacement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SourceRange&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nameStart&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nameEnd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;replacement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                
           &lt;span class=&quot;c1&quot;&gt;//报告警告&lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;DiagnosticsEngine&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;D&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Instance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getDiagnostics&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
           &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;diagID&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getCustomDiagID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DiagnosticsEngine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Class name should not start with lowercase letter&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;SourceLocation&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;location&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;decl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getLocation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Report&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;diagID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AddFixItHint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fixItHint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
       &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;完整代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
#include &amp;lt;iostream&amp;gt;
#include &quot;clang/AST/AST.h&quot;
#include &quot;clang/AST/ASTConsumer.h&quot;
#include &quot;clang/ASTMatchers/ASTMatchers.h&quot;
#include &quot;clang/ASTMatchers/ASTMatchFinder.h&quot;
#include &quot;clang/Frontend/CompilerInstance.h&quot;
#include &quot;clang/Frontend/FrontendPluginRegistry.h&quot;

#include &quot;llvm/Support/raw_ostream.h&quot;
#include &quot;clang/Sema/Sema.h&quot;
#include &quot;clang/AST/RecursiveASTVisitor.h&quot;

#include &quot;clang/Basic/Diagnostic.h&quot;

#include &quot;clang/AST/DeclObjC.h&quot;

using namespace clang;
using namespace std;
using namespace llvm;
using namespace clang::ast_matchers;


namespace CodeCheck {
    
    // MARK: - my handler
    class CodeCheckHandler : public MatchFinder::MatchCallback {
    private:
        CompilerInstance &amp;amp;ci;
        
    public:
        CodeCheckHandler(CompilerInstance &amp;amp;ci) :ci(ci) {}
        
        void checkInterfaceDecl(const ObjCInterfaceDecl *decl){
            StringRef className = decl-&amp;gt;getName();
            //类名称必须以大写字母开头
            char c = className[0];
            if (isLowercase(c))
            {
                 //修正提示
                 std::string tempName = className;
                 tempName[0] = toUppercase(c);
                 StringRef replacement(tempName);
                 SourceLocation nameStart = decl-&amp;gt;getLocation();
                 SourceLocation nameEnd = nameStart.getLocWithOffset(className.size() - 1);
                 FixItHint fixItHint = FixItHint::CreateReplacement(SourceRange(nameStart, nameEnd), replacement);

                 //报告警告
                 DiagnosticsEngine &amp;amp;D = ci.getDiagnostics();
                 int diagID = D.getCustomDiagID(DiagnosticsEngine::Error, &quot;编码提示: 类名必须以大写字母开头&quot;);
                 SourceLocation location = decl-&amp;gt;getLocation();
                 D.Report(location, diagID).AddFixItHint(fixItHint);
             }
        }
        
        void checkPropertyDecl(const clang::ObjCPropertyDecl *decl)
        {
            checkOtherPropertyDecl(decl);
            StringRef name = decl -&amp;gt; getName();
              if (name.size() == 1)
              {
                   //不需要检测
                   return;
              }

              //属性中不包含下划线
              size_t underscorePos = name.find('_', 1);
              if (underscorePos != StringRef::npos)
              {
                   //修正提示
                   std::string tempName = name;
                   std::string::iterator end_pos = std::remove(tempName.begin() + 1, tempName.end(), '_');
                   tempName.erase(end_pos, tempName.end());
                   StringRef replacement(tempName);
                   SourceLocation nameStart = decl-&amp;gt;getLocation();
                   SourceLocation nameEnd = nameStart.getLocWithOffset(name.size() - 1);
                   FixItHint fixItHint = FixItHint::CreateReplacement(SourceRange(nameStart, nameEnd), replacement);

                   //报告错误
                   DiagnosticsEngine &amp;amp;diagEngine = ci.getDiagnostics();
                   unsigned diagID = diagEngine.getCustomDiagID(DiagnosticsEngine::Warning, &quot;编码提示: 属性名称中不要包含`_`&quot;);
                   SourceLocation location = decl-&amp;gt;getLocation().getLocWithOffset(underscorePos);
                   diagEngine.Report(location, diagID).AddFixItHint(fixItHint);
              }
        }
        
        void checkOtherPropertyDecl(const clang::ObjCPropertyDecl *propertyDecl)
        {
            ObjCPropertyDecl::PropertyAttributeKind attrKind = propertyDecl-&amp;gt;getPropertyAttributes();
            SourceLocation location = propertyDecl-&amp;gt;getLocation();
            string typeStr = propertyDecl-&amp;gt;getType().getAsString();
            
            if (propertyDecl-&amp;gt;getTypeSourceInfo()) {
                if(!(attrKind &amp;amp; ObjCPropertyDecl::OBJC_PR_nonatomic)){
                    diagWaringReport(location, &quot;Are you sure to use atomic which might reduce the performance.&quot;, NULL);
                }
                
                if ((typeStr.find(&quot;NSString&quot;)!=string::npos)&amp;amp;&amp;amp; !(attrKind &amp;amp; ObjCPropertyDecl::OBJC_PR_copy)) {
                    diagWaringReport(location, &quot;NSString建议使用copy代替strong.&quot;, NULL);
                } else if ((typeStr.find(&quot;NSArray&quot;)!=string::npos)&amp;amp;&amp;amp; !(attrKind &amp;amp; ObjCPropertyDecl::OBJC_PR_copy)) {
                    diagWaringReport(location, &quot;NSArray建议使用copy代替strong.&quot;, NULL);
                }
                
                if(!typeStr.compare(&quot;int&quot;)){
                    diagWaringReport(location, &quot;Use the built-in NSInteger instead of int.&quot;, NULL);
                } else if ((typeStr.find(&quot;&amp;lt;&quot;)!=string::npos &amp;amp;&amp;amp; typeStr.find(&quot;&amp;gt;&quot;)!=string::npos) &amp;amp;&amp;amp; !(attrKind &amp;amp; ObjCPropertyDecl::OBJC_PR_weak)) {
                    diagWaringReport(location, &quot;建议使用weak定义Delegate.&quot;, NULL);
                }
            }
        }
        

        // 检测属性名是否存在大写开头
        void checkPropertyNameForUppercaseName(const clang::ObjCPropertyDecl *decl)
        {
              bool checkUppercaseNameIndex = 0;
              StringRef name = decl -&amp;gt; getName();
              if (name.find('_') == 0)
              {
                   //表示以下划线开头
                   checkUppercaseNameIndex = 1;
              }

              //名称必须以小写字母开头
              char c = name[checkUppercaseNameIndex];
              if (isUppercase(c))
              {
                   //修正提示
                   std::string tempName = name;
                   tempName[checkUppercaseNameIndex] = toLowercase(c);
                   StringRef replacement(tempName);
                   SourceLocation nameStart = decl-&amp;gt;getLocation();
                   SourceLocation nameEnd = nameStart.getLocWithOffset(name.size() - 1);
                   FixItHint fixItHint = FixItHint::CreateReplacement(SourceRange(nameStart, nameEnd), replacement);

                   //报告错误
                   DiagnosticsEngine &amp;amp;D = ci.getDiagnostics();
                   int diagID = D.getCustomDiagID(DiagnosticsEngine::Error, &quot;Property name should not start with uppercase letter&quot;);
                   SourceLocation location = decl-&amp;gt;getLocation();
                   D.Report(location, diagID).AddFixItHint(fixItHint);
               }
        }
        
        
        template &amp;lt;unsigned N&amp;gt;
        void diagWaringReport(SourceLocation Loc, const char (&amp;amp;FormatString)[N], FixItHint *Hint)
        {
            DiagnosticsEngine &amp;amp;diagEngine = ci.getDiagnostics();
            unsigned DiagID = diagEngine.getCustomDiagID(clang::DiagnosticsEngine::Warning, FormatString);
            (Hint!=NULL) ? diagEngine.Report(Loc, DiagID) &amp;lt;&amp;lt; *Hint : diagEngine.Report(Loc, DiagID);
        }
        
        void run(const MatchFinder::MatchResult &amp;amp;Result) {
            
            if (const ObjCInterfaceDecl *interfaceDecl = Result.Nodes.getNodeAs&amp;lt;ObjCInterfaceDecl&amp;gt;(&quot;ObjCInterfaceDecl&quot;)) {
                //类的检测
                checkInterfaceDecl(interfaceDecl);
            }
            
            if (const ObjCPropertyDecl *propertyDecl = Result.Nodes.getNodeAs&amp;lt;ObjCPropertyDecl&amp;gt;(&quot;objcPropertyDecl&quot;)) {
                //属性的检测
                checkPropertyDecl(propertyDecl);
            }

        }
        
    };
    
    class CodeCheckASTConsumer: public ASTConsumer {
    private:
        MatchFinder matcher;
        CodeCheckHandler handler;
    public:
        //调用CreateASTConsumer方法后就会加载Consumer里面的方法
        CodeCheckASTConsumer(CompilerInstance &amp;amp;ci) :handler(ci) {
            matcher.addMatcher(objcInterfaceDecl().bind(&quot;ObjCInterfaceDecl&quot;), &amp;amp;handler); // 类
            matcher.addMatcher(objcMethodDecl().bind(&quot;ObjCMethodDecl&quot;), &amp;amp;handler); // 方法
            matcher.addMatcher(objcPropertyDecl().bind(&quot;objcPropertyDecl&quot;), &amp;amp;handler); // 属性
        }
        
        //遍历完一次语法树就会调用一次下面方法
        void HandleTranslationUnit(ASTContext &amp;amp;context) {
            matcher.matchAST(context);
        }
    };
    
    class CodeCheckASTAction: public PluginASTAction {
    public:
        unique_ptr&amp;lt;ASTConsumer&amp;gt; CreateASTConsumer(CompilerInstance &amp;amp;ci, StringRef iFile) {
            return unique_ptr&amp;lt;CodeCheckASTConsumer&amp;gt; (new CodeCheckASTConsumer(ci));
        }
        
        bool ParseArgs(const CompilerInstance &amp;amp;ci, const std::vector&amp;lt;std::string&amp;gt; &amp;amp;args) {
            return true;
        }
    };
}



static FrontendPluginRegistry::Add&amp;lt;CodeCheck::CodeCheckASTAction&amp;gt;
X(&quot;CodeCheck&quot;, &quot;The CodeCheck is my first clang-plugin.&quot;);

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;FixItHint fixItHint = FixItHint::CreateReplacement(SourceRange(nameStart, nameEnd), replacement);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;FixItHint可用于修复改动，将想要的格式替换原有的格式&lt;/p&gt;

&lt;p&gt;Waring效果&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        template &amp;lt;unsigned N&amp;gt;
        /// 抛出警告
        /// @param Loc 位置
        /// @param Hint 修改提示
        void diagWaringReport(SourceLocation Loc, const char (&amp;amp;FormatString)[N], FixItHint *Hint)
        {
            DiagnosticsEngine &amp;amp;diagEngine = ci.getDiagnostics();
            unsigned DiagID = diagEngine.getCustomDiagID(clang::DiagnosticsEngine::Warning, FormatString);
            (Hint!=NULL) ? diagEngine.Report(Loc, DiagID) &amp;lt;&amp;lt; *Hint : diagEngine.Report(Loc, DiagID);
        }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/46.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Error效果&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        template &amp;lt;unsigned N&amp;gt;
        void diagERRorReport(SourceLocation Loc, const char (&amp;amp;FormatString)[N], FixItHint *Hint)
        {
            DiagnosticsEngine &amp;amp;diagEngine = ci.getDiagnostics();
            unsigned DiagID = diagEngine.getCustomDiagID(clang::DiagnosticsEngine::Error, FormatString);
            (Hint!=NULL) ? diagEngine.Report(Loc, DiagID) &amp;lt;&amp;lt; *Hint : diagEngine.Report(Loc, DiagID);
        }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/47.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;配置过程&quot;&gt;配置过程&lt;/h5&gt;

&lt;p&gt;1、源码添加位置是在&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/41.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2、CodeCheck文件夹平级的CMakeList.txt要添加&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;add_clang_subdirectory(CodeCheck)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/43.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;3、CodeCheck文件夹内CMakeList.txt要添加&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;add_llvm_library(CodeCheck MODULE
CodeCheck.cpp
)

if(LLVM_ENABLE_PLUGINS AND (WIN32 OR CYGWIN))
  target_link_libraries(CodeCheck PRIVATE
    clangAST
    clangBasic
    clangFrontend
    clangLex
    LLVMSupport
    )
endif()

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/44.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;4、检测项目的Other C Flags添加配置&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-Xclang -load -Xclang （你的插件dylib绝对路径）-Xclang -add-plugin -Xclang  （你的Plugin名字）
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;-Xclang -load -Xclang $(SRCROOT)/CodeCheck.dylib  -Xclang -add-plugin -Xclang  CodeCheck&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/45.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我的博客即将同步至腾讯云+社区，邀请大家一同入驻：https://cloud.tencent.com/developer/support-plan?invite_code=2qy5h9u54eg4g&lt;/p&gt;</content><author><name>Ted</name></author><category term="iOS" /><summary type="html">1、抽象语法树AST</summary></entry><entry><title type="html">减包-删除无用的代码</title><link href="http://www.helloted.com/ios/2021/07/13/unusedMethod/" rel="alternate" type="text/html" title="减包-删除无用的代码" /><published>2021-07-13T20:00:00+08:00</published><updated>2021-07-13T20:00:00+08:00</updated><id>http://www.helloted.com/ios/2021/07/13/unusedMethod</id><content type="html" xml:base="http://www.helloted.com/ios/2021/07/13/unusedMethod/">&lt;h3 id=&quot;一减包的措施&quot;&gt;一、减包的措施&lt;/h3&gt;

&lt;h4 id=&quot;1资源&quot;&gt;1、资源:&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;无用资源的删除&lt;/li&gt;
  &lt;li&gt;重复文件的删除&lt;/li&gt;
  &lt;li&gt;大文件压缩&lt;/li&gt;
  &lt;li&gt;图片管理方式规范&lt;/li&gt;
  &lt;li&gt;on-Demand Resource动态下载&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;1.1. 删除无用图片&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用开源工具 &lt;a href=&quot;https://github.com/tinymind/LSUnusedResources&quot;&gt;&lt;strong&gt;LSUnusedResources&lt;/strong&gt;&lt;/a&gt; 检查重复图片，但是可能会有误报，比如 [@”image%d”, index] 这种引用方式无法检查到，需要人工在核对一边。&lt;/p&gt;

&lt;p&gt;1.1.1重复文件删除&lt;/p&gt;

&lt;p&gt;借助 &lt;a href=&quot;https://link.segmentfault.com/?url=https%3A%2F%2Fgithub.com%2Fadrianlopezroche%2Ffdupes&quot;&gt;fdupes&lt;/a&gt; 这个开源工具，校验各资源的 MD5。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.2. 图片文件压缩&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用开源工具 &lt;a href=&quot;https://github.com/ImageOptim/ImageOptim&quot;&gt;&lt;strong&gt;imageOptim&lt;/strong&gt;&lt;/a&gt; 对所有图片压缩一遍。此工具会使用 git 上主流的图片压缩方法尝试一遍，选择最优方案。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.3. 纯色图片使用代码生成&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果项目中纯色的图片比较多，可以考虑使用代码替代，生成后缓存到本地以供后期使用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.4. 不常用图片后台下发&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对于项目中不常用的图片可以考虑由后台下发，但是此项收益可能不高，而且会影响使用体验，酌情使用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.5. 字体文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;字体文件一般都很大，如果项目中使用了多种字体文件，可以删掉不常用的字体文件。&lt;/p&gt;

&lt;h4 id=&quot;2编译选项处理&quot;&gt;2、编译选项处理&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Generate Debug Symbols 设置为NO，设置成NO就不会在断点处停下。减少符号生成，这个待确认。&lt;/li&gt;
  &lt;li&gt;舍弃架构armv7和armv7s，去除不必要的指令集&lt;/li&gt;
  &lt;li&gt;DEAD_CODE_STRIPPING = YES（好像默认就是YES）。 确定 dead code（代码被定义但从未被调用）被剥离，去掉冗余的代码&lt;/li&gt;
  &lt;li&gt;Optimization Level有几个编译优化选项，release版应该选择Fastest, Smalllest[-Os]，这个选项会开启那些不增加代码大小的全部优化，并让可执行文件尽可能小。&lt;/li&gt;
  &lt;li&gt;Strip Debug Symbols During Copy 和 Symbols Hidden by Default 在release版本应该设为yes，可以去除不必要的调试符号。Symbols Hidden by Default会把所有符号都定义成”private extern”，设了后会减小体积。&lt;/li&gt;
  &lt;li&gt;Strip Linked Product：DEBUG下设为NO，RELEASE下设为YES，用于RELEASE模式下缩减app的大小；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;二mach-o简介&quot;&gt;二、Mach-o简介&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Mach-O&lt;/strong&gt; 为 Mach Object 文件格式的缩写，它是一种用于可执行文件、目标代码、动态库、内核转储的文件格式。作为 a.out 格式的替代，Mach-O 提供了更强的扩展性，并提升了 符号表 中信息的访问速度。&lt;/p&gt;

&lt;p&gt;MachO 是一种文件规范，是一类文件的统称，包括但不限于以下几种常见的文件类型：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;.o（目标文件）&lt;/li&gt;
  &lt;li&gt;.a（静态库文件 ）&lt;/li&gt;
  &lt;li&gt;.dylib（动态库文件 ）&lt;/li&gt;
  &lt;li&gt;.framework（库文件）&lt;/li&gt;
  &lt;li&gt;.dSYM（XCode 调试符号文件）&lt;/li&gt;
  &lt;li&gt;可执行文件（没有扩展名）&lt;/li&gt;
  &lt;li&gt;dyld（动态链接器，一个特殊的可执行文件）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/48.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;macho-查看工具otool-与-machoview&quot;&gt;MachO 查看工具：OTool 与 MachOView:&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;OTool 是 macOS 自带的 MachO 文件查看工具，基于命令行，可以通过不同的命令参数快速地查看 MachO 文件各个方面的信息，OTool 位于（/Library/Developer/CommandLineTools/usr/bin/otool）&lt;/li&gt;
  &lt;li&gt;MachOView 是一款开源的 MachO 文件查看工具，基于图形界面，它为查看和编辑（基于 Intel 和 ARM 架构的）MachO 文件提供了完整的解决方案&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;1header&quot;&gt;1、Header&lt;/h4&gt;

&lt;p&gt;Header是文件的头部信息，包括CPU信息、文件类型、Command条数及Size信息。总体来说，作为开发者Header使用的较少，比较常用的是(uintptr_t)&amp;amp;_mh_execute_header获取header地址进行计算用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/49.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;2commands&quot;&gt;2、Commands&lt;/h4&gt;

&lt;p&gt;Load Commands描述的是文件的加载信息，加载信息有很多，加载的段、符号表、动态库信息等都在Commands中取到。这个部分信息还是比较有用的，我们可以从这里获取到符号表和字符串表的偏移量&lt;/p&gt;

&lt;h4 id=&quot;3data&quot;&gt;3、Data&lt;/h4&gt;

&lt;p&gt;Header 区域主要用于存储 MachO 文件的一般信息，并且描述了 LoadCommands 区域
而 LoadCommands 区域则详细描述了 Data 区域
如果说 Header 区域和 LoadCommands 区域的主要作用是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;让系统内核加载器知道如何读取 MachO 文件&lt;/li&gt;
  &lt;li&gt;并指定动态链接器来完成 MachO 文件后续的动态库加载&lt;/li&gt;
  &lt;li&gt;然后设置好程序入口等一些列程序启动前的信息&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;那么，Data 区域的作用，就是当程序运行起来后，为每一个映射到虚拟内存中的指令操作提供真实的物理存储支持&lt;/p&gt;

&lt;p&gt;Data 区域通常是 MachO 文件中最大的部分，主要包含：代码段、数据段，链接信息等
注意：不要把 Data 区域与数据段搞混掉了，Data 区域指的是广义上的数据，而不是特指数据段的数据&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Section&lt;/th&gt;
      &lt;th&gt;用途&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__TEXT.__text&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;主程序代码,存放的是汇编后的代码&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__TEXT.__cstring&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;C 语言字符串&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__TEXT.__const&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt; 关键字修饰的常量&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__TEXT.__stubs&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;用于 Stub 的占位代码，很多地方称之为&lt;em&gt;桩代码&lt;/em&gt;。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__TEXT.__stubs_helper&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;当 Stub 无法找到真正的符号地址后的最终指向&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__TEXT.__objc_methname&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Objective-C 方法名称&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__TEXT.__objc_methtype&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Objective-C 方法类型&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__TEXT.__objc_classname&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Objective-C 类名称&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__DATA.__data&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;初始化过的可变数据&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__DATA.__la_symbol_ptr&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;lazy binding 的指针表，表中的指针一开始都指向 &lt;code class=&quot;highlighter-rouge&quot;&gt;__stub_helper&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__DATA.nl_symbol_ptr&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;非 lazy binding 的指针表，每个表项中的指针都指向一个在装载过程中，被动态链机器搜索完成的符号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__DATA.__const&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;没有初始化过的常量&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__DATA.__cfstring&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;程序中使用的 Core Foundation 字符串（&lt;code class=&quot;highlighter-rouge&quot;&gt;CFStringRefs&lt;/code&gt;）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__DATA.__bss&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;BSS，存放为初始化的全局变量，即常说的静态内存分配&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__DATA.__common&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;没有初始化过的符号声明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__DATA.__objc_classlist&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Objective-C 类列表&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__DATA.__objc_protolist&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Objective-C 原型&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__DATA.__objc_imginfo&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Objective-C 镜像信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__DATA.__objc_selfrefs&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Objective-C &lt;code class=&quot;highlighter-rouge&quot;&gt;self&lt;/code&gt; 引用&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__DATA.__objc_protorefs&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Objective-C 原型引用&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__DATA.__objc_superrefs&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Objective-C 超类引用&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;三利用otool工具查找无用代码&quot;&gt;三、利用Otool工具查找无用代码&lt;/h3&gt;

&lt;p&gt;OTool 是 macOS 自带的 MachO 文件查看工具，基于命令行，可以通过不同的命令参数快速地查看 MachO 文件各个方面的信息，OTool 位于（/Library/Developer/CommandLineTools/usr/bin/otool）&lt;/p&gt;

&lt;h4 id=&quot;1所有方法&quot;&gt;1、所有方法&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; “otool - ov $path”将输出Objective - C类结构及其定义的方法。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/50.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过匹配可以和筛选，可以将获取所有的方法，除了setter and getter方法…&lt;/p&gt;

&lt;p&gt;代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def imp_selectors(path):
    re_sel_imp = re.compile('\s*imp\s*0x\w+ ([+|-]\[.+\s(.+)\])')
    re_properties_start = re.compile('\s*baseProperties 0x\w{9}')
    re_properties_end = re.compile('\w{16} 0x\w{9} _OBJC_CLASS_\$_(.+)')
    re_property = re.compile('\s*name\s*0x\w+ (.+)')
    imp_sels = {}
    is_properties_area = False

    for line in os.popen('/usr/bin/otool -oV %s' % path).readlines():
        results = re_sel_imp.findall(line)
        if results:
            (class_sel, sel) = results[0]
            if sel in imp_sels:
                imp_sels[sel].add(class_sel)
            else:
                imp_sels[sel] = set([class_sel])
        else:
            # delete setter and getter methods as ivar assignment will not trigger them
            # 删除相关的set方法
            if re_properties_start.findall(line):
                is_properties_area = True
            if re_properties_end.findall(line):
                is_properties_area = False
            if is_properties_area:
                property_result = re_property.findall(line)
                if property_result:
                    property_name = property_result[0]
                    if property_name and property_name in imp_sels:
                        # properties layout in mach-o is after func imp
                        imp_sels.pop(property_name)
                        # 拼接set方法
                        setter = 'set' + property_name[0].upper() + property_name[1:] + ':'
                        # 干掉set方法
                        if setter in imp_sels:
                            imp_sels.pop(setter)
    return imp_sels
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;2引用的方法&quot;&gt;2、引用的方法&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;otool -v -s __DATA __objc_selrefs $path
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/50.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;3找出未引用代码&quot;&gt;3、找出未引用代码&lt;/h4&gt;

&lt;p&gt;所有代码与引用的代码的差集即为未使用代码&lt;/p&gt;</content><author><name>Ted</name></author><category term="iOS" /><summary type="html">一、减包的措施</summary></entry><entry><title type="html">CND加速原理和游戏加速原理</title><link href="http://www.helloted.com/ios/2021/03/13/cdn/" rel="alternate" type="text/html" title="CND加速原理和游戏加速原理" /><published>2021-03-13T20:00:00+08:00</published><updated>2021-03-13T20:00:00+08:00</updated><id>http://www.helloted.com/ios/2021/03/13/cdn</id><content type="html" xml:base="http://www.helloted.com/ios/2021/03/13/cdn/">&lt;h3 id=&quot;一普通的http请求&quot;&gt;一、普通的HTTP请求&lt;/h3&gt;

&lt;h4 id=&quot;11http请求&quot;&gt;1.1HTTP请求&lt;/h4&gt;

&lt;p&gt;一次完整的HTTP请求所经历的步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;DNS解析(通过访问的域名找出其IP地址，递归搜索)&lt;/li&gt;
  &lt;li&gt;HTTP请求，当输入一个请求时，建立一个Socket连接发起TCP的3次握手&lt;/li&gt;
  &lt;li&gt;如果是HTTPS请求建立连接后，则会有安全认证。&lt;/li&gt;
  &lt;li&gt;客户端向服务器发送请求命令（一般是GET或POST请求）&lt;/li&gt;
  &lt;li&gt;客户端发送请求头信息&lt;/li&gt;
  &lt;li&gt;服务器发送应答头信息&lt;/li&gt;
  &lt;li&gt;服务器向客户端发送数据&lt;/li&gt;
  &lt;li&gt;服务器关闭TCP连接（4次挥手）&lt;/li&gt;
  &lt;li&gt;客户端根据返回的HTML，CSS，JS进行渲染&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;12dns解析&quot;&gt;1.2DNS解析&lt;/h4&gt;

&lt;p&gt;而在DNS解析过程中，如果要访问的网站名为：”baidu.com”，客户端首先会在本机的hosts文件和hosts缓存中查找该域名对应的IP地址；如果本机中没有此信息，则会到我们的&lt;code class=&quot;highlighter-rouge&quot;&gt;本地DNS&lt;/code&gt;进行询问该域名对应的IP地址；如果本地DNS中仍然没有该域名的IP信息时，则会由本地DNS依次向&lt;code class=&quot;highlighter-rouge&quot;&gt;根DNS&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;顶级域DNS&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;权威DNS&lt;/code&gt;进行询问，最终&lt;code class=&quot;highlighter-rouge&quot;&gt;本地DNS&lt;/code&gt;将IP地址发送给客户端。客户端通过IP地址向远程的源站服务器发出HTTP请求并获取相应的数据内容。&lt;/p&gt;

&lt;p&gt;以上是通过DNS的&lt;code class=&quot;highlighter-rouge&quot;&gt;迭代解析&lt;/code&gt;模式获取域名对应的IP地址并发送HTTP请求的过程。源站的提供商通过配置权威DNS将源站的域名与提供服务的服务器主机进行绑定，使客户端通过DNS服务可以顺利地获取源站域名对应的IP地址并通过IP地址与源站进行通信。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_1/49.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;二cdn&quot;&gt;二、CDN&lt;/h3&gt;

&lt;h4 id=&quot;21cdn简介&quot;&gt;2.1CDN简介&lt;/h4&gt;

&lt;p&gt;CDN（Content Delivery Network，内容分发网络，源站内容(image、html、js、css等) 这个属于内容分发）是构建在现有互联网基础之上的一层智能虚拟网络，通过在网络各处部署节点服务器，实现将源站内容分发至所有CDN节点，使用户可以就近获得所需的内容。CDN服务缩短了用户查看内容的访问延迟，提高了用户访问网站的响应速度与网站的可用性，解决了网络带宽小、用户访问量大、网点分布不均等问题。&lt;/p&gt;

&lt;p&gt;CDN 诞生于二十多年前，随着骨干网压力的逐渐增大，以及长传需求的逐渐增多，使得骨干网的压力越来越大，长传效果越来越差。于是在 1995 年，MIT 的应用数学教授 Tom Leighton 带领着研究生 Danny Lewin 和其他几位顶级研究人员一起尝试用数学问题解决网络拥堵问题。&lt;/p&gt;

&lt;p&gt;他们使用数学算法，处理内容的动态路由安排，并最终解决了困扰 Internet 使用者的难题。后来，史隆管理学院的 MBA 学生 Jonathan Seelig 加入了 Leighton 的队伍中，从那以后他们开始实施自己的商业计划，最终于 1998 年 8 月 20 日正式成立公司，命名为 Akamai。&lt;/p&gt;

&lt;p&gt;同年 1998 年，中国第一家 CDN 公司蓝汛 ChinaCache成立。&lt;/p&gt;

&lt;h4 id=&quot;22为什么有cdn&quot;&gt;2.2为什么有CDN&lt;/h4&gt;

&lt;p&gt;当下的互联网应用都包含大量的静态内容，但静态内容以及一些准动态内容又是最耗费带宽的，特别是针对全国甚至全世界的大型网站，如果这些请求都指向主站的服务器的话，不仅是主站服务器受不了，单端口500M左右的带宽也扛不住，所以大多数网站都需要CDN服务。&lt;/p&gt;

&lt;p&gt;根本上的原因是，访问速度对互联网应用的用户体验、口碑、甚至说直接的营收都有巨大的影响，任何的企业都渴望自己站点有更快的访问速度。而HTTP传输时延对web的访问速度的影响很大，在绝大多数情况下是起决定性作用的，这是由TCP/IP协议的一些特点决定的。物理层上的原因是光速有限、信道有限，协议上的原因有丢包、慢启动、拥塞控制等。&lt;/p&gt;

&lt;p&gt;这就是你使用CDN的第一个也是最重要的原因：为了加速网站的访问。&lt;/p&gt;

&lt;p&gt;除了加速网站的访问之外，CDN还有一些作用：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;为了实现跨运营商、跨地域的全网覆盖&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;互联不互通、区域ISP地域局限、出口带宽受限制等种种因素都造成了网站的区域性无法访问。CDN加速可以覆盖全球的线路，通过和运营商合作，部署IDC资源，在全国骨干节点商，合理部署CDN边缘分发存储节点，充分利用带宽资源，平衡源站流量。阿里云在国内有500+节点，海外300+节点，覆盖主流国家和地区不是问题，可以确保CDN服务的稳定和快速。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;为了保障你的网站安全&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CDN的负载均衡和分布式存储技术，可以加强网站的可靠性，相当无无形中给你的网站添加了一把保护伞，应对绝大部分的互联网攻击事件。防攻击系统也能避免网站遭到恶意攻击。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;为了异地备援&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当某个服务器发生意外故障时，系统将会调用其他临近的健康服务器节点进行服务，进而提供接近100%的可靠性，这就让你的网站可以做到永不宕机。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;为了节约成本&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;投入使用CDN加速可以实现网站的全国铺设，你根据不用考虑购买服务器与后续的托管运维，服务器之间镜像同步，也不用为了管理维护技术人员而烦恼，节省了人力、精力和财力。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;为了让你更专注业务本身&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CDN加速厂商一般都会提供一站式服务，业务不仅限于CDN，还有配套的云存储、大数据服务、视频云服务等，而且一般会提供7x24运维监控支持，保证网络随时畅通，你可以放心使用。并且将更多的精力投入到发展自身的核心业务之上。&lt;/p&gt;

&lt;h3 id=&quot;三cdn加速原理&quot;&gt;三、CDN加速原理&lt;/h3&gt;

&lt;p&gt;CDN将我们对源站的请求导向了距离用户较近的缓存节点，而非源站。&lt;/p&gt;

&lt;p&gt;在DNS解析域名时新增了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;全局负载均衡系统（GSLB）&lt;/code&gt;，GSLB的主要功能是根据用户的本地DNS的IP地址判断用户的位置，筛选出距离用户较近的&lt;code class=&quot;highlighter-rouge&quot;&gt;本地负载均衡系统（SLB）&lt;/code&gt;，并将该SLB的IP地址作为结果返回给本地DNS。SLB主要负责判断&lt;code class=&quot;highlighter-rouge&quot;&gt;缓存服务器集群&lt;/code&gt;中是否包含用户请求的资源数据，如果缓存服务器中存在请求的资源，则根据缓存服务器集群中节点的健康程度、负载量、连接数等因素筛选出最优的缓存节点，并将HTTP请求重定向到最优的缓存节点上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_1/50.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为了更清晰地说明CDN的工作原理，下面以客户端发起对”join.qq.com/video.php”的HTTP请求为例进行说明：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;用户发起对”join.qq.com/video.php”的HTTP请求，首先需要通过本地DNS通过”迭代解析”的方式获取域名”join.qq.com”的IP地址；&lt;/li&gt;
  &lt;li&gt;如果本地DNS的缓存中没有该域名的记录，则向&lt;code class=&quot;highlighter-rouge&quot;&gt;根DNS&lt;/code&gt;发送DNS查询报文；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;根DNS&lt;/code&gt;发现域名的前缀为”com”，则给出负责解析&lt;code class=&quot;highlighter-rouge&quot;&gt;com&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;顶级DNS&lt;/code&gt;的IP地址；&lt;/li&gt;
  &lt;li&gt;本地DNS向&lt;code class=&quot;highlighter-rouge&quot;&gt;顶级DNS&lt;/code&gt;发送DNS查询报文；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;顶级DNS&lt;/code&gt;发现域名的前缀为”qq.com”，在本地记录中查找负责该前缀的&lt;code class=&quot;highlighter-rouge&quot;&gt;权威DNS&lt;/code&gt;的IP地址并进行回复；&lt;/li&gt;
  &lt;li&gt;本地DNS向&lt;code class=&quot;highlighter-rouge&quot;&gt;权威DNS&lt;/code&gt;发送DNS查询报文；&lt;/li&gt;
  &lt;li&gt;权威DNS查找到一条NAME字段为”join.qq.com”的&lt;code class=&quot;highlighter-rouge&quot;&gt;CNAME记录&lt;/code&gt;（由服务提供者配置），该记录的Value字段为”join.qq.cdn.com”；并且还找到另一条NAME字段为”join.qq.cdn.com”的A记录，该记录的Value字段为GSLB的IP地址；&lt;/li&gt;
  &lt;li&gt;本地DNS向GSLB发送DNS查询报文；&lt;/li&gt;
  &lt;li&gt;GSLB根据&lt;code class=&quot;highlighter-rouge&quot;&gt;本地DNS&lt;/code&gt;的IP地址判断用户的大致位置为深圳，筛选出位于华南地区且综合考量最优的SLB的IP地址填入DNS回应报文，作为DNS查询的最终结果；&lt;/li&gt;
  &lt;li&gt;本地DNS回复客户端的DNS请求，将上一步的IP地址作为最终结果回复给客户端；&lt;/li&gt;
  &lt;li&gt;客户端根据IP地址向SLB发送HTTP请求：”&lt;a href=&quot;https://join.qq.com/video.php&quot;&gt;join.qq.com/video.php&lt;/a&gt;“；&lt;/li&gt;
  &lt;li&gt;SLB综合考虑缓存服务器集群中各个节点的资源限制条件、健康度、负载情况等因素，筛选出最优的缓存节点后回应客户端的HTTP请求（状态码为302，重定向地址为最优缓存节点的IP地址）；&lt;/li&gt;
  &lt;li&gt;客户端接收到SLB的HTTP回复后，重定向到该缓存节点上；&lt;/li&gt;
  &lt;li&gt;缓存节点判断请求的资源是否存在、过期，将缓存的资源直接回复给客户端，否则到源站进行数据更新再回复。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其中较为关键的步骤为6~9，与普通的DNS过程不同的是，这里需要服务提供者（源站）配置它在其权威DNS中的记录，将直接指向源站的A记录修改为一条CNAME记录及其对应的A记录，CNAME记录将目标域名转换为GSLB的别名，A记录又将该别名转换为GSLB的IP地址。通过这一系列的操作，将解析源站的目标域名的权力交给了GSLB，以致于GSLB可以根据地理位置等信息将用户的请求引导至距离其最近的”缓存节点”，减缓了源站的负载压力和网络拥塞。&lt;/p&gt;

&lt;h4 id=&quot;cdn节点有缓存场景&quot;&gt;CDN节点有缓存场景&lt;/h4&gt;

&lt;p&gt;HTTP请求流程说明：&lt;/p&gt;

&lt;p&gt;1、用户在浏览器输入要访问的网站域名，向本地DNS发起域名解析请求。&lt;/p&gt;

&lt;p&gt;2、域名解析的请求被发往网站授权DNS服务器。&lt;/p&gt;

&lt;p&gt;3、网站DNS服务器解析发现域名已经CNAME到了www.example.com.c.cdnhwc1.com。&lt;/p&gt;

&lt;p&gt;4、请求被指向CDN服务。&lt;/p&gt;

&lt;p&gt;5、CDN对域名进行智能解析，将响应速度最快的CDN节点IP地址返回给本地DNS。&lt;/p&gt;

&lt;p&gt;6、用户获取响应速度最快的CDN节点IP地址。&lt;/p&gt;

&lt;p&gt;7、浏览器在得到速度最快节点的IP地址以后，向CDN节点发出访问请求。&lt;/p&gt;

&lt;p&gt;8、CDN节点将用户所需资源返回给用户。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_1/51.jpeg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;cdn节点无缓存场景&quot;&gt;CDN节点无缓存场景&lt;/h4&gt;

&lt;p&gt;HTTP请求流程说明：&lt;/p&gt;

&lt;p&gt;1、用户在浏览器输入要访问的网站域名，向本地DNS发起域名解析请求。&lt;/p&gt;

&lt;p&gt;2、域名解析的请求被发往网站授权DNS服务器。&lt;/p&gt;

&lt;p&gt;3、网站DNS服务器解析发现域名已经CNAME到了www.example.com.c.cdnhwc1.com。&lt;/p&gt;

&lt;p&gt;4、请求被指向CDN服务。&lt;/p&gt;

&lt;p&gt;5、CDN对域名进行智能解析，将响应速度最快的CDN节点IP地址返回给本地DNS。&lt;/p&gt;

&lt;p&gt;6、用户获取响应速度最快的CDN节点IP地址。&lt;/p&gt;

&lt;p&gt;7、浏览器在得到速度最快节点的IP地址以后，向CDN节点发出访问请求。&lt;/p&gt;

&lt;p&gt;8、CDN节点回源站拉取用户所需资源。&lt;/p&gt;

&lt;p&gt;9、将回源拉取的资源缓存至节点。&lt;/p&gt;

&lt;p&gt;10、将用户所需资源返回给用户。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_1/52.jpeg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;cdn适用场景&quot;&gt;CDN适用场景&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;网站站点/应用加速&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通俗讲就是static 内容加速，静态内容加速，如：html image js css 等&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;视音频点播/大文件下载分发加速&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;基本上都是视频点播，MP4、flv等视频文件，例如国内的优酷、土豆、腾讯视频、爱奇艺都是一样。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;视频直播加速&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;视频直播加速，流媒体切片、转码、码流转换等等。&lt;/p&gt;

&lt;p&gt;熊猫TV、斗鱼、淘宝直播&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;移动应用加速&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;移动APP更新文件（apk文件）分发，移动APP内图片、页面、短视频、UGC等内容的优化加速分发。&lt;/p&gt;

&lt;p&gt;ios、安卓 端 APP 、微信小程序、支付宝小程序等。&lt;/p&gt;

&lt;h3 id=&quot;四网游加速原理&quot;&gt;四、网游加速原理&lt;/h3&gt;

&lt;h4 id=&quot;41网络质量指标&quot;&gt;4.1网络质量指标&lt;/h4&gt;

&lt;p&gt;网游加速的目的是为了让个人用户能够快速地连接到游戏服务器，让用户游戏更流畅。常用的衡量指标如下：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）网络延迟（delay）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;它定义为信号从网络的一端(如玩家客户端)到另一端(如游戏服务器)所花费的时间。基于网络延迟，游戏卡顿情况可以简单分为以下级别：&lt;/p&gt;

&lt;p&gt;1~30ms：极快，几乎察觉不出有延迟，玩任何游戏速度都特别顺畅&lt;/p&gt;

&lt;p&gt;31~50ms：良好，可以正常游戏，没有明显的延迟情况&lt;/p&gt;

&lt;p&gt;51~100ms：普通，对抗类游戏在一定水平以上能感觉出延迟，偶尔感觉到停顿&lt;/p&gt;

&lt;p&gt;100ms~200ms：较差，无法正常游玩对抗类游戏，有明显卡顿，偶尔出现丢包和&lt;a href=&quot;https://baike.baidu.com/item/掉线&quot;&gt;掉线&lt;/a&gt;现象&lt;/p&gt;

&lt;p&gt;200ms~500ms：很差，访问网页有明显的延迟和卡顿，经常出现丢包或无法访问&lt;/p&gt;

&lt;p&gt;&amp;gt;500ms：极差，难以接受的延迟和丢包，甚至无法访问网页&lt;/p&gt;

&lt;p&gt;&amp;gt;1000ms：基本无法访问&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）丢包率（Loss Tolerance或Packet Loss Rate）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;它定义为测试中所丢失数据包数量占所发送数据组的比率。计算方法是:“(输入报文-输出报文)/输入报文*100%”。丢包率与数据包长度以及包发送频率相关。通常,千兆网卡在流量大于200Mbps时,丢包率小于万分之五;百兆网卡在流量大于60Mbps时,丢包率小于万分之一。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（3）每秒传输帧数FPS（frames per second）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;它定义为画面每秒传输的帧数，可以理解为屏幕的刷新率，通常不低于30帧/秒。但达到60帧/秒以上，人眼就分别不出来了，也就是说60帧/秒和200帧/秒在人眼看来是完全没区别的。一块高性能的显卡有助于数据帧的处理。&lt;/p&gt;

&lt;p&gt;其它描述网络性能的指标还包括，速率、带宽、网络带宽积、吞吐率等。&lt;/p&gt;

&lt;h4 id=&quot;42网游加速方式&quot;&gt;4.2网游加速方式&lt;/h4&gt;

&lt;p&gt;网游加速器主要是在骨干网发挥作用，为了提升网络互联速度，网游加速器厂商专门搭建或租用了高带宽的双线机房，架设多个节点服务器，编写&lt;a href=&quot;https://www.jinglingip.com/&quot;&gt;网络加速器&lt;/a&gt;客户端，借助节点服务器来高效完成玩家的跨网连接游戏服务器请求。网络加速器客户端能够自动识别用户的网络线路类型(电信或联通)，自动选择速度最快的节点服务器进行数据转发，从而达到数据加速作用。&lt;/p&gt;

&lt;p&gt;网游加速可以采用两种方式来实现。&lt;/p&gt;

&lt;p&gt;其一是VPN&lt;/p&gt;

&lt;p&gt;它需要部署双线VPN服务器作为加速节点，用于电信和联通之间的自动快速切换。客户端通过加速服务器自动选择速度最快的服务器。它需要拨号连接到VPN服务器并获取一个虚拟IP地址，通过修改路由表的方式，将指定进程的网络访问路由到虚拟IP上，而其余地址仍经过原默认路由途径访问。&lt;/p&gt;

&lt;p&gt;其二是代理服务器。&lt;/p&gt;

&lt;p&gt;它通过部署SOCKS5代理服务器作为加速节点，使得客户端能够自动选择最快的代理服务器作为当前的转发节点。在客户端，该方式主要采用LSP技术，在用户的主机安装分层协议。当在游戏客户端调用connect函数试图连接游戏服务器时，LSP将该连接重定向到代理服务器，并采用SOCKS5协议规范与代理服务器进行数据协商，由代理服务器来连接真正的游戏服务器，最后将游戏服务器的数据原封不动转发给用户或将用户的数据原封不动转发给游戏服务器。&lt;/p&gt;

&lt;h4 id=&quot;43网游加速应用&quot;&gt;4.3网游加速应用&lt;/h4&gt;

&lt;p&gt;加速器服务提供商有一台高速服务器连接游戏服务器，延时极低，然后当地加速器客户端通过添加lsp或vpn的方法!让游戏历程连接到加速器服务商的服务器上，这样就即是别的开发了一条人很少的通道，游戏的重要延时就是用户盘算机和加速器服务器之间的延时了。&lt;/p&gt;

&lt;p&gt;迅游手游加器的加速原理是：&lt;/p&gt;

&lt;p&gt;利用VPN技术，用户通过一 台登 陆服务器用加速软件商提供的账号密码拨号登 陆到 一台具有双线带宽的服务器上，并与之建立连接并改变当前网络环境。在访问的时候，将本机访问的目标（例如：一个网址）通过节点服务器转发一次，从而完成加速效果。&lt;/p&gt;

&lt;p&gt;Anycas加速：&lt;/p&gt;

&lt;p&gt;Anycast 的 IP 能起到游戏加速器的作用，游戏请求就近进入腾讯云，走腾讯云的内网专线到达游戏服务器，极大缩短经过的公网路径，减少了延时、抖动、丢包。此外跟传统加速比，IP 入口无需额外部署流量接收设备，且IP无需区分地域，简化了 DNS 部署。&lt;/p&gt;</content><author><name>Ted</name></author><category term="iOS" /><summary type="html">一、普通的HTTP请求</summary></entry><entry><title type="html">iOS推送APNs</title><link href="http://www.helloted.com/ios/2021/02/26/push/" rel="alternate" type="text/html" title="iOS推送APNs" /><published>2021-02-26T20:00:00+08:00</published><updated>2021-02-26T20:00:00+08:00</updated><id>http://www.helloted.com/ios/2021/02/26/push</id><content type="html" xml:base="http://www.helloted.com/ios/2021/02/26/push/">&lt;h4 id=&quot;0通知&quot;&gt;0、通知&lt;/h4&gt;

&lt;p&gt;iOS中的推送通知，主要有以下几种推送：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;本地通知：&lt;/strong&gt;iOS在本地发出的通知，功能开发集成在UserNotifications.framework内，常见应用：闹钟提醒。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;在线推送：&lt;/strong&gt;APP在前台时，消息通过自建的网络长连接从服务器推送到应用，常见应用：微信在前台时的消息推送。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;APNs：&lt;/strong&gt;APP未被唤起或者处于后台，通过苹果服务器远程推送消息给应用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;notifications-回顾&quot;&gt;Notifications 回顾&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;iOS 3 － Apple 引入推送通知&lt;/li&gt;
  &lt;li&gt;iOS 4 － 引入本地通知&lt;/li&gt;
  &lt;li&gt;iOS 5 － 有了通知中心&lt;/li&gt;
  &lt;li&gt;iOS 6 － 通知中心与iCloud同步&lt;/li&gt;
  &lt;li&gt;iOS 7 － 后台靜默推送&lt;/li&gt;
  &lt;li&gt;iOS 8 － 重新設定了通知许可权，可互动通知&lt;/li&gt;
  &lt;li&gt;iOS 9 － 支援在通知中回复信息，Provider API 等等&lt;/li&gt;
  &lt;li&gt;iOS 10 － 新增了UserNotificationKit框架，整合了关于通知的方法，新增了图片音频视频等格式&lt;/li&gt;
  &lt;li&gt;iOS 12 － 新增了通知分组、隐式推送、通知内容拓展&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;1apns&quot;&gt;1、APNs&lt;/h4&gt;

&lt;p&gt;APNs，即 Apple Push Notification Service，依托一个或几个系统常驻进程运作，是全局的（接管所有应用的消息推送），可看作是独立于应用之外，设备与苹果的服务器之间维持一个长连接进行消息传递。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_1/46.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;主要流程为：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;服务器端将消息先发送到苹果的APNs；&lt;/li&gt;
  &lt;li&gt;由苹果的APNs将消息推送到客户的设备端；&lt;/li&gt;
  &lt;li&gt;由iOS系统将接收到的消息分发给相应的App。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;2详细过程&quot;&gt;2、详细过程&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_1/48.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_1/47.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;过程如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;首先是设备与APNS Server建立连接；&lt;/li&gt;
  &lt;li&gt;APP首次启动向APNS Server注册deviceToken。APNS Server返回deviceToken给APP；&lt;/li&gt;
  &lt;li&gt;APP将deviceToken发送给PUSH服务端程序；&lt;/li&gt;
  &lt;li&gt;服务端程序向APNS服务发送消息；&lt;/li&gt;
  &lt;li&gt;APNS服务将消息发送给设备，设备转发给对应的APP。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;3apns的安全架构&quot;&gt;3、APNs的安全架构&lt;/h4&gt;

&lt;p&gt;APNs使用两个“信任”来实施端到端、密码验证和身份验证：连接信任和设备令牌信任（&lt;em&gt;connection trust&lt;/em&gt; and &lt;em&gt;device token trust&lt;/em&gt;.）。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;连接信任(connection trust)&lt;/code&gt;在消息Providers和APN之间、APN和设备device之间起作用。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;提供程序到APN的连接信任&lt;/strong&gt;:确保提供程序和APN之间的连接仅适用于与Apple达成推送通知传递协议的公司拥有的授权提供程序。通过签名证书来保证授权。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;APN到设备的连接信任&lt;/strong&gt;:可确保只有授权的设备才能连接到APN来接收通知。APNs会自动强制与每个设备建立连接信任，以确保设备的合法性。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;设备令牌信任(device token trust)&lt;/code&gt;对于每个远程通知都是端到端的。它确保仅在正确的起点（提供者）和终点（设备）之间路由通知。&lt;/p&gt;

&lt;p&gt;deviceToken是不透明的NSData实例，其中包含Apple分配给特定设备上特定应用程序的唯一标识符。只有APN才能解码和读取deviceToken的内容。每个应用程序实例在向APN注册时都会收到其唯一的deviceToken，然后必须将token转发给它的提供者，推送通知请求中包含设备令牌；APN使用设备令牌来确保仅将通知传递给预期的唯一应用程序设备组合。&lt;/p&gt;

&lt;p&gt;APN可以出于多种原因发行新的deviceToken：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用户在新设备上安装您的应用&lt;/li&gt;
  &lt;li&gt;用户从备份中还原设备&lt;/li&gt;
  &lt;li&gt;用户重新安装操作系统&lt;/li&gt;
  &lt;li&gt;其他系统定义的事件&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;4devicetoken&quot;&gt;4、DeviceToken&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;device token: APNs uses device tokens to identify each unique app and device combination. It also uses them to authenticate the routing of remote notifications sent to a device.(device token是APNs用于区分识别每个iOS设备和设备上不同app的一个标识符，还可以用于APNs通过它将推送消息路由到指定设备上)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;deviceToken注意事项：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;获取deviceToken跟app是否申请了推送权限无关，即使是禁用了远程推送，也可以正确获取deviceToken。如果没有申请权限，会以静默推送形式呈现。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;If you do not request and receive authorization for your app’s interactions, the system delivers all remote notifications to your app silently.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;安装应用后第一次打开APP获取deviceToken时必须联网。如果在获取时没有网络，在重新连接网络后会第一时间返回deviceToken。&lt;/li&gt;
  &lt;li&gt;不需要缓存DeviceToken。如果已经生成了有效的DeviceToken，系统或有缓存，在 重新安装App、重装系统、或者从备份还原系统时，会重新生成DeviceToken并更新缓存。&lt;/li&gt;
  &lt;li&gt;debug环境下是向开发环境的APNs服务器申请DeviceToken，而release环境是向生产环境的APNs服务器申请的。如果环境不匹配，则会出现Bad deviceToken错误。&lt;/li&gt;
  &lt;li&gt;deviceToken与bundleId存在着关联。如果deviceToken与证书中的bundleId不匹配，会返回DeviceTokenNotForTopic&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Ted</name></author><category term="iOS" /><summary type="html">0、通知</summary></entry><entry><title type="html">机器学习在APP启动耗时统计的应用</title><link href="http://www.helloted.com/ios/2020/11/26/sklearn/" rel="alternate" type="text/html" title="机器学习在APP启动耗时统计的应用" /><published>2020-11-26T20:00:00+08:00</published><updated>2020-11-26T20:00:00+08:00</updated><id>http://www.helloted.com/ios/2020/11/26/sklearn</id><content type="html" xml:base="http://www.helloted.com/ios/2020/11/26/sklearn/">&lt;h4 id=&quot;0统计方案&quot;&gt;0、统计方案&lt;/h4&gt;

&lt;p&gt;应用启动耗时统计除了有通过代码来计算，还有一种方案就是通过录屏，然后查看视频，一帧一帧的人工识别启动帧和加载完成的帧，并且用时间戳相减，从而得到启动耗时时间。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
&lt;img src=&quot;/img/Simple_3/53.jpg&quot; style=&quot;width:300px; float:left&quot; /&gt;&lt;img src=&quot;/img/Simple_3/54.jpg&quot; style=&quot;width:300px;margin-left:16px&quot; /&gt;  
&lt;/div&gt;

&lt;p&gt;这种方案如果多次人工识别就很繁琐，所以我们引入机器学习&lt;/p&gt;

&lt;h4 id=&quot;1机器学习自动识别过程&quot;&gt;1、机器学习自动识别过程&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_3/55.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这是一个典型的图像识别，因此选择了SVM模型训练数据，通过有监督学习，建立图像和labal之间的对应关系。&lt;/p&gt;

&lt;p&gt;框架选择方面，这是传统的机器学习，所以用的是Scikit-learn框架&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_3/57.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;2准备训练数据&quot;&gt;2、准备训练数据&lt;/h4&gt;

&lt;p&gt;iOS的启动过程：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;启动前&lt;/li&gt;
  &lt;li&gt;点击启动iCon&lt;/li&gt;
  &lt;li&gt;默认LaunchScreen&lt;/li&gt;
  &lt;li&gt;广告页&lt;/li&gt;
  &lt;li&gt;首页出现&lt;/li&gt;
  &lt;li&gt;首页加载完毕&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;cut_video&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_video&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_video&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'cuting...'&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;videoCap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cv2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;VideoCapture&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_video&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;videoCap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isOpened&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;log&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_video&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; 该输入路径视频不存在，请检查&quot;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;success&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;frame&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;videoCap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;success&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cv2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;waitKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;27&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;success&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;frame&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;videoCap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cv2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;imwrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_video&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'o_'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'.jpg'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;frame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;videoCap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;将训练视频按帧分割，这里用的是cv2的库&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;make_dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;folder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;feature_dir&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getcwd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;folder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exists&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;makedirs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;make_all_folder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;make_dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'mark_data/0_pre'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 桌面前
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;make_dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'mark_data/1_home'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 桌面状态
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;make_dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'mark_data/2_icon_click'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 点击icon
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;make_dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'mark_data/3_default_show'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 默认启动图
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;make_dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'mark_data/4_ad_show'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 广告页
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;make_dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'mark_data/5_first_screen'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 首页
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;make_dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'mark_data/6_finish'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 完成
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;生成几个阶段的文件夹，然后将分割好的图片放入对应的阶段&lt;/p&gt;

&lt;h4 id=&quot;3模型训练&quot;&gt;3、模型训练&lt;/h4&gt;

&lt;p&gt;减少数据大小，将图片缩小10倍，导入标签&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pre_train_datas&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;img_w&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;img_h&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;label_list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;image_list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;image_classes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;listdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;mark_data&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;classes&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;image_classes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;image_dir&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getcwd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'/mark_data/'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;classes&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;image_dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;image_path&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;listdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;image_dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)[:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;image_path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endswith&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;.jpg&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;img&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Image&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;image_dir&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;image_path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;img_w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;img_h&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;thumbnail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;img_w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;img_h&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;image_list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;asarray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flatten&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;label_list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;classes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;image_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;label_list&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;用SVM训练，得到model&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def training_model():
    train_img, train_label = pre_train_datas()

    linear_svc = svm.LinearSVC()
    linear_svc.fit(train_img, train_label)
    model_name = 'model/' + str(img_w) + '_' + str (img_h) + '_model'
    joblib.dump(linear_svc, model_name)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;4测试&quot;&gt;4、测试&lt;/h4&gt;

&lt;p&gt;将测试视频输入后按帧分割，进行识别，记录启动时和加载完成的时间戳，将时间戳一减便能得到启动时间&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;check_video&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_video&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;videoCap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cv2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;VideoCapture&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_video&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;videoCap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isOpened&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;log&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_video&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; 该输入路径视频不存在，请检查&quot;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    
    &lt;span class=&quot;n&quot;&gt;width&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;videoCap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cv2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CAP_PROP_FRAME_WIDTH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;height&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;videoCap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cv2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CAP_PROP_FRAME_HEIGHT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;model_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'model/'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'_'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'_model'&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;clf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;joblib&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;model_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;success&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;success&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;success&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;frame&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;videoCap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;success&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;milliseconds&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;videoCap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cv2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CAP_PROP_POS_MSEC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;img&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Image&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fromarray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cv2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cvtColor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;frame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cv2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;COLOR_BGR2RGB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;  
            &lt;span class=&quot;n&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;thumbnail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reshape&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;predicts&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;predict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;predicts&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;predicts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'2_icon_click'&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;milliseconds&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;predicts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'6_finish'&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;milliseconds&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;duration&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'本次启动时间:'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;duration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'ms'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_3/56.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;</content><author><name>Ted</name></author><category term="iOS" /><summary type="html">0、统计方案</summary></entry><entry><title type="html">Clang插件统计方法耗时</title><link href="http://www.helloted.com/ios/2020/09/22/clang-time/" rel="alternate" type="text/html" title="Clang插件统计方法耗时" /><published>2020-09-22T20:00:00+08:00</published><updated>2020-09-22T20:00:00+08:00</updated><id>http://www.helloted.com/ios/2020/09/22/clang-time</id><content type="html" xml:base="http://www.helloted.com/ios/2020/09/22/clang-time/">&lt;h4 id=&quot;0统计函数耗时原理&quot;&gt;0、统计函数耗时原理&lt;/h4&gt;

&lt;p&gt;LLVM的优化和转换工作就需要通过PASS来进行，就像下面这种图，PASS就像流水线上的操作工一样对中间代码IR进行优化，每个PASS完成特定的优化工作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_3/36.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;所有的pass都是llvm的Pass类的子类，通过重写继承的虚函数来实现特定的功能。根据pass不同的功能分类，继承的类也不同，比如：ModulePass , CallGraphSCCPass, FunctionPass , LoopPass, RegionPass, BasicBlockPass，llvm系统会根据实例的类别来判断pass的功能，然后将其整合到现有的优化体系中去。&lt;/p&gt;

&lt;p&gt;FunctionPASS会遍历我们编译的每个函数，在遍历编译的函数过程中，在函数运行之前获取当前时间，在函数运行之后获取当前时间，二者相减，可以得到函数的运行时间。&lt;/p&gt;

&lt;h4 id=&quot;1整体过程&quot;&gt;1、整体过程&lt;/h4&gt;

&lt;p&gt;待插入函数&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sys/time.h&amp;gt;
&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;my_fun_b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timeval&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;star&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;gettimeofday&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;star&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;star&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tv_sec&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000000&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;star&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tv_usec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;my_fun_e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timeval&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;gettimeofday&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tv_sec&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000000&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tv_usec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s %ld us&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;my_fun_b是函数的最开始，插入并用于记录当前时间；&lt;/p&gt;

&lt;p&gt;my_fun_e则是在函数的最末尾插入，用于记录当前时间并与之前函数开始记录的时间做差值，把函数名称和耗时打印出来。&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;runOnFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Function&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// 1. 已经插入的不需要再次插入&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;startswith&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;my_fun_&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

      &lt;span class=&quot;c1&quot;&gt;// 2. 记录开始时间&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;beginTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;insert_begin_inst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;beginTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      
      &lt;span class=&quot;c1&quot;&gt;// 3. 方法结束时统计方法耗时，开始的时间记录作为参数&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;insert_return_inst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;beginTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;2函数开始&quot;&gt;2、函数开始&lt;/h4&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;insert_begin_inst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Function&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;beginTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// 0.函数最开始的BasicBlock&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;LLVMContext&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getParent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;BasicBlock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getEntryBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
      
      &lt;span class=&quot;c1&quot;&gt;// 1. 获取要插入的函数&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;FunctionCallee&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;beginFun&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getParent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getOrInsertFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;my_fun_b&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FunctionType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getInt64Ty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

      &lt;span class=&quot;c1&quot;&gt;// 2. 构造函数&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// Value *beginTime = nullptr;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;CallInst&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inst&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;IRBuilder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;builder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;inst&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;builder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CreateCall&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beginFun&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;llvm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;errs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Create First CallInst Failed&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

      &lt;span class=&quot;c1&quot;&gt;// 3. 获取函数开始的第一条指令&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;Instruction&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beginInst&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dyn_cast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Instruction&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;

      &lt;span class=&quot;c1&quot;&gt;// 4. 将inst插入&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;inst&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;insertBefore&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beginInst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      
      &lt;span class=&quot;c1&quot;&gt;// 5.根据返回值记录开始时间&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;beginTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;3函数结束&quot;&gt;3、函数结束&lt;/h4&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;insert_return_inst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Function&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;beginTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;LLVMContext&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getParent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iterator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;I&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;I&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          
        &lt;span class=&quot;c1&quot;&gt;//  函数结尾的BasicBlock&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;BasicBlock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BB&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BasicBlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iterator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;I&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;I&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;ReturnInst&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IST&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dyn_cast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReturnInst&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IST&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
          
          &lt;span class=&quot;c1&quot;&gt;// end_func 类型&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;FunctionType&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endFuncType&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FunctionType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getVoidTy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getInt8PtrTy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getInt64Ty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)},&lt;/span&gt;
            &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;
          &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

          &lt;span class=&quot;c1&quot;&gt;// end_func&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;FunctionCallee&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endFunc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getModule&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getOrInsertFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;my_fun_e&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endFuncType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

          &lt;span class=&quot;c1&quot;&gt;// 构造end_func&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;IRBuilder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;builder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;IRBuilder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;callBuilder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;CallInst&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endCI&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;callBuilder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CreateCall&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;builder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CreateGlobalStringPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getParent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()),&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;beginTime&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

          &lt;span class=&quot;c1&quot;&gt;// 插入end_func(struction)&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;endCI&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;insertBefore&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IST&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;4运行效果&quot;&gt;4、运行效果&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-[AppDelegate application:didFinishLaunchingWithOptions:] 5 us
-[AppDelegate application:configurationForConnectingSceneSession:options:] 63 us
-[SceneDelegate window] 0 us
-[SceneDelegate setWindow:] 0 us
-[SceneDelegate window] 0 us
-[SceneDelegate window] 0 us
-[SceneDelegate scene:willConnectToSession:options:] 0 us
-[SceneDelegate window] 0 us
-[SceneDelegate window] 0 us
-[SceneDelegate window] 0 us
-[ViewController viewDidLoad] 0 us
-[SceneDelegate sceneWillEnterForeground:] 0 us
-[SceneDelegate sceneDidBecomeActive:] 0 us
-[SceneDelegate window] 0 us
-[SceneDelegate window] 0 us
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;5统计方法耗时的其他方案&quot;&gt;5、统计方法耗时的其他方案&lt;/h4&gt;
&lt;p&gt;可以通过hook objc_msgSend：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;复制栈帧，debug时候（或crash时候），可以看到调用堆栈。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;保存寄存器。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;调用hook_objc_msgSend_before （保存lr和记录函数调用开始时间）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;恢复寄存器。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;调用objc_msgSend&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;保存寄存器。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;调用hook_objc_msgSend_after （返回lr和函数结束时间减去开始时间，得到函数耗时）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;恢复寄存器。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ret。&lt;/p&gt;

    &lt;p&gt;参考&lt;a href=&quot;https://github.com/maniackk/TimeProfiler&quot;&gt;TimeProfiler&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>Ted</name></author><category term="iOS" /><summary type="html">0、统计函数耗时原理</summary></entry></feed>