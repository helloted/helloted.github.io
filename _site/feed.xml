<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.5.1">Jekyll</generator><link href="http://www.helloted.com/feed.xml" rel="self" type="application/atom+xml" /><link href="http://www.helloted.com/" rel="alternate" type="text/html" /><updated>2018-05-02T19:39:47+08:00</updated><id>http://www.helloted.com/</id><title type="html">Helloted Blog</title><subtitle>Write your site description here. It will be used as your sites meta description as well!</subtitle><entry><title type="html">Mac上搭建直播服务器</title><link href="http://www.helloted.com/%E5%9F%BA%E7%A1%80/2018/05/01/vlclive/" rel="alternate" type="text/html" title="Mac上搭建直播服务器" /><published>2018-05-01T20:00:00+08:00</published><updated>2018-05-01T20:00:00+08:00</updated><id>http://www.helloted.com/%E5%9F%BA%E7%A1%80/2018/05/01/vlclive</id><content type="html" xml:base="http://www.helloted.com/%E5%9F%BA%E7%A1%80/2018/05/01/vlclive/">&lt;h4 id=&quot;1安装nginx&quot;&gt;1、安装Nginx&lt;/h4&gt;

&lt;p&gt;通过homebrew来安装支持rtmp协议模块的nginx&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;brew install nginx-full --with-rtmp-module
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过下面的命令来查看安装位置&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;brew info nginx-full
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_7/22.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过浏览器访问&lt;a href=&quot;http://localhost:8080&quot;&gt;http://localhost:8080&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_7/23.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在nginx.conf里配置&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rtmp {
    server {
        listen 1935;
        application zbcs {
            live on;
            record off;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;重启&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;nginx -s reload
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;2安装ffmpeg来推流本地视频&quot;&gt;2、安装ffmpeg来推流本地视频&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;brew install ffmpeg
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;推流命令为&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ffmpeg -re -i /Users/imac/Documents/demo.mp4 -vcodec copy -f flv rtmp://127.0.0.1:1935/zbcs/room
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ffmpeg -re -i 你的视频文件的绝对路径 -vcodec copy -f flv rtmp://localhost:1935/nginx配置的application名称/room
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这就开始推流了&lt;/p&gt;

&lt;h4 id=&quot;3vlc直播&quot;&gt;3、VLC直播&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;mac端&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下载vlc播放器，在File-&amp;gt;open network输入&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rtmp://127.0.0.1:1935/zbcs/room
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_7/24.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;iPhone&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下载VLC播放器，同一局域网，打开网络流，输入&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rtmp://电脑的本地IP:1935/zbcs/room
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_7/26.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;4推流桌面或者摄像头直播&quot;&gt;4、推流桌面或者摄像头直播&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ffmpeg -f avfoundation -list_devices true -i &quot;&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_7/25.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到在视频设备：&lt;/p&gt;

&lt;p&gt;0：摄像头&lt;/p&gt;

&lt;p&gt;1：桌面捕获&lt;/p&gt;

&lt;p&gt;音频设备：&lt;/p&gt;

&lt;p&gt;0：麦克风&lt;/p&gt;

&lt;p&gt;所以如果要直播摄像头&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ffmpeg -f avfoundation -i &quot;0&quot; -vcodec libx264  -f flv rtmp://localhost:1935/zbcs/room
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;加上声音&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ffmpeg -f avfoundation -i &quot;0:0&quot; -vcodec libx264  -acodec libmp3lame -ar 44100 -ac 1 -f flv rtmp://localhost:1935/zbcs/room
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;还可以设置频率和分辨率&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 设置帧率为30帧，图像大小为320x240
ffmpeg -f avfoundation -framerate 30 -video_size 320x240 -i &quot;0&quot; -vcodec libx264 -f flv rtmp://localhost:1935/zbcs/room
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果要实现电脑屏幕和摄像头一起直播&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ffmpeg -f avfoundation  -framerate 30 -i &quot;1:0&quot; -f avfoundation -framerate 30 -video_size 320x240 -i &quot;0&quot; -vcodec libx264 -filter_complex 'overlay=main_w-overlay_w-10:main_h-overlay_h-10'  -acodec libmp3lame -ar 44100 -ac 1 -f flv rtmp://localhost:1935/zbcs/room
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><author><name>Ted</name></author><category term="基础" /><summary type="html">1、安装Nginx</summary></entry><entry><title type="html">UITableView实践(一):实现原理</title><link href="http://www.helloted.com/ios/2018/04/25/tableView_1/" rel="alternate" type="text/html" title="UITableView实践(一):实现原理" /><published>2018-04-25T20:00:00+08:00</published><updated>2018-04-25T20:00:00+08:00</updated><id>http://www.helloted.com/ios/2018/04/25/tableView_1</id><content type="html" xml:base="http://www.helloted.com/ios/2018/04/25/tableView_1/">&lt;h3 id=&quot;一综述&quot;&gt;一、综述&lt;/h3&gt;

&lt;p&gt;UITableView应该是iOS中最经典也是最常见的一个控件了。使用很普遍&lt;/p&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;UITableView&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tableView&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UITableView&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;initWithFrame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;frame&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;style&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UITableViewStyleGrouped&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;   
&lt;span class=&quot;n&quot;&gt;tableView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delegate&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tableView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dataSource&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tableView&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;registerClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UITableViewCell&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;forCellReuseIdentifier&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;MyCellReuseIdentifier&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addSubview&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tableView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

&lt;span class=&quot;cp&quot;&gt;#pragma mark - UITableViewDelegate
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// 行高
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CGFloat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;tableView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UITableView&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;tableView&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;heightForRowAtIndexPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSIndexPath&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;indexPath&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;cp&quot;&gt;#pragma mark - UITableViewDataSource
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// Cell复用
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UITableViewCell&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;tableView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UITableView&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;tableView&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;cellForRowAtIndexPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSIndexPath&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;indexPath&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;UITableViewCell&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tableView&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;dequeueReusableCellWithIdentifier&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;MyCellReuseIdentifier&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 行数
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSInteger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;tableView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UITableView&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;tableView&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;numberOfRowsInSection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSInteger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;section&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dataArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;chameleon项目&quot;&gt;&lt;a href=&quot;https://github.com/BigZaphod/Chameleon&quot;&gt;Chameleon&lt;/a&gt;项目&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;If you’re an iOS developer, you’re already familiar with UIKit, the framework used to create apps for the iPhone, iPod and iPad. Chameleon is a drop in replacement for UIKit that runs on Mac OS X. In many cases, your iOS code doesn’t need to change at all in order to run on a Mac.&lt;/p&gt;

  &lt;p&gt;This new framework is a clean room implementation of the work done by Apple for iOS. The only thing Chameleon has in common with UIKit are the public class and method names. The code is based on Apple’s documentation and does not use any private APIs or other techniques disallowed by the Mac App Store.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们知道在iOS上开发的视图使用UIKit，Mac OS则没有。Chameleon项目就是将UIKit的代码也可以运行在macOS上。我们可以通过Chameleon项目的源码来一探究竟，UITableView是如何实现的。&lt;/p&gt;

&lt;h3 id=&quot;二初始化&quot;&gt;二、初始化&lt;/h3&gt;

&lt;h4 id=&quot;1init&quot;&gt;1、init&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;initWithFrame:(CGRect)frame style:(UITableViewStyle)theStyle&lt;/code&gt;是最常用的初始化方式，那么Chameleon项目是怎么做的呢？&lt;/p&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;initWithFrame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CGRect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;frame&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;style&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UITableViewStyle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;theStyle&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;initWithFrame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;frame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_style&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;theStyle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
       &lt;span class=&quot;c1&quot;&gt;// 已生成Cell的缓存
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;_cachedCells&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSMutableDictionary&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
       &lt;span class=&quot;c1&quot;&gt;// Secitons的缓存
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;_sections&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSMutableArray&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
       &lt;span class=&quot;c1&quot;&gt;// 复用的Cells
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;_reusableCells&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSMutableSet&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

      	&lt;span class=&quot;c1&quot;&gt;// 一些基本属性的初始化
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;separatorColor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UIColor&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;colorWithRed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;88&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;green&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;88&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;88&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alpha&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;separatorStyle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UITableViewCellSeparatorStyleSingleLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;showsHorizontalScrollIndicator&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;allowsSelection&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;YES&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;allowsSelectionDuringEditing&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sectionHeaderHeight&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sectionFooterHeight&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;22&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;alwaysBounceVertical&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;YES&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_style&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UITableViewStylePlain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;backgroundColor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UIColor&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;whiteColor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        
      	&lt;span class=&quot;c1&quot;&gt;// setNeedsLayout
&lt;/span&gt;        &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;_setNeedsReload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_setNeedsReload&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_needsReload&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;YES&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setNeedsLayout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;初始化大概分为三部分：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用来装载实例的容器初始化&lt;/li&gt;
  &lt;li&gt;基本属性的默认值赋值&lt;/li&gt;
  &lt;li&gt;标记需要&lt;code class=&quot;highlighter-rouge&quot;&gt;setNeedsLayout&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们知道，iOS的交互流程是这样的&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_3/15.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;所以，接下来就是&lt;code class=&quot;highlighter-rouge&quot;&gt;layoutSubviews&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;2layoutsubviews&quot;&gt;2、layoutSubviews&lt;/h4&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layoutSubviews&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_backgroundView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;frame&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bounds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;_reloadDataIfNeeded&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;_layoutTableView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;layoutSubviews&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_7/20.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;reloadData&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reloadData&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// clear the caches and remove the cells since everything is going to change
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_cachedCells&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;allValues&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;makeObjectsPerformSelector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;@selector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;removeFromSuperview&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_reusableCells&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;makeObjectsPerformSelector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;@selector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;removeFromSuperview&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_reusableCells&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;removeAllObjects&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_cachedCells&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;removeAllObjects&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// clear prior selection
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;_selectedRow&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_highlightedRow&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;// trigger the section cache to be repopulated
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;_updateSectionsCache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;_setContentSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    
    &lt;span class=&quot;n&quot;&gt;_needsReload&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;因为需要重新加载数据，所以将缓存以及复用的Cell都清空掉，SectionsCache也更新掉&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;layoutTableView&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_layoutTableView&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// lays out headers and rows that are visible at the time. this should also do cell
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// dequeuing and keep a list of all existing cells that are visible and those
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// that exist but are not visible and are reusable
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// if there's no section cache, no rows will be laid out but the header/footer will (if any).
&lt;/span&gt;    
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CGSize&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;boundsSize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bounds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CGFloat&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contentOffset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contentOffset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CGRect&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visibleBounds&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CGRectMake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contentOffset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;boundsSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;boundsSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;CGFloat&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tableHeight&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_tableHeaderView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;CGRect&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tableHeaderFrame&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_tableHeaderView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;frame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;tableHeaderFrame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;origin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CGPointZero&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;tableHeaderFrame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;width&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;boundsSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_tableHeaderView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;frame&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tableHeaderFrame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;tableHeight&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tableHeaderFrame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;// layout sections and rows
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;NSMutableDictionary&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;availableCells&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_cachedCells&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;mutableCopy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSInteger&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numberOfSections&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_sections&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_cachedCells&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;removeAllObjects&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSInteger&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;section&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;section&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numberOfSections&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;section&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;CGRect&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sectionRect&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;rectForSection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;section&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;tableHeight&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sectionRect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CGRectIntersectsRect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sectionRect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visibleBounds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CGRect&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;headerRect&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;rectForHeaderInSection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;section&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CGRect&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;footerRect&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;rectForFooterInSection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;section&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;UITableViewSection&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sectionRecord&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_sections&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;objectAtIndex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;section&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSInteger&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numberOfRows&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sectionRecord&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numberOfRows&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sectionRecord&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;headerView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;sectionRecord&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;headerView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;frame&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;headerRect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sectionRecord&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;footerView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;sectionRecord&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;footerView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;frame&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;footerRect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSInteger&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numberOfRows&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;NSIndexPath&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;indexPath&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSIndexPath&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;indexPathForRow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;row&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;inSection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;section&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;CGRect&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rowRect&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;rectForRowAtIndexPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;indexPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CGRectIntersectsRect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rowRect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;visibleBounds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rowRect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;height&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;UITableViewCell&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;availableCells&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;objectForKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;indexPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;?:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dataSource&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;tableView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;cellForRowAtIndexPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;indexPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_cachedCells&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;forKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;indexPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
                        &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;availableCells&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;removeObjectForKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;indexPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;highlighted&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_highlightedRow&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isEqual&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;indexPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;selected&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_selectedRow&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isEqual&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;indexPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;frame&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rowRect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;backgroundColor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;backgroundColor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                        &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;_setSeparatorStyle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_separatorStyle&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_separatorColor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
                        &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addSubview&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
                    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;// remove old cells, but save off any that might be reusable
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UITableViewCell&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;availableCells&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;allValues&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reuseIdentifier&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_reusableCells&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;removeFromSuperview&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;// non-reusable cells should end up dealloced after at this point, but reusable ones live on in _reusableCells.
&lt;/span&gt;    
    &lt;span class=&quot;c1&quot;&gt;// now make sure that all available (but unused) reusable cells aren't on screen in the visible area.
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// this is done becaue when resizing a table view by shrinking it's height in an animation, it looks better. The reason is that
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// when an animation happens, it sets the frame to the new (shorter) size and thus recalcuates which cells should be visible.
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// If it removed all non-visible cells, then the cells on the bottom of the table view would disappear immediately but before
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// the frame of the table view has actually animated down to the new, shorter size. So the animation is jumpy/ugly because
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// the cells suddenly disappear instead of seemingly animating down and out of view like they should. This tries to leave them
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// on screen as long as possible, but only if they don't get in the way.
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;NSArray&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;allCachedCells&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_cachedCells&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;allValues&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UITableViewCell&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_reusableCells&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CGRectIntersectsRect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;frame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;visibleBounds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;allCachedCells&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;containsObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;removeFromSuperview&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_tableFooterView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;CGRect&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tableFooterFrame&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_tableFooterView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;frame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;tableFooterFrame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;origin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CGPointMake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tableHeight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;tableFooterFrame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;width&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;boundsSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_tableFooterView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;frame&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tableFooterFrame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这一步操作主要是将已经初始化的Cells重新布局，以及其他布局如HeadView，FootView的设置&lt;/p&gt;

&lt;h3 id=&quot;三cell复用&quot;&gt;三、Cell复用&lt;/h3&gt;

&lt;p&gt;cell在初始化的时候会绑定一个Identifier用以以后复用&lt;/p&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;initWithStyle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UITableViewCellStyle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;style&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;reuseIdentifier&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;reuseIdentifier&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;initWithFrame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CGRectMake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;320&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_UITableViewDefaultRowHeight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_style&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;style&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_reuseIdentifier&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reuseIdentifier&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如上文，在UITableView初始化的时候，会初始化一个空的集合用来装载可复用的Cell。这是一个可变的集合&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objc&quot;&gt;_reusableCells = [[NSMutableSet alloc] init];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在UITableView重载数据&lt;code class=&quot;highlighter-rouge&quot;&gt;reloadData&lt;/code&gt;时，会将里面的cell清空&lt;/p&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_reusableCells&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;makeObjectsPerformSelector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;@selector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;removeFromSuperview&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_reusableCells&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;removeAllObjects&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在TableView滑动或者做了其他更新布局&lt;code class=&quot;highlighter-rouge&quot;&gt;layoutTableView&lt;/code&gt;，将绑定了Identifier的cell装入集合以便复用&lt;/p&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;c1&quot;&gt;// remove old cells, but save off any that might be reusable
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UITableViewCell&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;availableCells&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;allValues&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reuseIdentifier&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_reusableCells&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;removeFromSuperview&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下面是UITableview数据源协议的复用代码&lt;/p&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UITableViewCell&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;tableView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UITableView&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;tableView&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;cellForRowAtIndexPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSIndexPath&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;indexPath&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;UITableViewCell&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tableView&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;dequeueReusableCellWithIdentifier&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;MyCellReuseIdentifier&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;根据Identifier将cell从集合中取出&lt;/p&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UITableViewCell&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;dequeueReusableCellWithIdentifier&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;identifier&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UITableViewCell&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_reusableCells&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reuseIdentifier&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isEqualToString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;identifier&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;UITableViewCell&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strongCell&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            
            &lt;span class=&quot;c1&quot;&gt;// the above strongCell reference seems totally unnecessary, but without it ARC apparently
&lt;/span&gt;            &lt;span class=&quot;c1&quot;&gt;// ends up releasing the cell when it's removed on this line even though we're referencing it
&lt;/span&gt;            &lt;span class=&quot;c1&quot;&gt;// later in this method by way of the cell variable. I do not like this.
&lt;/span&gt;            &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_reusableCells&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;removeObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strongCell&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;cell复用的三个容器&quot;&gt;Cell复用的三个容器&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSMutableDictionary&lt;/code&gt; 类型 &lt;strong&gt;_cachedCells&lt;/strong&gt;：用来存储当前屏幕上所有 Cell 与其对应的 indexPath。以键值对的关系进行存储。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSMutableDictionary&lt;/code&gt; 类型 &lt;strong&gt;availableCells&lt;/strong&gt;：当列表发生滑动的时候，部分 Cell 从屏幕移出，这个容器会对 &lt;code class=&quot;highlighter-rouge&quot;&gt;_cachedCells&lt;/code&gt; 进行拷贝，然后将屏幕上此时的 Cell 全部去除。即最终取出所有退出屏幕的 Cell。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSMutableSet&lt;/code&gt; 类型 &lt;strong&gt;_reusableCells&lt;/strong&gt;：用来收集曾经出现过此时未出现在屏幕上的 Cell。当再出滑入主屏幕时，则直接使用其中的对象根据 &lt;code class=&quot;highlighter-rouge&quot;&gt;CGRectIntersectsRect&lt;/code&gt; Rect 碰撞试验进行复用。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_7/21.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当到状态 ② 的时候，我们发现 &lt;code class=&quot;highlighter-rouge&quot;&gt;_reusableCells&lt;/code&gt; 容器中，已经出现了状态 ① 中已经退出屏幕的 Cell 0。而当我们重新将 Cell 0 滑入界面的时候，在系统 &lt;code class=&quot;highlighter-rouge&quot;&gt;addView&lt;/code&gt; 渲染阶段，会直接将 &lt;code class=&quot;highlighter-rouge&quot;&gt;_reusableCells&lt;/code&gt; 中的 Cell 0 立即取出进行渲染，从而代替创建新的实例再进行渲染，简化了时间与性能上的开销。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;https://github.com/BigZaphod/Chameleon&lt;/p&gt;

&lt;p&gt;http://www.desgard.com/TableView-Reuse/&lt;/p&gt;</content><author><name>Ted</name></author><category term="iOS" /><summary type="html">一、综述</summary></entry><entry><title type="html">Objective-C对象引用</title><link href="http://www.helloted.com/ios/2018/04/14/reference/" rel="alternate" type="text/html" title="Objective-C对象引用" /><published>2018-04-14T20:00:00+08:00</published><updated>2018-04-14T20:00:00+08:00</updated><id>http://www.helloted.com/ios/2018/04/14/reference</id><content type="html" xml:base="http://www.helloted.com/ios/2018/04/14/reference/">&lt;h3 id=&quot;一引用&quot;&gt;一、引用&lt;/h3&gt;

&lt;p&gt;引用是iOS内存管理中的重要知识点，总所周知，iOS对象的内存管理是使用引用计数来表示的。一个对象只有在它的所有强引用都被释放后才能被回收。因此，一个对象的生命周期取决于其强引用的所有者。在某些情况下，这种行为可能并不理想。您可能想要引用一个对象而不妨碍对象本身的回收。对于这种情况，您可以获取一个“弱”引用。弱引用是通过存储一个指向对象的指针创建的，而不是保留对象。&lt;/p&gt;

&lt;p&gt;强引用(持有对象Retain)：当前对象被其他对象引用时，会执行retain操作，引用计数器+1。所以只要有一个强引用，当前对象就不可能被释放，RootViewController、NavgationController、TabbarContrller都会对ViewCoontrller进行强引用，addSubView会导致对子View的强引用，属性成员变量如果修饰符是Strong也是强引用。&lt;/p&gt;

&lt;p&gt;弱引用：不会修改引用计数，不论有多少弱引用，该释放就释放，而且weak指针在被释放的时候还会被置为nil，防止野指针的出现&lt;/p&gt;

&lt;h4 id=&quot;weak-引用原理&quot;&gt;weak 引用原理：&lt;/h4&gt;

&lt;p&gt;1、初始化时：runtime会调用objc_initWeak函数，初始化一个新的weak指针指向对象的地址。&lt;/p&gt;

&lt;p&gt;2、添加引用时：objc_initWeak函数会调用 objc_storeWeak() 函数， objc_storeWeak() 的作用是更新指针指向，创建对应的弱引用表。&lt;/p&gt;

&lt;p&gt;3、释放时，调用clearDeallocating函数。clearDeallocating函数首先根据对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中的数据设为nil，最后把这个entry从weak表中删除，最后清理对象的记录。&lt;/p&gt;

&lt;h3 id=&quot;二循环引用&quot;&gt;二、循环引用&lt;/h3&gt;

&lt;p&gt;对象 A 和对象 B，相互引用了对方作为自己的成员变量，只有当自己销毁时，才会将成员变量的引用计数减 1。因为对象 A 的销毁依赖于对象 B 销毁，而对象 B 的销毁与依赖于对象 A 的销毁，这样就造成了我们称之为循环引用（Reference Cycle）。循环引用比较容易出现在Block、Timer引用中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_7/17.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;打破循环引用很简单，将其中一个指针改为弱引用&lt;/p&gt;

&lt;h4 id=&quot;三nstimer引起的循环引用&quot;&gt;三、NSTimer引起的循环引用&lt;/h4&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DetailViewController&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weak&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSTimer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DetailViewController&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IBAction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;fireButtonPressed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;sender&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_timer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSTimer&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;scheduledTimerWithTimeInterval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;
                                              &lt;span class=&quot;nf&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;
                                            &lt;span class=&quot;nl&quot;&gt;selector:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;@selector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timerFire&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                                            &lt;span class=&quot;nl&quot;&gt;userInfo:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;nil&lt;/span&gt;
                                             &lt;span class=&quot;nl&quot;&gt;repeats:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;YES&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_timer&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;timerFire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;userinfo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;NSLog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;Fire&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当我们从这个界面跳转到其他界面的时候却发现：控制台还在源源不断的输出着 Fire 。看来 &lt;code class=&quot;highlighter-rouge&quot;&gt;Timer&lt;/code&gt; 并没有停止。ViewController的dealloc也未被调用。&lt;/p&gt;

&lt;p&gt;为什么ViewController对timer是弱引用，还是不行？&lt;/p&gt;

&lt;p&gt;原因是&lt;code class=&quot;highlighter-rouge&quot;&gt;Timer&lt;/code&gt; 添加到 &lt;code class=&quot;highlighter-rouge&quot;&gt;Runloop&lt;/code&gt; 的时候，会被 &lt;code class=&quot;highlighter-rouge&quot;&gt;Runloop&lt;/code&gt; 强引用，Timer对Self进行强引用，导致ViewController得不到释放。&lt;/p&gt;

&lt;p&gt;那么换成weakSelf呢？就是我们在block中常用的那种。&lt;/p&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;__weak&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;typeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weakSelf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;_timer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSTimer&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;scheduledTimerWithTimeInterval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;
                                          &lt;span class=&quot;nf&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;weakSelf&lt;/span&gt;
                                        &lt;span class=&quot;n&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;@selector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timerFire&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                                        &lt;span class=&quot;n&quot;&gt;userInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;nil&lt;/span&gt;
                                         &lt;span class=&quot;n&quot;&gt;repeats&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;YES&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;实际运行发现，还是不行，说明target就是强引用。&lt;/p&gt;

&lt;h4 id=&quot;解决方案&quot;&gt;解决方案&lt;/h4&gt;

&lt;p&gt;使用一个中间target给timer，不让timer直接强引用VC。&lt;/p&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HTWeakTimer&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSTimer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;timer&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;performSelector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;selector&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;withObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;userInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timer&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;invalidate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;


&lt;span class=&quot;k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSTimer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;scheduledTimerWithTimeInterval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSTimeInterval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;interval&lt;/span&gt;
                                      &lt;span class=&quot;nf&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;aTarget&lt;/span&gt;
                                    &lt;span class=&quot;nf&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SEL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;aSelector&lt;/span&gt;
                                    &lt;span class=&quot;nf&quot;&gt;userInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;userInfo&lt;/span&gt;
                                     &lt;span class=&quot;nf&quot;&gt;repeats&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BOOL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;repeats&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;HTWeakTimer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timerTarget&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HTWeakTimer&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;timerTarget&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;aTarget&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;timerTarget&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;selector&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;aSelector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;timerTarget&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSTimer&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;scheduledTimerWithTimeInterval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;interval&lt;/span&gt;
                                                         &lt;span class=&quot;nf&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timerTarget&lt;/span&gt;
                                                       &lt;span class=&quot;nl&quot;&gt;selector:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;@selector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fire&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                                                       &lt;span class=&quot;nl&quot;&gt;userInfo:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;userInfo&lt;/span&gt;
                                                        &lt;span class=&quot;nl&quot;&gt;repeats:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;repeats&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timerTarget&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;四如何objc_setassociatedobject关联weak属性&quot;&gt;四、如何objc_setAssociatedObject关联weak属性&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OBJC_ASSOCIATION_ASSIGN&lt;/code&gt; 不会在属性清空后将引用指针清空，这会造成野指针，所以是由风险去访问一个已经被清除的对象的。但是我们可以用另外的一种方法来关联一个weak属性，那就是强关联一个对象，然后让这个对象来弱引用这个属性。&lt;/p&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;WeakObjectContainer&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NSObject&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readonly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weak&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;WeakObjectContainer&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;instancetype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;initWithObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;object&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;_object&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;把WeakObjectContainer对象用OBJC_ASSOCIATION_RETAIN_NONATOMIC强关联&lt;/p&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;objc_setAssociatedObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MyKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WeakObjectContainer&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;initWithObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OBJC_ASSOCIATION_RETAIN_NONATOMIC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;取&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objc&quot;&gt;id object = [objc_getAssociatedObject(self, &amp;amp;MyKey) object];
&lt;/code&gt;&lt;/pre&gt;</content><author><name>Ted</name></author><category term="iOS" /><summary type="html">一、引用</summary></entry><entry><title type="html">OpenGL ES实践</title><link href="http://www.helloted.com/ios/2018/04/02/opengles_1/" rel="alternate" type="text/html" title="OpenGL ES实践" /><published>2018-04-02T20:00:00+08:00</published><updated>2018-04-02T20:00:00+08:00</updated><id>http://www.helloted.com/ios/2018/04/02/opengles_1</id><content type="html" xml:base="http://www.helloted.com/ios/2018/04/02/opengles_1/">&lt;h3 id=&quot;一概念简介&quot;&gt;一、概念简介&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;GPU&lt;/strong&gt;：能够结合几何、颜色、灯光和其他数据而产生一个屏幕图像的硬件组件&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;渲染&lt;/strong&gt;：把程序提供的几何数据转换成屏幕上的图像的过程叫做渲染，渲染的结果保存在帧缓存中&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;像素&lt;/strong&gt;：计算机上显示的图片都是由矩形的颜色点组成，这些颜色点叫做像素，每个像素都是由3个颜色元素组成的，一个红点、一个绿点和一个蓝点、RGB&lt;/p&gt;

&lt;h4 id=&quot;缓存&quot;&gt;缓存&lt;/h4&gt;

&lt;p&gt;OpenGL ES部分运行在CPU上，部分运行在GPU上，协调两个内存区域之间的数据交换，而OpenGL ES为两个内存区域间的数据交换定义了缓存(buffers)的概念，缓存是指图形处理器能够控制和管理的连续RAM。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;OpenGL ES为缓存提供数据的7个步骤：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1、生成glGenBuffers()——请求OpenGL ES为图形处理器控制的缓存生成一个独一无二的标识符。&lt;/p&gt;

&lt;p&gt;2、绑定glBindBuffer()——告诉OpenGL ES为接下来的运算使用一个缓存。&lt;/p&gt;

&lt;p&gt;3、缓冲数据glBufferData()或glBufferSubData()——让OpenGL ES为当前绑定的缓存分配病初始化足够的连续内存（通常是从CPU控制的内存复制数据到分配的内存）。&lt;/p&gt;

&lt;p&gt;4、启用或者禁止glEnableVertexAttribArray()或glDisVertexAttribArray()——告诉OpenGL ES在接下来的渲染中是否使用缓存中的数据。&lt;/p&gt;

&lt;p&gt;5、设置指针glVertexAttribPointer()——告诉OpenGL ES在缓存中的数据的类型和所有需要访问的数据的内存偏移值。&lt;/p&gt;

&lt;p&gt;6、绘制glDrawArrays()或glDrawElements()——告诉OpenGL ES使用当前绑定并启用的缓冲中的数据渲染整个场景或者某个场景的一部分。&lt;/p&gt;

&lt;p&gt;7、删除glDeleteBuffers()——告诉OpenGL ES删除以前生成的缓存病释放相关的资源。&lt;/p&gt;

&lt;h4 id=&quot;帧缓存&quot;&gt;帧缓存&lt;/h4&gt;

&lt;p&gt;GPU需要知道应该在内存中那个位置存储渲染出来的2D图像像素数据，接受渲染结果的缓存区叫做帧缓存。&lt;/p&gt;

&lt;p&gt;屏幕显示像素受到保存在前帧缓存中的像素颜色元素控制，所以程序和操作系统不会直接渲染到前帧缓存中，因为那样会让用户看到还没渲染完成的图像。而是，把渲染结果保存到后帧缓存中，当后帧缓存包含一个&lt;strong&gt;完成&lt;/strong&gt;的图像，前后帧缓存瞬间切换，这样就呈现了新的图像。在iOS系统中，这些操作由系统之家完成，应用不能插手。Core Animation会把多个层（应用的层，系统的层比如状态栏）混合起来并在后帧缓存中产生最终的颜色，然后切换缓存。&lt;/p&gt;

&lt;h3 id=&quot;二ios的图像架构&quot;&gt;二、iOS的图像架构&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_6/20.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而在iOS 8之后，苹果推出了metal框架用来取代OpenGL&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_6/21.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;关于Core Graphics和OpenGL ES之间的关系：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当图像是要显示到屏幕上的时候，OpenGL ES是Core Graphics的底层，用于连接硬件&lt;/li&gt;
  &lt;li&gt;而如果是离屏渲染，用于生成PDF和图片文件，Core Graphics则是与OpenGL ES处于并列关系&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Yes, on iOS Core Graphics (Quartz) appears to be layered on top of OpenGL ES for drawing that targets the screen, although not in an explicit way that we have access to.&lt;/p&gt;

  &lt;p&gt;Core Graphics takes vector elements (lines, arcs, etc.) and some raster ones (images) and processes them for display to the screen or for other forms of output (PDF files, printing, etc.). If the target is the screen on iOS, those vector elements will be hosted in a CALayer, either directly or through the backing layer of a UIView.&lt;/p&gt;

  &lt;p&gt;These Core Animation layers are effectively wrappers around rectangular textures on the GPU, which is how Core Animation can provide the smooth translation, scaling, and rotation of layers on even the original iPhone hardware. I can’t find a reference for it right now, but at least one WWDC presentation states that OpenGL ES is used by Core Animation to communicate with the GPU to perform this hardware acceleration. Something similar can be observed on the new dual-GPU MacBook Pros, where the more powerful GPU kicks in when interacting with an application using Core Animation.&lt;/p&gt;

  &lt;p&gt;Because Core Graphics rasterizes the vector and raster elements into a CALayer when drawing to the screen, and a CALayer effectively wraps around an OpenGL ES texture, I would place OpenGL ES below Core Graphics on iOS, but only for the case where Core Graphics is rendering to the screen. The reason for the side-by-side placement in the hierarchy you saw may be due to three factors: on the Mac, not all views are layer-backed, so they may not be hardware accelerated in the same way; we can’t really interact with the OpenGL ES backing of standard UI elements, so from a developer’s point of view they are distinct concepts; and Core Graphics can be used to render to offscreen contexts, like PDF files or images.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;引自&lt;a href=&quot;https://stackoverflow.com/questions/7558636/ios-is-core-graphics-implemented-on-top-of-opengl&quot;&gt;iOS: is Core Graphics implemented on top of OpenGL?&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;三helloworld&quot;&gt;三、HelloWorld&lt;/h3&gt;

&lt;h4 id=&quot;1渲染整个context的背景色&quot;&gt;1、渲染整个context的背景色&lt;/h4&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;viewDidLoad&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;viewDidLoad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;GLKView&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;glkView&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GLKView&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;glkView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EAGLContext&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;initWithAPI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kEAGLRenderingAPIOpenGLES2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;glkView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;drawableColorFormat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLKViewDrawableColorFormatRGBA8888&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;glkView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;drawableDepthFormat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLKViewDrawableDepthFormat24&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;c1&quot;&gt;//将此“EAGLContext”实例设置为OpenGL的“当前激活”的“Context”。这样，以后所有“GL”的指令均作用在这个“Context”上。
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EAGLContext&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setCurrentContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;glkView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;glkView&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GLKView&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;drawInRect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CGRect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rect&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 指定刷新整个context颜色缓冲区时所用的颜色，RGBA
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;glClearColor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;// 刷新缓存区
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// GL_COLOR_BUFFER_BIT:    当前可写的颜色缓冲
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// GL_DEPTH_BUFFER_BIT:    深度缓冲
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// GL_ACCUM_BUFFER_BIT:    累积缓冲
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// GL_STENCIL_BUFFER_BIT:  模板缓冲
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;glClear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GL_COLOR_BUFFER_BIT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GL_DEPTH_BUFFER_BIT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如图所示，可以将整个背景渲染成蓝色&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_6/23.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;解释&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;drawableColorFormat&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;你的OpenGL上下文有一个缓冲区，它用以存储将在屏幕中显示的颜色。你可以使用其属性来设置缓冲区中每个像素的颜色格式。缺省值是GLKViewDrawableColorFormatRGBA8888，即缓冲区的每个像素的最小组成部分(-个像素有四个元素组成 RGBA)使用8个bit(如R使用8个bit)（所以每个像素4个字节 既 4*8 个bit）。这非常好，因为它给了你提供了最广泛的颜色范围，让你的app看起来更好。但是如果你的app允许更小范围的颜色，你可以设置为GLKViewDrawableColorFormatRGB565，从而使你的app消耗更少的资源（内存和处理时间）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;drawableDepthFormat&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;你的OpenGL上下文还可以（可选地）有另一个缓冲区，称为深度缓冲区。这帮助我们确保更接近观察者的对象显示在远一些的对象的前面（意思就是离观察者近一些的对象会挡住在它后面的对象）。其缺省的工作方式是：OpenGL把接近观察者的对象的所有像素存储到深度缓冲区，当开始绘制一个像素时，它（OpenGL）首先检查深度缓冲区，看是否已经绘制了更接近观察者的什么东西，如果是则忽略它（要绘制的像素，就是说，在绘制一个像素之前，看看前面有没有挡着它的东西，如果有那就不用绘制了）。否则，把它增加到深度缓冲区和颜色缓冲区。你可以设置这个属性，以选择深度缓冲区的格式。缺省值是GLKViewDrawableDepthFormatNone，意味着完全没有深度缓冲区。但是如果你要使用这个属性（一般用于3D游戏），你应该选择GLKViewDrawableDepthFormat16或GLKViewDrawableDepthFormat24。这里的差别是使用GLKViewDrawableDepthFormat16将消耗更少的资源，但是当对象非常接近彼此时，你可能存在渲染问题。&lt;/p&gt;

&lt;h4 id=&quot;2渲染某个色块&quot;&gt;2、渲染某个色块&lt;/h4&gt;

&lt;p&gt;OpenGL ES的坐标系与Core Graphics的坐标系不一样，起点是在屏幕的中点，到两边是1&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_6/22.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;c1&quot;&gt;// 声明顶点数据
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;GLfloat&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vertexData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//顶点数据缓存
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//这几行代码表示的含义是：声明一个缓冲区的标识（GLuint类型）让OpenGL自动分配一个缓冲区并且返回这个标识的值绑定这个缓冲区到当前“Context”最后，将我们前面预先定义的顶点数据“vertexData”复制进这个缓冲区中。参数“GL_STATIC_DRAW”，它表示此缓冲区内容只能被修改一次，但可以无限次读取。
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;GLuint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;glGenBuffers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;glBindBuffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GL_ARRAY_BUFFER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;glBufferData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GL_ARRAY_BUFFER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vertexData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vertexData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GL_STATIC_DRAW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;// 激活顶点属性（默认它的关闭的）
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;glEnableVertexAttribArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GLKVertexAttribPosition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 填充顶点数据，顶点属性索引（这里是位置）、3个分量的矢量、类型是浮点（GL_FLOAT）、填充时不需要单位化（GL_FALSE）、在数据数组中每行的跨度是12个字节（4*3=12。从预定义的数组中可看出，每行有3个GL_FLOAT浮点值，而GL_FLOAT占4个字节，因此每一行的跨度是4*3），最后一个参数是一个偏移量的指针，用来确定“第一个数据”将从内存数据块的什么地方开始。
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;glVertexAttribPointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GLKVertexAttribPosition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GL_FLOAT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GL_FALSE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GLfloat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GLfloat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 着色器
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mEffect&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GLKBaseEffect&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 着色器的颜色
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mEffect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;constantColor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLKVector4Make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    
 &lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;glkView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GLKView&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;drawInRect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CGRect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;rect&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 指定刷新整个context颜色缓冲区时所用的颜色，RGBA
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;glClearColor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;// 刷新缓存区
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// GL_COLOR_BUFFER_BIT:    当前可写的颜色缓冲
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// GL_DEPTH_BUFFER_BIT:    深度缓冲
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// GL_ACCUM_BUFFER_BIT:    累积缓冲
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// GL_STENCIL_BUFFER_BIT:  模板缓冲
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;glClear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GL_COLOR_BUFFER_BIT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GL_DEPTH_BUFFER_BIT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    
   &lt;span class=&quot;c1&quot;&gt;//启动着色器
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mEffect&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;prepareToDraw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
   &lt;span class=&quot;c1&quot;&gt;// 画出三角形
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;glDrawArrays&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GL_TRIANGLES&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_6/24.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;</content><author><name>Ted</name></author><category term="iOS" /><summary type="html">一、概念简介</summary></entry><entry><title type="html">APP生成与运行(二)</title><link href="http://www.helloted.com/ios/2018/03/31/app-2/" rel="alternate" type="text/html" title="APP生成与运行(二)" /><published>2018-03-31T20:00:00+08:00</published><updated>2018-03-31T20:00:00+08:00</updated><id>http://www.helloted.com/ios/2018/03/31/app-2</id><content type="html" xml:base="http://www.helloted.com/ios/2018/03/31/app-2/">&lt;h3 id=&quot;一启动过程&quot;&gt;一、启动过程&lt;/h3&gt;

&lt;p&gt;iOS开发中，main函数是我们熟知的程序启动入口，但实际上并非真正意义上的入口，因为在我们运行程序，再到main方法被调用之间，程序已经做了许许多多的事情，比如我们熟知的runtime的初始化就发生在main函数调用前，还有程序动态库的加载链接也发生在这阶段。&lt;/p&gt;

&lt;p&gt;整个过程为：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;系统先读取App的可执行文件（Mach-O文件），从里面获得dyld的路径&lt;/li&gt;
  &lt;li&gt;加载dyld，dyld去初始化运行环境，开启缓存策略，加载程序相关依赖库(其中也包含我们的可执行文件)，并对这些库进行链接&lt;/li&gt;
  &lt;li&gt;调用每个依赖库的初始化方法&lt;/li&gt;
  &lt;li&gt;runtime被初始化&lt;/li&gt;
  &lt;li&gt;runtime对项目中所有类进行类结构初始化&lt;/li&gt;
  &lt;li&gt;调用所有的load方法&lt;/li&gt;
  &lt;li&gt;dyld返回main函数地址，main函数被调用&lt;/li&gt;
  &lt;li&gt;main函数调用&lt;/li&gt;
  &lt;li&gt;执行AppDelegate的代理方法，主要是&lt;code class=&quot;highlighter-rouge&quot;&gt;didFinishLaunchingWithOptions&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;初始化Window，初始化基础的ViewController结构&lt;/li&gt;
  &lt;li&gt;获取数据(Local DB／Network)，展示给用户&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;总体可以分为main函数调用之前和main函数调用之后。&lt;/p&gt;

&lt;h3 id=&quot;二main函数启动之前&quot;&gt;二、main函数启动之前&lt;/h3&gt;

&lt;h4 id=&quot;mach-o可执行文件&quot;&gt;Mach-O可执行文件&lt;/h4&gt;

&lt;p&gt;Mach-O文件格式是 OS X 与 iOS 系统上的可执行文件格式，像我们编译过程产生的.O文件，以及程序的可执行文件，动态库等都是Mach-O文件。有以下几种Mach-O&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Executable 可执行文件&lt;/li&gt;
  &lt;li&gt;Dylib 动态库&lt;/li&gt;
  &lt;li&gt;Bundle 库：无法被连接的动态库，只能通过dlopen()加载&lt;/li&gt;
  &lt;li&gt;Image ：指的是Executable，Dylib或者Bundle的一种，文中会多次使用Image这个名词。&lt;/li&gt;
  &lt;li&gt;Framework 库：动态库和对应的头文件和资源文件的集合&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Mach-O的结构如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_7/11.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Header 头部，包含可以执行的CPU架构，比如x86,arm64&lt;/li&gt;
  &lt;li&gt;Load commands 加载命令，包含文件的组织架构和在虚拟内存中的布局方式&lt;/li&gt;
  &lt;li&gt;Data，数据，包含load commands中需要的各个段(segment)的数据，每一个Segment都得大小是Page的整数倍。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;更多Mach-O可查看《&lt;a href=&quot;https://github.com/LeoMobileDeveloper/React-Native-Files/blob/master/Mac%20OS%20X%20ABI%20Mach-O%20File%20Format%20Reference.pdf&quot;&gt;Mac OS X ABI Mach-O File Format Reference&lt;/a&gt;》&lt;/p&gt;

&lt;p&gt;有两种方式可以查看一个APP动态调用的系统可执行文件&lt;/p&gt;

&lt;p&gt;1、通过&lt;a href=&quot;https://sourceforge.net/projects/machoview/?source=navbar&quot;&gt;machoview&lt;/a&gt;,选择APP的可执行文件，可以看到&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_7/12.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2、通过&lt;code class=&quot;highlighter-rouge&quot;&gt;otool -L&lt;/code&gt;命令行查看&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_7/13.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;dyld&quot;&gt;dyld&lt;/h4&gt;

&lt;p&gt;全程the dynamic loade，Apple 的动态链接器，系统 kernel 做好启动程序的初始准备后，交给 dyld 负责。&lt;/p&gt;

&lt;p&gt;2017年，苹果引入了Dyld 3.0，但是只有系统APP采用这个，第三方APP都是采用Dyld 2.0。&lt;/p&gt;

&lt;p&gt;Dyld 2.0的加载过程是：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_7/14.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;解析 mach-o 文件，找到其依赖的库，并且递归的找到所有依赖的库，形成一张动态库的依赖图。iOS 上的大部分 app 都依赖 300 到 600 个动态链接库，所以这个步骤包含了较大的工作量。&lt;/li&gt;
  &lt;li&gt;匹配 mach-o 文件到自身的地址空间；&lt;/li&gt;
  &lt;li&gt;进行符号查找：比如 app 中调用了 printf 方法，就需要去系统库中查找到 printf 的地址，然后将地址拷贝到 app 中的函数指针中；&lt;/li&gt;
  &lt;li&gt;绑定和变基：由于 app 需要让地址空间配置随机加载，所以所有的指针都需要加上一个基地址；&lt;/li&gt;
  &lt;li&gt;运行初始化程序（Runtime、+load、+initialize），之后运行 main() 函数。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;三优化启动时间&quot;&gt;三、优化启动时间&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;main函数之后&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这部分是主要的优化部分&lt;/p&gt;

&lt;h4 id=&quot;appdelegate&quot;&gt;Appdelegate&lt;/h4&gt;

&lt;p&gt;能延迟初始化的尽量延迟初始化，不能延迟初始化的尽量放到后台初始化。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;三方SDK初始化，比如Crash统计; 像分享之类的，可以等到第一次调用再出初始化。&lt;/li&gt;
  &lt;li&gt;初始化某些基础服务，比如WatchDog，远程参数。&lt;/li&gt;
  &lt;li&gt;启动相关日志，日志往往涉及到DB操作，一定要放到后台去做&lt;/li&gt;
  &lt;li&gt;业务方初始化，这个交由每个业务自己去控制初始化时间。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;启动业务的优化&quot;&gt;启动业务的优化&lt;/h4&gt;

&lt;p&gt;建一个类来管理初始化，所有需要初始化的代码都在这里进行，分类初始化：&lt;/p&gt;

&lt;p&gt;1)、日志 / 统计等需要第一时间启动的, 仍然伴随 didFinishLaunchingWithOptions 启动.&lt;/p&gt;

&lt;p&gt;2)、用户数据需要在广告显示完成以后使用, 所以需要伴随广告页启动。&lt;/p&gt;

&lt;p&gt;3)、比如分享业务, 肯定是用户能看到真正的主界面以后才需要启动, 所以推迟到主界面加载完成以后启动, 只需要将代码放到方法里。&lt;/p&gt;

&lt;h4 id=&quot;viewcontroller&quot;&gt;ViewController&lt;/h4&gt;

&lt;p&gt;延迟初始化那些不必要的&lt;code class=&quot;highlighter-rouge&quot;&gt;UIViewController&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&quot;用time-profiler找到元凶&quot;&gt;用Time Profiler找到元凶&lt;/h4&gt;

&lt;p&gt;Time Profiler在分析时间占用上非常强大。实用的时候注意三点&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在打包模式下分析（一般是Release）,这样和线上环境一样。&lt;/li&gt;
  &lt;li&gt;记得开启dsym，不然无法查看到具体的函数调用堆栈&lt;/li&gt;
  &lt;li&gt;分析性能差的设备，对于支持iOS 8的，一般分析iphone 4s或者iphone 5。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_7/15.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Main函数之前&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Main函数之前是iOS系统的工作，所以这部分的优化往往更具有通用性。&lt;/p&gt;

&lt;h4 id=&quot;dylibs&quot;&gt;dylibs&lt;/h4&gt;

&lt;p&gt;启动的第一步是加载动态库，加载系统的动态库使很快的，因为可以缓存，而加载内嵌的动态库速度较慢。所以，提高这一步的效率的关键是：&lt;strong&gt;减少动态库的数量&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;合并动态库，比如公司内部由私有Pod建立了如下动态库：XXTableView, XXHUD, XXLabel，强烈建议合并成一个XXUIKit来提高加载速度。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;rebase--bind--objective-c-runtime&quot;&gt;Rebase &amp;amp; Bind &amp;amp; Objective C Runtime&lt;/h4&gt;

&lt;p&gt;Rebase和Bind都是为了解决指针引用的问题。对于Objective C开发来说，主要的时间消耗在Class/Method的符号加载上，所以常见的优化方案是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;减少&lt;code class=&quot;highlighter-rouge&quot;&gt;__DATA&lt;/code&gt;段中的指针数量。&lt;/li&gt;
  &lt;li&gt;合并Category和功能类似的类。比如：UIView+Frame,UIView+AutoLayout…合并为一个&lt;/li&gt;
  &lt;li&gt;删除无用的方法和类。&lt;/li&gt;
  &lt;li&gt;多用Swift Structs，因为Swfit Structs是静态分发的。感兴趣的同学可以看看我之前这篇文章：《&lt;a href=&quot;http://blog.csdn.net/hello_hwc/article/details/53147910&quot;&gt;Swift进阶之内存模型和方法调度&lt;/a&gt;》&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;initializers&quot;&gt;Initializers&lt;/h4&gt;

&lt;p&gt;通常，我们会在&lt;code class=&quot;highlighter-rouge&quot;&gt;+load&lt;/code&gt;方法中进行method-swizzling，这也是&lt;a href=&quot;http://nshipster.com/method-swizzling/&quot;&gt;Nshipster&lt;/a&gt;推荐的方式。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用initialize替代load。不少同学喜欢用method-swizzling来实现AOP去做日志统计等内容，强烈建议改为在initialize进行初始化。&lt;/li&gt;
  &lt;li&gt;减少&lt;code class=&quot;highlighter-rouge&quot;&gt;__atribute__((constructor))&lt;/code&gt;的使用，而是在第一次访问的时候才用dispatch_once等方式初始化。&lt;/li&gt;
  &lt;li&gt;不要创建线程&lt;/li&gt;
  &lt;li&gt;使用Swfit重写代码。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;四ios-静态库动态库与-framework&quot;&gt;四、iOS 静态库，动态库与 Framework&lt;/h3&gt;

&lt;h4 id=&quot;静态库与动态库的区别&quot;&gt;静态库与动态库的区别&lt;/h4&gt;

&lt;p&gt;首先来看什么是库，库(Library)说白了就是一段编译好的二进制代码，加上头文件就可以供别人使用。&lt;/p&gt;

&lt;p&gt;什么时候我们会用到库呢？一种情况是某些代码需要给别人使用，但是我们不希望别人看到源码，就需要以库的形式进行封装，只暴露出头文件。另外一种情况是，对于某些不会进行大的改动的代码，我们想减少编译的时间，就可以把它打包成库，因为库是已经编译好的二进制了，编译的时候只需要 Link 一下，不会浪费编译时间。&lt;/p&gt;

&lt;p&gt;上面提到库在使用的时候需要 Link，Link 的方式有两种，静态和动态，于是便产生了静态库和动态库。&lt;/p&gt;

&lt;h4 id=&quot;静态库&quot;&gt;静态库&lt;/h4&gt;

&lt;p&gt;静态库即静态链接库（Windows 下的 .lib，Linux 和 Mac 下的 .a）。之所以叫做静态，是因为静态库在编译的时候会被直接拷贝一份，复制到目标程序里，这段代码在目标程序里就不会再改变了。&lt;/p&gt;

&lt;p&gt;静态库的好处很明显，编译完成之后，库文件实际上就没有作用了。目标程序没有外部依赖，直接就可以运行。当然其缺点也很明显，就是会使用目标程序的体积增大。&lt;/p&gt;

&lt;h4 id=&quot;动态库&quot;&gt;动态库&lt;/h4&gt;

&lt;p&gt;动态库即动态链接库（Windows 下的 .dll，Linux 下的 .so，Mac 下的 .dylib/.tbd）。与静态库相反，动态库在编译时并不会被拷贝到目标程序中，目标程序中只会存储指向动态库的引用。等到程序运行时，动态库才会被真正加载进来。&lt;/p&gt;

&lt;p&gt;动态库的优点是，不需要拷贝到目标程序中，不会影响目标程序的体积，而且同一份库可以被多个程序使用（因为这个原因，动态库也被称作&lt;strong&gt;共享库&lt;/strong&gt;）。同时，编译时才载入的特性，也可以让我们随时对库进行替换，而不需要重新编译代码。动态库带来的问题主要是，动态载入会带来一部分性能损失，使用动态库也会使得程序依赖于外部环境。如果环境缺少动态库或者库的版本不正确，就会导致程序无法运行（Linux 下喜闻乐见的 lib not found 错误）。&lt;/p&gt;

&lt;h4 id=&quot;ios-framework&quot;&gt;iOS Framework&lt;/h4&gt;

&lt;p&gt;除了上面提到的 .a 和 .dylib/.tbd 之外，Mac OS/iOS 平台还可以使用 Framework。Framework 实际上是一种打包方式，将库的二进制文件，头文件和有关的资源文件打包到一起，方便管理和分发。&lt;/p&gt;

&lt;p&gt;在 iOS 8 之前，iOS 平台不支持使用动态 Framework，开发者可以使用的 Framework 只有苹果自家的 UIKit.Framework，Foundation.Framework 等。这种限制可能是出于安全的考虑（见&lt;a href=&quot;https://stackoverflow.com/questions/4733847/can-you-build-dynamic-libraries-for-ios-and-load-them-at-runtime&quot;&gt;这里的讨论&lt;/a&gt;)。换一个角度讲，因为 iOS 应用都是运行在沙盒当中，不同的程序之间不能共享代码，同时动态下载代码又是被苹果明令禁止的，没办法发挥出动态库的优势，实际上动态库也就没有存在的必要了。&lt;/p&gt;

&lt;p&gt;由于上面提到的限制，开发者想要在 iOS 平台共享代码，唯一的选择就是打包成静态库 .a 文件，同时附上头文件（例如&lt;a href=&quot;https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;amp;t=resource/res_list&amp;amp;verify=1&amp;amp;id=open1419319164&amp;amp;token=&amp;amp;lang=zh_CN&quot;&gt;微信的SDK&lt;/a&gt;）。但是这样的打包方式不够方便，使用时也比较麻烦，大家还是希望共享代码都能能像 Framework 一样，直接扔到工程里就可以用。于是人们想出了各种奇技淫巧去让 Xcode Build 出 iOS 可以使用的 Framework，具体做法参考&lt;a href=&quot;https://github.com/kstenerud/iOS-Universal-Framework&quot;&gt;这里&lt;/a&gt;和&lt;a href=&quot;https://github.com/jverkoey/iOS-Framework&quot;&gt;这里&lt;/a&gt;，这种方法产生的 Framework 还有 “伪”(Fake) Framework 和 “真”(Real) Framework 的区别。&lt;/p&gt;

&lt;p&gt;iOS 8/Xcode 6 推出之后，iOS 平台添加了动态库的支持，同时 Xcode 6 也原生自带了 Framework 支持（动态和静态都可以），上面提到的的奇技淫巧也就没有必要了（新的做法参考&lt;a href=&quot;http://www.cocoachina.com/ios/20141126/10322.html&quot;&gt;这里&lt;/a&gt;）。为什么 iOS 8 要添加动态库的支持？唯一的理由大概就是 Extension 的出现。Extension 和 App 是两个分开的可执行文件，同时需要共享代码，这种情况下动态库的支持就是必不可少的了。但是这种动态 Framework 和系统的 UIKit.Framework 还是有很大区别。系统的 Framework 不需要拷贝到目标程序中，我们自己做出来的 Framework 哪怕是动态的，最后也还是要拷贝到 App 中（App 和 Extension 的 Bundle 是共享的），因此苹果又把这种 Framework 称为 &lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html&quot;&gt;Embedded Framework&lt;/a&gt;。&lt;/p&gt;

&lt;h4 id=&quot;swift-支持&quot;&gt;Swift 支持&lt;/h4&gt;

&lt;p&gt;跟着 iOS8 / Xcode 6 同时发布的还有 Swift。如果要在项目中使用外部的代码，可选的方式只有两种，一种是把代码拷贝到工程中，另一种是用动态 Framework。使用静态库是不支持的。&lt;/p&gt;

&lt;p&gt;造成这个问题的原因主要是 Swift 的运行库没有被包含在 iOS 系统中，而是会打包进 App 中（这也是造成 Swift App 体积大的原因），静态库会导致最终的目标程序中包含重复的运行库（这是&lt;a href=&quot;https://github.com/ksm/SwiftInFlux#static-libraries&quot;&gt;苹果自家的解释&lt;/a&gt;）。同时拷贝 Runtime 这种做法也会导致在纯 ObjC 的项目中使用 Swift 库出现问题。苹果声称等到 Swift 的 Runtime 稳定之后会被加入到系统当中，到时候这个限制就会被去除了（参考&lt;a href=&quot;https://stackoverflow.com/questions/25020783/how-to-distribute-swift-library-without-exposing-the-source-code&quot;&gt;这个问题&lt;/a&gt; 的问题描述，也是来自苹果自家文档）。&lt;/p&gt;

&lt;h4 id=&quot;cocoapods-的做法&quot;&gt;CocoaPods 的做法&lt;/h4&gt;

&lt;p&gt;在纯 ObjC 的项目中，CocoaPods 使用编译静态库 .a 方法将代码集成到项目中。在 Pods 项目中的每个 target 都对应这一个 Pod 的静态库。不过在编译过程中并不会真的产出 .a 文件。如果需要 .a 文件的话，可以参考&lt;a href=&quot;http://www.cnblogs.com/brycezhang/p/4117180.html&quot;&gt;这里&lt;/a&gt;，或者使用 &lt;a href=&quot;https://github.com/CocoaPods/cocoapods-packager&quot;&gt;CocoasPods-Packager&lt;/a&gt; 这个插件。&lt;/p&gt;

&lt;p&gt;当不想发布代码的时候，也可以使用 Framework 发布 Pod，CocoaPods 提供了 &lt;code class=&quot;highlighter-rouge&quot;&gt;vendored_framework&lt;/code&gt; 选项来使用第三方 Framework，具体的做法可以参考&lt;a href=&quot;http://www.telerik.com/blogs/how-to-use-a-third-party-framework-in-a-private-cocoapod&quot;&gt;这里&lt;/a&gt;和&lt;a href=&quot;https://stackoverflow.com/questions/18219286/podspec-link-binary-library&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;对于 Swift 项目，CocoaPods 提供了动态 Framework 的支持。通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;use_frameworks!&lt;/code&gt; 选项控制。对于 Swift 写的库来说，想通过 CocoaPods 引入工程，必须加入 &lt;code class=&quot;highlighter-rouge&quot;&gt;use_frameworks!&lt;/code&gt; 选项。具体原因参见上一节对于 Swift 部分的介绍。&lt;/p&gt;

&lt;p&gt;引用：&lt;/p&gt;

&lt;p&gt;https://blog.csdn.net/hello_hwc/article/details/78317863&lt;/p&gt;

&lt;p&gt;WWDC 2017: &lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2017/413/&quot;&gt;App Startup Time: Past, Present, and Future&lt;/a&gt;&lt;/p&gt;</content><author><name>Ted</name></author><category term="iOS" /><summary type="html">一、启动过程</summary></entry><entry><title type="html">APP生成与运行(一)</title><link href="http://www.helloted.com/ios/2018/03/29/app-1/" rel="alternate" type="text/html" title="APP生成与运行(一)" /><published>2018-03-29T20:00:00+08:00</published><updated>2018-03-29T20:00:00+08:00</updated><id>http://www.helloted.com/ios/2018/03/29/app-1</id><content type="html" xml:base="http://www.helloted.com/ios/2018/03/29/app-1/">&lt;h3 id=&quot;一编译&quot;&gt;一、编译&lt;/h3&gt;

&lt;h4 id=&quot;汇编&quot;&gt;汇编&lt;/h4&gt;

&lt;p&gt;CPU 由上亿个晶体管组成，在运行的时候，单个晶体管只能根据电流的流通或关闭来确认两种状态，我们一般说 0 或 1，根据这种状态，人类创造了二进制，通过二进制编码我们可以表示所有的概念。但是，CPU 依然只能执行二进制代码。我们将一组二进制代码合并成一个指令或符号，创造了汇编语言，汇编语言以一种相对好理解的方式来编写，然后通过汇编过程生成 CPU 可以运行的二进制代码并运行在 CPU 上。&lt;/p&gt;

&lt;h4 id=&quot;编译&quot;&gt;编译&lt;/h4&gt;

&lt;p&gt;编译器将原始程序（Source program）作为输入，翻译产生使用目标语言（Target language）的等价程序。源代码一般为高阶语言 (High-level language), 如C、C++、C# 、Objective-C、Swift、Java 等，而目标语言则是汇编语言或目标机器的目标代码（Object code），有时也称作机器代码（Machine code）&lt;/p&gt;

&lt;h4 id=&quot;编译型语言和解释型语言&quot;&gt;编译型语言和解释型语言&lt;/h4&gt;

&lt;p&gt;编译程序是整体编译完了，再一次性执行。 而解释程序是一边解释，一边执行。&lt;/p&gt;

&lt;p&gt;编译型语言：C系，java&lt;/p&gt;

&lt;p&gt;解释型语言：html、javascript&lt;/p&gt;

&lt;h3 id=&quot;二llvmclang&quot;&gt;二、LLVM、Clang&lt;/h3&gt;

&lt;h4 id=&quot;llvm&quot;&gt;LLVM&lt;/h4&gt;

&lt;p&gt;LLVM本身并不是编译器，只是一套用于开发编译器、解释器等程序语言相关工具的库，主要聚焦于编译器后端功能，如代码生成、代码优化、JIT等。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;LLVM&lt;a href=&quot;http://www.aosabook.org/en/llvm.html#footnote-1&quot;&gt;1&lt;/a&gt; an umbrella project that hosts and develops a set of close-knit low-level toolchain components (e.g., assemblers, compilers, debuggers, etc.)&lt;/p&gt;

  &lt;p&gt;LLVM 是一个涵盖和开发一系列紧密结合的低级工具链组件（例如，汇编器，编译器，调试器等）的综合项目&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;传统的编译器通常分为三个部分，前端(frontEnd)，优化器(Optimizer)和后端(backEnd)，在编译过程中，前端主要负责词法和语法分析，将源代码转化为抽象语法树；优化器则是在前端的基础上，对得到的中间代码进行优化，使代码更加高效；后端则是将已经优化的中间代码转化为针对各自平台的机器代码。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_7/05.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;clang&quot;&gt;Clang&lt;/h4&gt;

&lt;p&gt;Clang 是一个C、C++、Objective-C和Objective-C++编程语言的编译器前端。它采用了LLVM作为其后端。&lt;/p&gt;

&lt;p&gt;Clang是2005年由苹果电脑发起，是LLVM编译器工具集的前端（front-end），目的是输出代码对应的抽象语法树（Abstract Syntax Tree, AST），并将代码编译成LLVM Bitcode。接着在后端（back-end）使用LLVM编译成平台相关的机器语言 。Clang支持C、C++、Objective C。&lt;/p&gt;

&lt;p&gt;Clang本身性能优异，其生成的AST所耗用掉的内存仅仅是GCC的20%左右，测试证明Clang编译Objective-C代码时速度为GCC的3倍，还能针对用户发生的编译错误准确地给出建议。&lt;/p&gt;

&lt;h3 id=&quot;三ios中的编译&quot;&gt;三、iOS中的编译&lt;/h3&gt;

&lt;p&gt;Objective C采用Clang作为前端，而Swift则采用swift()作为前端，二者LLVM(Low level vritual machine)作为编译器后端。编译过程如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_7/06.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;来看看一个文件的编译过程，新建Test.m&lt;/p&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;@autoreleasepool&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;NSLog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;%@&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;Hello Leo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在终端输入：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;clang -ccc-print-phases -framework Foundation test.m -o test
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;会看到下列的：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0: input, &lt;span class=&quot;s2&quot;&gt;&quot;Foundation&quot;&lt;/span&gt;, object 
1: input, &lt;span class=&quot;s2&quot;&gt;&quot;test.m&quot;&lt;/span&gt;, objective-c
2: preprocessor, &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;1&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;, objective-c-cpp-output//预处理
3: compiler, &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;2&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;, ir //编译生成IR&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;中间代码&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
4: backend, &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;3&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;, assembler//汇编器生成汇编代码
5: assembler, &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;4&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;, object//生成机器码
6: linker, &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;0, 5&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;, image//链接
7: &lt;span class=&quot;nb&quot;&gt;bind&lt;/span&gt;-arch, &lt;span class=&quot;s2&quot;&gt;&quot;x86_64&quot;&lt;/span&gt;, &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;6&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;, image//生成Image，也就是最后的可执行文件
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;编译器前端&quot;&gt;编译器前端&lt;/h4&gt;

&lt;p&gt;编译器前端的任务是进行：语法分析，语义分析，生成中间代码(intermediate representation )。在这个过程中，会进行类型检查，如果发现错误或者警告会标注出来在哪一行。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_7/07.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;编译器优化&quot;&gt;编译器优化&lt;/h4&gt;

&lt;p&gt;LVVM优化器会进行BitCode的生成，链接期优化等等&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_7/08.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;编译器后端&quot;&gt;编译器后端&lt;/h4&gt;

&lt;p&gt;LLVM机器码生成器会针对不同的架构，比如arm64等生成不同的机器码&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_7/09.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;四xcode执行build的流程&quot;&gt;四、Xcode执行Build的流程&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;编译信息写入辅助文件，创建编译后的文件架构(name.app)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;写入辅助文件：将项目的文件结构对应表、将要执行的脚本、项目依赖库的文件结构对应表写成文件，方便后面使用&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;运行预设脚本：Cocoapods 会预设一些脚本，当然你也可以自己预设一些脚本来运行。这些脚本都在 Build Phases 中可以看到；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;编译文件：针对每一个文件进行编译，生成可执行文件 Mach-O，这过程 LLVM 的完整流程，前端、优化器、后端；使用&lt;code class=&quot;highlighter-rouge&quot;&gt;CompileC&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;clang&lt;/code&gt;命令。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CompileC ClassName.o ClassName.m normal x86_64 objective-c com.apple.compilers.llvm.clang.1_0.compiler
export LANG=en_US.US-ASCII
export PATH=&quot;...&quot;
clang -x objective-c -arch x86_64 -fmessage-length=0 -fobjc-arc... -Wno-missing-field-initializers ... -DDEBUG=1 ... -isysroot iPhoneSimulator10.1.sdk -fasm-blocks ... -I 上文提到的文件 -F 所需要的Framework  -iquote 所需要的Framework  ... -c ClassName.c -o ClassName.o
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;clang是实际的编译命令
-x      objective-c 指定了编译的语言
-arch   x86_64制定了编译的架构，类似还有arm7等
-fobjc-arc 一些列-f开头的，指定了采用arc等信息。这个也就是为什么你可以对单独的一个.m文件采用非ARC编程。
-Wno-missing-field-initializers 一系列以-W开头的，指的是编译的警告选项，通过这些你可以定制化编译选项
-DDEBUG=1 一些列-D开头的，指的是预编译宏，通过这些宏可以实现条件编译
-iPhoneSimulator10.1.sdk 制定了编译采用的iOS SDK版本
-I 把编译信息写入指定的辅助文件
-F 链接所需要的Framework
-c ClassName.c 编译文件
-o ClassName.o 编译产物
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;链接库，例如&lt;code class=&quot;highlighter-rouge&quot;&gt;Foundation.framework&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;AFNetworking.framework&lt;/code&gt;…&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;拷贝资源文件：将项目中的资源文件拷贝到目标包；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;编译 storyboard 文件：storyboard 文件也是会被编译的；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;链接 storyboard 文件：将编译后的 storyboard 文件链接成一个文件；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;编译 Asset 文件：我们的图片如果使用 Assets.xcassets 来管理图片，那么这些图片将会被编译成机器码，除了 icon 和 launchImage；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;运行 Cocoapods 脚本：将在编译项目之前已经编译好的依赖库和相关资源拷贝到包中。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;创建.app文件和对其签名&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;dsym-文件&quot;&gt;dSYM 文件&lt;/h4&gt;

&lt;p&gt;我们在每次编译过后，都会生成一个dsym文件。dsym文件中，存储了16进制的函数地址映射。&lt;/p&gt;

&lt;p&gt;在App实际执行的二进制文件中，是通过地址来调用方法的。在App crash的时候，第三方工具（Fabric,友盟等）会帮我们抓到崩溃的调用栈，调用栈里会包含crash地址的调用信息。然后，通过dSYM文件，我们就可以由地址映射到具体的函数位置。&lt;/p&gt;

&lt;h3 id=&quot;五提高项目build速度&quot;&gt;五、提高项目Build速度&lt;/h3&gt;

&lt;h4 id=&quot;查看编译时间&quot;&gt;查看编译时间&lt;/h4&gt;

&lt;p&gt;我们需要一个途径，能够看到编译的时间，这样才能有个对比，知道我们的优化究竟有没有效果。 
对于XCode 8，关闭XCode，终端输入以下指令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ defaults write com.apple.dt.Xcode ShowBuildOperationDuration YES
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;代码优化-forward-declaration&quot;&gt;代码优化-&lt;strong&gt;forward declaration&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@class CLASSNAME&lt;/code&gt;，而不是&lt;code class=&quot;highlighter-rouge&quot;&gt;#import CLASSNAME.h&lt;/code&gt;。这样，编译器能大大提高#import的替换速度。&lt;/p&gt;

&lt;h4 id=&quot;对常用工具类打包&quot;&gt;对常用工具类打包&lt;/h4&gt;

&lt;p&gt;打包成Framework或者静态库，这样编译的时候这部分代码就不需要重新编译了。&lt;/p&gt;

&lt;h4 id=&quot;常用头文件放到预编译文件里&quot;&gt;常用头文件放到预编译文件里&lt;/h4&gt;

&lt;p&gt;XCode的pch文件是预编译文件，这里的内容在执行XCode build之前就已经被预编译，并且引入到每一个.m文件里了。&lt;/p&gt;

&lt;p&gt;编译器选项优化&lt;/p&gt;

&lt;h4 id=&quot;debug模式下不生成dsym文件&quot;&gt;Debug模式下，不生成dsym文件&lt;/h4&gt;

&lt;p&gt;上文提到了，dysm文件里存储了调试信息，在Debug模式下，我们可以借助XCode和LLDB进行调试。所以，不需要生成额外的dsym文件来降低编译速度。&lt;/p&gt;

&lt;h4 id=&quot;debug开启build-active-architecture-only&quot;&gt;Debug开启&lt;code class=&quot;highlighter-rouge&quot;&gt;Build Active Architecture Only&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;在XCode -&amp;gt; Build Settings -&amp;gt; Build Active Architecture Only 改为YES。这样做，可以只编译当前的版本，比如arm7/arm64等等，记得只开启Debug模式。这个选项在高版本的XCode中自动开启了。&lt;/p&gt;

&lt;h4 id=&quot;debug模式下关闭编译器优化&quot;&gt;Debug模式下，关闭编译器优化&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_7/10.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;</content><author><name>Ted</name></author><category term="iOS" /><summary type="html">一、编译</summary></entry><entry><title type="html">OpenGL ES编程指南（四）</title><link href="http://www.helloted.com/%E5%9F%BA%E7%A1%80/2018/03/23/OpenGL_4/" rel="alternate" type="text/html" title="OpenGL ES编程指南（四）" /><published>2018-03-23T20:00:00+08:00</published><updated>2018-03-23T20:00:00+08:00</updated><id>http://www.helloted.com/%E5%9F%BA%E7%A1%80/2018/03/23/OpenGL_4</id><content type="html" xml:base="http://www.helloted.com/%E5%9F%BA%E7%A1%80/2018/03/23/OpenGL_4/">&lt;p&gt;本文翻译自苹果官方文档&lt;a href=&quot;https://developer.apple.com/library/content/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008793-CH1-SW1&quot;&gt;OpenGL ES Programming Guide&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;七可视化opengl-es&quot;&gt;七、可视化OpenGL ES&lt;/h3&gt;

&lt;p&gt;用于可视化OpenGL ES设计的两个方面：作为客户端 - 服务器体系结构和作为管道。 这两种观点都可以用于规划和评估应用程序的体系结构。&lt;/p&gt;

&lt;h4 id=&quot;opengl-es作为客户端---服务器体系结构&quot;&gt;OpenGL ES作为客户端 - 服务器体系结构&lt;/h4&gt;

&lt;p&gt;下图将OpenGL ES形象化为客户端 - 服务器体系结构。 您的应用程序将状态更改，纹理和顶点数据以及渲染命令传递给OpenGL ES客户端。 客户端将这些数据转换为图形硬件可以理解的格式，并将其转发给GPU。 这些进程会增加应用程序图形性能的开销。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_6/12.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;实现良好的性能需要仔细管理这些开销。 一个设计良好的应用程序可以减少对OpenGL ES的调用频率，使用适合硬件的数据格式来最大限度地降低翻译成本，并小心管理其本身和OpenGL ES之间的数据流。&lt;/p&gt;

&lt;h4 id=&quot;opengl-es作为图形管道&quot;&gt;OpenGL ES作为图形管道&lt;/h4&gt;

&lt;p&gt;下图将OpenGL ES形象化为图形管道。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;您的应用程序配置图形管道，&lt;/li&gt;
  &lt;li&gt;然后执行绘图命令将顶点数据(vertex)发送到管道，&lt;/li&gt;
  &lt;li&gt;管道的连续阶段运行顶点着色器(shader)来处理顶点数据，将顶点组装成基元(primitives)，&lt;/li&gt;
  &lt;li&gt;将基元划分为片段(fragments)，&lt;/li&gt;
  &lt;li&gt;运行片段着色器( fragment shader)以计算每个片段的颜色和深度值，并将片段混合到帧缓冲区中以进行显示。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_6/13.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;使用管道作为模型来确定您的应用执行哪些工作来生成新框架。 您的渲染器设计包括编写着色器程序以处理管道的顶点和片段阶段，组织提供给这些程序的顶点和纹理数据，以及配置驱动流水线固定功能阶段的OpenGL ES状态机。&lt;/p&gt;

&lt;p&gt;图形管道中的各个阶段可以同时计算其结果 - 例如，您的应用程序可能会准备新的基元，而图形硬件的不同部分将对先前提交的几何图形执行顶点和片段计算。 然而，后期阶段取决于早期阶段的产出。 如果任何流水线阶段执行太多工作或执行得太慢，则其他流水线阶段处于闲置状态，直到最慢阶段完成其工作。 根据图形硬件功能，精心设计的应用程序会平衡每个流水线阶段执行的工作。&lt;/p&gt;

&lt;h3 id=&quot;八opengl-es版本和渲染器架构&quot;&gt;八、OpenGL ES版本和渲染器架构&lt;/h3&gt;

&lt;p&gt;iOS支持三种版本的OpenGL ES。 较新的版本提供了更多的灵活性，使您可以实现包含高质量视觉效果而不影响性能的渲染算法。&lt;/p&gt;

&lt;h4 id=&quot;opengl-es-30&quot;&gt;OpenGL ES 3.0&lt;/h4&gt;

&lt;p&gt;OpenGL ES 3.0是iOS 7中的新功能。您的应用程序可以使用OpenGL ES 3.0中引入的功能来实现先前的图形编程技术（以前仅在桌面级硬件和游戏控制台上提供），以获得更快的图形性能和引人注目的视觉效果。&lt;/p&gt;

&lt;p&gt;下面突出显示了OpenGL ES 3.0的一些关键特性。有关完整的概述，请参阅OpenGL ES API注册表中的OpenGL ES 3.0规范。&lt;/p&gt;

&lt;h4 id=&quot;1opengl-es着色语言版本30&quot;&gt;1、OpenGL ES着色语言版本3.0&lt;/h4&gt;

&lt;p&gt;GLSL ES 3.0增加了统一块，32位整数和附加整数运算等新功能，用于在顶点和片段着色器程序中执行更通用的计算任务。要在着色器程序中使用新语言，着色器源代码必须以#version 330 es指令开始。 OpenGL ES 3.0上下文与为OpenGL ES 2.0编写的着色器保持兼容。&lt;/p&gt;

&lt;h4 id=&quot;2多个渲染目标&quot;&gt;2、多个渲染目标&lt;/h4&gt;

&lt;p&gt;通过启用多个渲染目标，您可以创建片段着色器，以同时写入多个帧缓冲区附件。&lt;/p&gt;

&lt;p&gt;此功能允许使用高级渲染算法，如延迟着色，其中您的应用首先渲染一组纹理以存储几何数据，然后执行一次或多次从这些纹理读取的着色过程，并执行光照计算以输出最终图片。由于此方法会预先计算照明计算的输入，因此将大量灯光添加到场景的增量性能成本要小得多。延迟着色算法需要多个渲染目标支持，如下图所示，以实现合理的性能。否则，渲染到多个纹理需要为每个纹理单独绘制通过。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_6/14.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;除了创建帧缓冲区对象中描述的过程外，您还可以设置多个渲染目标。 您可以创建多个，而不是为帧缓冲区创建单个颜色附件。 然后，调用glDrawBuffers函数来指定在渲染中使用哪些帧缓冲区附件，如所示。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Attach (previously created) textures to the framebuffer.
glFramebufferTexture2D(GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, _colorTexture, 0);
glFramebufferTexture2D(GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT1, GL_TEXTURE_2D, _positionTexture, 0);
glFramebufferTexture2D(GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT2, GL_TEXTURE_2D, _normalTexture, 0);
glFramebufferTexture2D(GL_DRAW_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_TEXTURE_2D, _depthTexture, 0);
 
// Specify the framebuffer attachments for rendering.
GLenum targets[] = {GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1, GL_COLOR_ATTACHMENT2};
glDrawBuffers(3, targets);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当您的应用程序发出绘图命令时，片段着色器将确定为每个渲染目标中的每个像素输出的颜色（或非颜色数据）。 下面代码显示了一个基本的片段着色器，该片段着色器通过分配位置与上面设置的位置匹配的片段输出变量来呈现给多个目标&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#version 300 es
 
uniform lowp sampler2D myTexture;
in mediump vec2 texCoord;
in mediump vec4 position;
in mediump vec3 normal;
 
layout(location = 0) out lowp vec4 colorData;
layout(location = 1) out mediump vec4 positionData;
layout(location = 2) out mediump vec4 normalData;
 
void main()
{
    colorData = texture(myTexture, texCoord);
    positionData = position;
    normalData = vec4(normalize(normal), 1.0);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;多个渲染目标对于其他高级图形技术也很有用，例如实时反射，屏幕空间环境遮挡和体积照明。&lt;/p&gt;

&lt;h4 id=&quot;3变换反馈&quot;&gt;3、变换反馈&lt;/h4&gt;

&lt;p&gt;图形硬件使用针对矢量处理进行了优化的高度并行化架构。 您可以利用新的变换反馈功能更好地使用此硬件，该功能可以将顶点着色器的输出捕捉到GPU内存中的缓冲区对象中。 您可以捕获一个渲染过程中的数据以用于另一个过程，或者禁用图形管道的某些部分，并使用变换反馈进行通用计算。&lt;/p&gt;

&lt;p&gt;从变换反馈中受益的一种技术是动画粒子效应。 下图说明了渲染粒子系统的一般体系结构。 首先，应用程序设置粒子模拟的初始状态。 然后，对于每个渲染帧，应用程序运行一个模拟步骤，更新每个模拟粒子的位置，方向和速度，然后绘制代表粒子当前状态的可视化资源。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_6/15.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;传统上，实现粒子系统的应用程序在CPU上运行其模拟，将模拟结果存储在顶点缓冲区中以用于渲染粒子艺术。 但是，将顶点缓冲区的内容传输到GPU内存是非常耗时的。 通过优化现代GPU硬件中可用的并行架构的功能来转换反馈，可更有效地解决问题。&lt;/p&gt;

&lt;p&gt;借助变换反馈，您可以设计渲染引擎以更有效地解决此问题。 图6-5显示了应用程序如何配置OpenGL ES图形管道来实现粒子系统动画。 由于OpenGL ES将每个粒子及其状态表示为顶点，因此GPU的顶点着色器阶段可以同时运行多个粒子的模拟。 由于包含粒子状态数据的顶点缓冲区在帧之间被重用，因此在初始化时，将数据传输到GPU内存的昂贵过程只发生一次。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_6/16.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;在初始化时，创建一个顶点缓冲区，并在其中填充包含模拟中所有粒子初始状态的数据。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在GLSL顶点着色器程序中实现您的粒子模拟，并通过绘制包含粒子位置数据的顶点缓冲区的内容来运行它。&lt;/p&gt;

    &lt;p&gt;要在启用变换反馈的情况下进行渲染，请调用glBeginTransformFeedback函数。 （在恢复正常绘图之前调用glEndTransformFeedback（）。）&lt;/p&gt;

    &lt;p&gt;使用glTransformFeedbackVaryings函数来指定哪些着色器输出应该被变换反馈捕获，并使用glBindBufferBase或glBindBufferRange函数和GL_TRANSFORM_FEEDBACK_BUFFER缓冲区类型来指定它们将被捕获到的缓冲区。&lt;/p&gt;

    &lt;p&gt;通过调用glEnable（GL_RASTERIZER_DISCARD）禁用栅格化（以及管道的后续阶段）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;要渲染模拟结果以供显示，请使用包含粒子位置的顶点缓冲区作为第二个绘制阶段的输入，并再次启用光栅化（以及管道的其余部分），并使用适合渲染应用视觉内容的顶点和片段着色器。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在下一帧中，使用上一帧模拟步骤输出的顶点缓冲区作为下一个模拟步骤的输入&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;opengl-es-20&quot;&gt;OpenGL ES 2.0&lt;/h4&gt;

&lt;p&gt;OpenGL ES 2.0提供了可编程着色器的灵活图形管道，并可在所有当前的iOS设备上使用。 OpenGL ES 3.0规范中正式引入的许多功能通过OpenGL ES 2.0扩展可用于iOS设备，因此您可以在保持与大多数设备兼容的同时实现许多高级图形编程技术。&lt;/p&gt;

&lt;h4 id=&quot;opengl-es-11&quot;&gt;OpenGL ES 1.1&lt;/h4&gt;

&lt;p&gt;OpenGL ES 1.1只提供了一个基本的固定功能图形管道。 iOS支持OpenGL ES 1.1主要用于向后兼容。 如果您正在维护OpenGL ES 1.1应用程序，请考虑更新您的代码以获取更新的OpenGL ES版本。&lt;/p&gt;

&lt;h3 id=&quot;九设计一个高性能opengl-es-app&quot;&gt;九、设计一个高性能OpenGL ES App&lt;/h3&gt;

&lt;p&gt;总而言之，一个精心设计的OpenGL ES应用程序需要：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;利用OpenGL ES管道中的并行性。&lt;/li&gt;
  &lt;li&gt;管理应用程序和图形硬件之间的数据流。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下图给出了使用OpenGL ES对显示进行动画的应用程序的流程图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_6/17.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当应用程序启动时，它所做的第一件事是初始化资源，它不打算在应用程序的生命周期中进行更改。理想情况下，应用程序将这些资源封装到OpenGL ES对象中。我们的目标是创建任何可以保持应用运行时不变的对象（或甚至是应用生命周期的一部分，例如游戏中的关卡持续时间），交易增加的初始化时间以获得更好的呈现性能。复杂的命令或状态更改应该用OpenGL ES对象代替，这些对象可以与单个函数调用一起使用。例如，配置固定功能管道可能需要数十个函数调用。相反，在初始化时编译一个图形着色器，并在运行时用一个函数调用切换到它。几乎总是创建或修改昂贵的OpenGL ES对象应该被创建为静态对象。&lt;/p&gt;

&lt;p&gt;渲染循环处理您打算渲染到OpenGL ES上下文的所有项目，然后将结果呈现给显示器。在动画场景中，每帧都会更新一些数据。在图6-6所示的内部渲染循环中，应用程序在更新渲染资源（在过程中创建或修改OpenGL ES对象）和提交使用这些资源的绘图命令之间进行交替。这个内部循环的目标是平衡工作负载，以便CPU和GPU并行工作，防止应用程序和OpenGL ES同时访问相同的资源。在iOS上，修改OpenGL ES对象在帧的开始或结束没有执行修改时可能很昂贵。&lt;/p&gt;

&lt;p&gt;这个内部循环的一个重要目标是避免将数据从OpenGL ES复制回应用程序。从GPU复制结果到CPU可能非常缓慢。如果复制的数据稍后也用作渲染当前帧的过程的一部分，如中间渲染循环所示，则应用程序会阻止，直到完成所有以前提交的绘图命令。&lt;/p&gt;

&lt;p&gt;在应用程序提交框架中需要的所有绘图命令后，它会将结果呈现给屏幕。非交互式应用程序会将最终图像复制到应用程序内存以供进一步处理。&lt;/p&gt;

&lt;p&gt;最后，当您的应用程序准备退出或完成一项重要任务时，它将释放OpenGL ES对象以为其自身或其他应用程序提供额外资源。&lt;/p&gt;

&lt;p&gt;总结这个设计的重要特征：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;尽可能创建静态资源。&lt;/li&gt;
  &lt;li&gt;内部渲染循环在修改动态资源和提交渲染命令之间交替进行。尽量避免修改动态资源，除了在帧的开始或结束时。&lt;/li&gt;
  &lt;li&gt;避免将中间渲染结果读回您的应用程序。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;避免同步和刷新操作&quot;&gt;避免同步和刷新操作&lt;/h4&gt;

&lt;p&gt;OpenGL ES规范不要求实现立即执行命令。通常，命令排队到命令缓冲区，稍后由硬件执行。通常，OpenGL ES会一直等待，直到应用程序在将命令发送到硬件之前将许多命令排队为止 - 批处理通常更高效。但是，一些OpenGL ES函数必须立即刷新命令缓冲区。其他函数不仅会刷新命令缓冲区，而且还会阻塞，直到先前提交的命令已完成，然后再返回对应用程序的控仅当需要此行为时才使用刷新和同步命令。过度使用刷新或同步命令可能会导致应用程序在等待硬件完成呈现时停顿。&lt;/p&gt;

&lt;p&gt;这些情况需要OpenGL ES将命令缓冲区提交给硬件执行。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;函数glFlush将命令缓冲区发送到图形硬件。它会阻塞直到命令提交给硬件，但不会等待命令完成执行。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;函数glFinish刷新命令缓冲区，然后等待所有先前提交的命令在图形硬件上完成执行。&lt;/li&gt;
  &lt;li&gt;检索帧缓冲区内容的函数（如glReadPixels）也等待提交的命令完成。&lt;/li&gt;
  &lt;li&gt;命令缓冲区已满。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;有效地使用glflush&quot;&gt;有效地使用glFlush&lt;/h4&gt;

&lt;p&gt;在某些桌面OpenGL实现中，定期调用glFlush函数以有效平衡CPU和GPU工作会很有用，但iOS中并非如此。由iOS图形硬件实现的基于图块的延迟渲染算法取决于缓冲场景中的所有顶点数据，因此可以针对隐藏的曲面去除进行最佳处理。通常，只有两种情况，OpenGL ES应用程序应调用glFlush或glFinish函数。&lt;/p&gt;

&lt;p&gt;当您的应用移动到后台时，您应该刷新命令缓冲区，因为在应用处于后台时在GPU上执行OpenGL ES命令会导致iOS终止您的应用。 （请参阅实施多任务处理型OpenGL ES应用程序。）
如果您的应用程序在多个上下文之间共享OpenGL ES对象（如顶点缓冲区或纹理），则应该调用glFlush函数来同步对这些资源的访问。例如，您应该在一个上下文中加载顶点数据后调用glFlush函数，以确保其内容已准备好被另一个上下文检索。当与其他iOS API（如Core Image）共享OpenGL ES对象时，此建议也适用。&lt;/p&gt;

&lt;h4 id=&quot;避免查询opengl-es状态&quot;&gt;避免查询OpenGL ES状态&lt;/h4&gt;

&lt;p&gt;调用glGet *（）（包括glGetError（））可能需要OpenGL ES在检索任何状态变量之前执行先前的命令。这种同步迫使图形硬件与CPU进行锁步，减少了并行机会。为了避免这种情况，请维护您需要查询的任何状态的副本，并直接访问它，而不是调用OpenGL ES。&lt;/p&gt;

&lt;p&gt;发生错误时，OpenGL ES会设置一个错误标志。这些错误和其他错误出现在Xcode的OpenGL ES Frame Debugger或Instruments的OpenGL ES Analyzer中。您应该使用这些工具而不是glGetError函数，这会在频繁调用时降低性能。其他查询，如glCheckFramebufferStatus（），glGetProgramInfoLog（）和glValidateProgram（）通常也仅在开发和调试时有用。您应该在应用的发布版本中省略对这些功能的调用。&lt;/p&gt;

&lt;h4 id=&quot;使用opengl-es来管理您的资源&quot;&gt;使用OpenGL ES来管理您的资源&lt;/h4&gt;

&lt;p&gt;许多OpenGL数据可以直接存储在OpenGL ES渲染上下文及其相关的共享组对象中。 OpenGL ES实现可自由将数据转换为最适合图形硬件的格式。这可以显着提高性能，特别是对于频繁更改的数据。您的应用程序还可以向OpenGL ES提供关于打算如何使用这些数据的提示。 OpenGL ES实现可以使用这些提示更有效地处理数据。例如，静态数据可能被放置在图形处理器可以轻易获取的内存中，甚至放入专用图形内存中。&lt;/p&gt;

&lt;h4 id=&quot;使用双缓冲来避免资源冲突&quot;&gt;使用双缓冲来避免资源冲突&lt;/h4&gt;

&lt;p&gt;当您的应用程序和OpenGL ES同时访问OpenGL ES对象时，会发生资源冲突。 当一个参与者尝试修改另一个参与者使用的OpenGL ES对象时，它们可能会阻塞，直到该对象不再被使用。 一旦他们开始修改对象，其他参与者可能无法访问对象，直到修改完成。 或者，OpenGL ES可以隐式复制对象，以便两个参与者都可以继续执行命令。 这两个选项都是安全的，但每个选项都可能成为您应用程序的瓶颈。 图6-7显示了这个问题。 在这个例子中，有一个纹理对象，OpenGL ES和你的应用都想使用它。 当应用程序尝试更改纹理时，它必须等到之前提交的绘图命令完成CPU才会与GPU同步。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_6/18.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为了解决这个问题，您的应用程序可以在更改对象和绘图之间执行额外的工作。 但是，如果你的应用程序没有额外的工作，它可以执行，它应该明确地创建两个相同大小的对象; 当一个参与者读取一个对象时，另一个参与者修改另一个参与者。 图6-8说明了双缓冲方法。 GPU在一个纹理上运行时，CPU会修改另一个纹理。 初次启动后，CPU或GPU都不处于闲置状态。 尽管显示了纹理，但该解决方案几乎适用于任何类型的OpenGL ES对象。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_6/19.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于大多数应用程序来说，双缓冲就足够了，但它要求两个参与者大致在同一时间完成处理命令。 为了避免阻塞，你可以添加更多的缓冲区; 这实现了传统的生产者 - 消费者模式。 如果生产者在消费者完成处理命令之前完成，它会占用一个空闲缓冲区并继续处理命令。 在这种情况下，制造商只有在消费者严重落后的情况下才会闲置。&lt;/p&gt;

&lt;p&gt;双倍和三倍缓冲折衷消耗额外的内存，以防止管道堵塞。 额外使用内存可能会对应用程序的其他部分造成压力。 在iOS设备上，内存可能非常稀少; 您的设计可能需要使用更多内存与其他应用程序优化进行平衡。&lt;/p&gt;

&lt;h4 id=&quot;注意opengl-es状态&quot;&gt;注意OpenGL ES状态&lt;/h4&gt;

&lt;p&gt;OpenGL ES实现维护一组复杂的状态数据，包括使用glEnable或glDisable函数设置的开关，当前着色器程序及其统一变量，当前绑定的纹理单元以及当前绑定的顶点缓冲区及其启用的顶点属性。硬件有一个当前状态，它被懒惰地编译和缓存。开关状态很昂贵，所以最好设计你的应用程序以最小化状态开关。&lt;/p&gt;

&lt;p&gt;不要设置已经设置的状态。一旦功能启用后，不需要再次启用。例如，如果多次调用具有相同参数的glUniform函数，OpenGL ES可能无法检查是否已经设置了相同的统一状态。即使该值与当前值相同，它也会更新状态值。&lt;/p&gt;

&lt;p&gt;通过使用专用的设置或关闭例程避免设置超过必要的状态，而不是将这些调用放入绘图循环中。设置和关闭例程对于打开和关闭实现特定视觉效果的功能也很有用 - 例如，在纹理多边形周围绘制线框轮廓时。&lt;/p&gt;

&lt;h4 id=&quot;用opengl-es对象封装状态&quot;&gt;用OpenGL ES对象封装状态&lt;/h4&gt;

&lt;p&gt;要减少状态更改，请创建将多个OpenGL ES状态更改收集到可通过单个函数调用进行绑定的对象中的对象。例如，顶点数组对象将多个顶点属性的配置存储到单个对象中。请参阅使用顶点数组对象合并顶点数组状态更改。&lt;/p&gt;

&lt;h4 id=&quot;组织绘图调用以最小化状态更改&quot;&gt;组织绘图调用以最小化状态更改&lt;/h4&gt;

&lt;p&gt;更改OpenGL ES状态不会立即生效。相反，当您发出绘图命令时，OpenGL ES会执行必要的工作以绘制一组状态值。您可以通过最小化状态更改来减少重新配置图形管道所花费的CPU时间。例如，在您的应用中保留一个状态向量，并且只有当您的状态在绘制调用之间改变时才设置相应的OpenGL ES状态。另一个有用的算法是状态排序 - 跟踪您需要执行的绘图操作以及每个绘图操作所需的状态更改量，然后对它们进行排序以连续执行使用相同状态的操作。&lt;/p&gt;

&lt;p&gt;OpenGL ES的iOS实现可以缓存一些状态之间有效切换所需的配置数据，但每个独特状态集的初始配置需要更长的时间。为了获得一致的性能，您可以“预热”您在安装例程期间计划使用的每个状态集：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;启用您打算使用的状态配置或着色器。&lt;/li&gt;
  &lt;li&gt;使用该状态配置绘制一小堆顶点。&lt;/li&gt;
  &lt;li&gt;刷新OpenGL ES上下文，以便不显示此预热阶段的绘图。&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Ted</name></author><category term="基础" /><summary type="html">本文翻译自苹果官方文档OpenGL ES Programming Guide</summary></entry><entry><title type="html">OpenGL ES编程指南（三）</title><link href="http://www.helloted.com/%E5%9F%BA%E7%A1%80/2018/03/22/OpenGL_3/" rel="alternate" type="text/html" title="OpenGL ES编程指南（三）" /><published>2018-03-22T20:00:00+08:00</published><updated>2018-03-22T20:00:00+08:00</updated><id>http://www.helloted.com/%E5%9F%BA%E7%A1%80/2018/03/22/OpenGL_3</id><content type="html" xml:base="http://www.helloted.com/%E5%9F%BA%E7%A1%80/2018/03/22/OpenGL_3/">&lt;p&gt;本文翻译自苹果官方文档&lt;a href=&quot;https://developer.apple.com/library/content/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008793-CH1-SW1&quot;&gt;OpenGL ES Programming Guide&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;六多任务高分辨率和其他功能&quot;&gt;六、多任务、高分辨率和其他功能&lt;/h3&gt;

&lt;p&gt;使用OpenGL ES的许多方面都是平台无关的，但在iOS上使用OpenGL ES的一些细节需要特别注意。 尤其是，使用OpenGL ES的iOS应用程序必须正确处理多任务，否则在转到后台时可能会被终止。 在为iOS设备开发OpenGL ES内容时，您还应该考虑显示分辨率和其他设备功能。&lt;/p&gt;

&lt;h4 id=&quot;不能在后台工作&quot;&gt;不能在后台工作&lt;/h4&gt;

&lt;p&gt;OpenGL ES应用程序移到后台时必须做额外的操作。 如果应用程序不正确地处理这些任务，它可能会被iOS终止。 此外，应用程序可能需要释放OpenGL ES资源，以便这些资源可用于前台应用程序。&lt;/p&gt;

&lt;p&gt;iOS会阻止后台应用程序访问图形处理器，以便前台的应用程序始终能够为用户提供出色的体验。 您的应用程序如果在后台进行OpenGL ES调用，或者在后台将先前提交的命令刷新到GPU，应用程序将会被终止。 您的应用程序必须确保移动到后台之前让先前提交的所有命令在都已完成执行。&lt;/p&gt;

&lt;p&gt;如果您使用GLKit view和view controller，并且只在绘图方法中提交OpenGL ES命令，那么当您的应用移动到背景时，您的应用会自动正确运行。 默认情况下，GLKViewController类会在您的应用程序变为非活动状态时暂停其动画计时器，以确保您的绘图方法未被调用。&lt;/p&gt;

&lt;p&gt;如果您不使用GLKit view和view controller，或者如果您在GLKView绘图方法外提交OpenGL ES命令，则必须执行以下步骤以确保您的应用程序不会在后台终止：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在您的应用程序delegate的&lt;code class=&quot;highlighter-rouge&quot;&gt;applicationWillResignActive：&lt;/code&gt;方法中，您的应用程序应停止其动画计时器（如果有），将自己置于已知良好状态，然后调用&lt;code class=&quot;highlighter-rouge&quot;&gt;glFinish&lt;/code&gt;函数。&lt;/li&gt;
  &lt;li&gt;在您的应用程序delegate的&lt;code class=&quot;highlighter-rouge&quot;&gt;applicationDidEnterBackground：&lt;/code&gt;方法中，您的应用程序可能希望删除其某些OpenGL ES对象，以使内存和资源可用于前台应用程序。 调用&lt;code class=&quot;highlighter-rouge&quot;&gt;glFinish&lt;/code&gt;函数以确保立即删除资源。&lt;/li&gt;
  &lt;li&gt;在您的应用退出其&lt;code class=&quot;highlighter-rouge&quot;&gt;applicationDidEnterBackground：&lt;/code&gt;方法后，它不能进行任何新的OpenGL ES调用。 如果它进行OpenGL ES调用，它将被iOS终止。&lt;/li&gt;
  &lt;li&gt;在您的应用程序delegate的&lt;code class=&quot;highlighter-rouge&quot;&gt;applicationWillEnterForeground：&lt;/code&gt;方法中，重新创建任何对象并重新启动您的动画计时器&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总之，您的应用程序需要调用&lt;code class=&quot;highlighter-rouge&quot;&gt;glFinish&lt;/code&gt;函数以确保所有先前提交的命令从命令缓冲区中排出并由OpenGL ES执行。 进入后台后，必须避免使用OpenGL ES，直到它移回到前台。&lt;/p&gt;

&lt;h4 id=&quot;在移至后台之前删除易重建资源&quot;&gt;在移至后台之前删除易重建资源&lt;/h4&gt;

&lt;p&gt;在移动到后台时，您的应用永远不需要释放OpenGL ES对象。通常，您的应用应该避免处理其内容。考虑两种情况：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;用户正在玩您的游戏并暂时退出以查看日历。当玩家回到游戏时，游戏的资源仍然在记忆中，游戏可以立即恢复。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当用户启动另一个OpenGL ES应用程序时，您的OpenGL ES应用程序处于后台。如果该应用程序需要的内存超过设备上的可用内存，系统将自动终止您的应用程序，而无需执行任何其他工作。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;您的目标应该是设计您的应用程序成为一个”好公民”：这意味着尽可能缩短移动到前台所需的时间，同时减少其在后台的内存占用量。&lt;/p&gt;

&lt;p&gt;以下是您应该如何处理这两种情况的方法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;您的应用应该将纹理，模型和其他资源保留在内存中;花费很长时间重新创建的资源不应该在您的应用移动到后台时处理。&lt;/li&gt;
  &lt;li&gt;您的应用程序应该处理可以快速轻松地重新创建的对象。寻找消耗大量内存的对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;简单的目标是你的应用程序分配的帧缓冲区来保存渲染结果。当您的应用程序位于后台时，它对用户不可见，并且可能不会使用OpenGL ES呈现任何新内容。这意味着您的应用程序的帧缓冲区所消耗的内存已分配，但无用。而且，帧缓冲器的内容是暂时的;大多数应用程序每次渲染新帧时都会重新创建帧缓冲区的内容。这使得渲染缓冲区成为一个可以轻松重新创建的内存密集型资源，成为移动到后台时可以处理的对象的良好候选对象。&lt;/p&gt;

&lt;p&gt;如果您使用GLKit视图和视图控制器，则当您的应用移动到后台时，GLKViewController类会自动处理其关联视图的帧缓冲区。如果您为其他用途手动创建帧缓冲区，则应该在应用移动到背景时将其丢弃。无论哪种情况，您还应该考虑当时您的应用可以处理的其他暂时资源。&lt;/p&gt;

&lt;h4 id=&quot;支持高分辨率显示&quot;&gt;支持高分辨率显示&lt;/h4&gt;

&lt;p&gt;默认情况下，GLKit View的contentScaleFactor属性的值与包含它的屏幕的比例相匹配，因此将其关联的帧缓冲区配置为在显示器的全分辨率下呈现。&lt;/p&gt;

&lt;p&gt;如果您使用Core Animation图层呈现OpenGL ES内容，则默认情况下其比例因子设置为1.0。 要以Retina显示器的全分辨率绘制，您应该更改CAEAGLLayer对象的比例因子以匹配屏幕的比例因子。&lt;/p&gt;

&lt;p&gt;当支持具有高分辨率显示器的设备时，您应该相应地调整应用程序的型号和纹理资源。 在高分辨率设备上运行时，您可能需要选择更详细的模型和纹理以呈现更好的图像。 相反，在标准分辨率设备上，您可以使用较小的模型和纹理。&lt;/p&gt;

&lt;p&gt;重要提示：许多OpenGL ES API调用以屏幕像素表示尺寸。 如果使用大于1.0的比例因子，则应在使用&lt;code class=&quot;highlighter-rouge&quot;&gt;glScissor&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;glBlitFramebuffer&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;glLineWidth&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;glPointSize&lt;/code&gt;函数或&lt;code class=&quot;highlighter-rouge&quot;&gt;gl_PointSize&lt;/code&gt;着色器变量时相应地调整尺寸。&lt;/p&gt;

&lt;p&gt;确定如何支持高分辨率显示器的一个重要因素是性能。 Retina显示屏上缩放倍数的倍增使像素数量增加了四倍，导致GPU处理四倍的碎片。如果您的应用执行许多每片段计算，则像素增加可能会降低帧速率。如果您发现您的应用在较高比例因素下运行速度显着较慢，请考虑以下选项之一：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;使用本文档中的性能调整指导来优化片段着色器的性能。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在你的片段着色器中实现一个更简单的算法。通过这样做，您可以降低单个像素的质量，从而以更高的分辨率呈现整个图像。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用1.0到和屏幕比例因子之间的分数比例因子。比例因子1.5提供比1.0的比例因子更好的质量，但需要填充比缩放为2.0的图像更少的像素。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为您的GLKView对象的&lt;code class=&quot;highlighter-rouge&quot;&gt;drawableColorFormat&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;drawableDepthFormat&lt;/code&gt;属性使用较低精度的格式。通过这样做，可以减少在底层渲染缓冲区上操作所需的内存带宽。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用较低的比例因子并启用多重采样。另一个优点是多重采样还可以在不支持高分辨率显示的设备上提供更高的质量。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;要为GLKView对象启用多重采样，请更改其drawableMultisample属性的值。如果您未渲染到GLKit视图，则必须手动设置多重采样缓冲区并在呈现最终图像之前解决它们（请参阅使用多重采样来提高图像质量）。&lt;/p&gt;

    &lt;p&gt;多重采样不是免费的;需要额外的内存来存储额外的样本，并且将样本解析到解析帧缓冲区需要时间。如果您向应用添加多重采样，请始终测试应用的性能以确保其可接受性。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;多方向交互&quot;&gt;多方向交互&lt;/h4&gt;

&lt;p&gt;与任何应用程序一样，OpenGL ES应用程序应支持适合其内容的用户界面方向。您可以在其信息属性列表中为您的应用程序声明支持的界面方向，或者使用其supportedInterfaceOrientations方法为托管OpenGL ES内容的视图控制器声明支持的界面方向。&lt;/p&gt;

&lt;p&gt;默认情况下，GLKViewController和GLKView类会自动处理方向更改：当用户将设备旋转到支持的方向时，系统会激活方向更改并更改视图控制器视图的大小。当其大小改变时，GLKView对象相应地调整其帧缓冲区和视口的大小。如果您需要响应此更改，请在您的GLKViewController子类中实现viewWillLayoutSubviews或viewDidLayoutSubviews方法，或者在使用自定义GLKView子类时实现layoutSubviews方法。&lt;/p&gt;

&lt;p&gt;如果您使用Core Animation图层绘制OpenGL ES内容，则应用程序仍应包含视图控制器来管理用户界面方向。&lt;/p&gt;

&lt;h4 id=&quot;其他显示屏上展示&quot;&gt;其他显示屏上展示&lt;/h4&gt;

&lt;p&gt;iOS设备可以连接到外部显示器。外部显示器的分辨率及其内容比例因子可能与主屏幕的分辨率和比例因子不同;渲染帧的代码应调整为匹配。&lt;/p&gt;

&lt;p&gt;在外部显示器上绘图的步骤与在主屏幕上运行的步骤几乎完全相同。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;按照多显示器编程指南for iOS中的步骤在外部显示器上创建一个窗口。&lt;/li&gt;
  &lt;li&gt;为您的渲染策略添加适当的视图或视图控制器对象。&lt;/li&gt;
  &lt;li&gt;如果使用GLKit进行渲染，请设置GLKViewController和GLKView（或您的自定义子类）的实例，并使用其rootViewController属性将它们添加到窗口中。&lt;/li&gt;
  &lt;li&gt;如果渲染到Core Animation图层，请将包含图层的视图添加为窗口的子视图。要使用动画循环进行渲染，请通过检索窗口的屏幕属性并调用其displayLinkWithTarget：selector：方法来创建为外部显示器优化的显示链接对象。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Ted</name></author><category term="基础" /><summary type="html">本文翻译自苹果官方文档OpenGL ES Programming Guide</summary></entry><entry><title type="html">OpenGL ES编程指南（二）</title><link href="http://www.helloted.com/%E5%9F%BA%E7%A1%80/2018/03/21/OpenGL_2/" rel="alternate" type="text/html" title="OpenGL ES编程指南（二）" /><published>2018-03-21T20:00:00+08:00</published><updated>2018-03-21T20:00:00+08:00</updated><id>http://www.helloted.com/%E5%9F%BA%E7%A1%80/2018/03/21/OpenGL_2</id><content type="html" xml:base="http://www.helloted.com/%E5%9F%BA%E7%A1%80/2018/03/21/OpenGL_2/">&lt;p&gt;本文翻译自苹果官方文档&lt;a href=&quot;https://developer.apple.com/library/content/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008793-CH1-SW1&quot;&gt;OpenGL ES Programming Guide&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;四通过opengl-es和glkit来画&quot;&gt;四、通过OpenGL ES和GLKit来画&lt;/h3&gt;

&lt;p&gt;GLKit框架提供了View和ViewController类，它们消除了OpenGL ES内容绘制和动画制作所需的设置和代码维护。 GLKView类管理OpenGL ES基础结构并为绘图代码提供位置，而GLKViewController类则为GLKit视图中的OpenGL ES内容的平滑动画提供渲染循环。 这些类扩展了用于绘制视图内容和管理视图表示的标准UIKit设计模式。 因此，您可以将精力主要放在您的OpenGL ES渲染代码上，并让您的应用程序快速启动并运行。 GLKit框架还提供了其他功能来简化OpenGL ES 2.0和3.0的开发。&lt;/p&gt;

&lt;h4 id=&quot;glkit-view&quot;&gt;GLKit View&lt;/h4&gt;

&lt;p&gt;GLKView类提供了基于OpenGL ES的的绘图，与标准UIView绘图循环等价。 UIView实例自动配置其图形上下文，以便您的drawRect：实现只需执行Quartz 2D绘图命令；而GLKView实例自动配置它自己，绘图只需执行OpenGL ES绘图命令。 GLKView类通过维护一个保存OpenGL ES绘图命令结果的framebuffer对象来提供这种功能，然后在绘图方法返回时自动将它们呈现给Core Animation。&lt;/p&gt;

&lt;p&gt;与标准UIKit视图一样，GLKit视图按需呈现其内容。首次显示视图时，它将调用您的绘图方法 - Core Animation会缓存呈现的输出并在显示视图时显示它。如果要更改视图的内容，请调用setNeedsDisplay方法，视图再次调用绘图方法，缓存结果图像并将其显示在屏幕上。当用于渲染图像的数据不经常更改或仅响应用户操作时，此方法非常有用。通过仅在需要时渲染新的视图内容，您可以节省设备上的电池电量，并为设备执行其他操作留出更多时间。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_6/06.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;创建并配置一个glkit-view&quot;&gt;创建并配置一个GLKit View&lt;/h4&gt;

&lt;p&gt;您可以通过编程或使用Interface Builder来创建和配置GLKView对象。 在将其用于绘制之前，您必须将其与EAGLContext对象关联（请参阅配置OpenGL ES上下文）。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;以编程方式创建视图时，首先创建一个上下文，然后将其传递给视图的 &lt;code class=&quot;highlighter-rouge&quot;&gt;initWithFrame:context:&lt;/code&gt; 方法。&lt;/li&gt;
  &lt;li&gt;从storyboard加载视图后，创建一个上下文并将其设置为视图的上下文属性的值。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;GLKit视图会自动创建和配置自己的OpenGL ES帧缓冲区对象和渲染缓冲区。 您可以使用视图的可绘制属性来控制这些对象的属性，如下所示。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)viewDidLoad
{
    [super viewDidLoad];
 
    // Create an OpenGL ES context and assign it to the view loaded from storyboard
    GLKView *view = (GLKView *)self.view;
    view.context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];
 
    // Configure renderbuffers created by the view
    view.drawableColorFormat = GLKViewDrawableColorFormatRGBA8888;
    view.drawableDepthFormat = GLKViewDrawableDepthFormat24;
    view.drawableStencilFormat = GLKViewDrawableStencilFormat8;
 
    // Enable multisampling
    view.drawableMultisample = GLKViewDrawableMultisample4X;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果您更改GLKit视图的大小，比例因子或可绘制属性，则会在下次绘制内容时自动删除并重新创建适当的帧缓冲区对象和渲染缓冲区.&lt;/p&gt;

&lt;p&gt;您可以使用其drawableMultisample属性为GLKView实例启用多重采样。 多重采样是抗锯齿的一种形式，可平滑锯齿状边缘，以大幅增加内存和碎片处理时间为代价提高大多数3D应用的图像质量 - 如果启用多重采样，则始终测试应用的性能以确保其可接受性。&lt;/p&gt;

&lt;h4 id=&quot;用glkit-view进行绘制&quot;&gt;用GLKit View进行绘制&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)drawRect:(CGRect)rect
{
    // Clear the framebuffer
    glClearColor(0.0f, 0.0f, 0.1f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
 
    // Draw using previously configured texture, shader, uniforms, and vertex array
    glBindTexture(GL_TEXTURE_2D, _planetTexture);
    glUseProgram(_diffuseShading);
    glUniformMatrix4fv(_uniformModelViewProjectionMatrix, 1, 0, _modelViewProjectionMatrix.m);
    glBindVertexArrayOES(_planetMesh);
    glDrawElements(GL_TRIANGLE_STRIP, 256, GL_UNSIGNED_SHORT);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注意：glClear函数提示OpenGL ES可以丢弃任何现有的帧缓冲区内容，避免了将以前的内容加载到内存中的昂贵的内存操作。 为确保最佳性能，在绘制之前应始终调用此函数。&lt;/p&gt;

&lt;p&gt;GLKView类能够为OpenGL ES绘图提供一个简单的接口，因为它管理着OpenGL ES渲染过程的标准部分：&lt;/p&gt;

&lt;p&gt;在调用绘图方法之前，视图：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使其EAGLContext对象成为当前上下文&lt;/li&gt;
  &lt;li&gt;根据当前大小，比例因子和可绘制属性（如果需要）创建帧缓冲区对象和渲染缓冲区，&lt;/li&gt;
  &lt;li&gt;将帧缓冲区对象绑定为绘图命令的当前目标&lt;/li&gt;
  &lt;li&gt;设置OpenGL ES视口以匹配帧缓冲区大小&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;绘图方法返回后，视图：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;解决多重采样缓冲区（如果启用了多重采样）&lt;/li&gt;
  &lt;li&gt;放弃其内容不再需要的渲染缓冲区&lt;/li&gt;
  &lt;li&gt;将渲染缓冲区内容呈现给Core Animation进行缓存和显示&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;用一个代理对象来进行渲染&quot;&gt;用一个代理对象来进行渲染&lt;/h4&gt;

&lt;p&gt;许多OpenGL ES应用程序在自定义类中实现渲染代码。 这种方法的一个优点是它允许您通过为每个渲染算法类定义不同的渲染器类来轻松支持多种渲染算法。 具有共同功能的渲染算法可以从父类继承。 例如，您可能使用不同的渲染器类来支持OpenGL ES 2.0和3.0（请参阅配置OpenGL ES上下文）。 或者您可以使用它们来定制渲染，以便在具有更强大硬件的设备上获得更好的图像质量&lt;/p&gt;

&lt;p&gt;GLKit非常适合这种方法 - 您可以使您的渲染器对象为标准GLKView实例的代理。 您的渲染器类不使用GLKView的子类并实现&lt;code class=&quot;highlighter-rouge&quot;&gt;drawRect：&lt;/code&gt;方法，而是使用GLKViewDelegate协议并实现&lt;code class=&quot;highlighter-rouge&quot;&gt;glkView:drawInRect:&lt;/code&gt;方法。 下面代码在应用启动时基于硬件特性选择渲染器类&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
    // Create a context so we can test for features
    EAGLContext *context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];
    [EAGLContext setCurrentContext:context];
 
    // Choose a rendering class based on device features
    GLint maxTextureSize;
    glGetIntegerv(GL_MAX_TEXTURE_SIZE, &amp;amp;maxTextureSize);
    if (maxTextureSize &amp;gt; 2048)
        self.renderer = [[MyBigTextureRenderer alloc] initWithContext:context];
    else
        self.renderer = [[MyRenderer alloc] initWithContext:context];
 
    // Make the renderer the delegate for the view loaded from the main storyboard
    GLKView *view = (GLKView *)self.window.rootViewController.view;
    view.delegate = self.renderer;
 
    // Give the OpenGL ES context to the view so it can draw
    view.context = context;
 
    return YES;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;glkit-view-controller&quot;&gt;GLKit View Controller&lt;/h4&gt;

&lt;p&gt;默认情况下，GLKView对象根据需要呈现其内容。 也就是说，使用OpenGL ES进行绘图的一个关键优势是它能够使用图形处理硬件来连续动画复杂的场景 - 例如游戏和模拟等应用很少呈现静态图像。 对于这些情况，GLKit框架提供了一个View Controller类，为其管理的GLKView对象维护一个动画循环。 该循环遵循游戏和模拟中常见的设计模式，分为两个阶段：更新和显示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_6/06.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于更新阶段，View Controller调用它自己的更新方法（或其代理的glkViewControllerUpdate方法）。在这种方法里，你应该准备绘制下一帧。例如，游戏可能会使用这种方法根据自上一帧以来接收到的输入事件来确定玩家和敌人角色的位置，科学可视化可能会使用此方法来运行其模拟步骤。如果您需要计时信息来确定下一帧的应用程序状态，请使用视图控制器的计时属性之一，例如timeSinceLastUpdate属性。在上图中，更新阶段增加一个角度变量并使用它来计算变换矩阵。&lt;/p&gt;

&lt;p&gt;对于显示阶段，View Controller调用其视图的显示方法，该方法又调用您的绘图方法。在您的绘图方法中，您将OpenGL ES绘图命令提交给GPU以呈现您的内容。为了获得最佳性能，应用程序应该在渲染新帧时开始修改OpenGL ES对象，然后提交绘制命令。显示阶段将着色器程序中的统一变量设置为更新阶段计算的矩阵，然后提交绘制命令以渲染新内容。&lt;/p&gt;

&lt;p&gt;动画循环以视图控制器的framesPerSecond属性所指示的速率在这两个阶段之间交替。您可以使用preferredFramesPerSecond属性设置所需的帧速率 - 以优化当前显示硬件的性能，视图控制器会自动选择接近您首选值的最佳帧速率。&lt;/p&gt;

&lt;p&gt;重要提示：为获得最佳效果，请选择您的应用可以始终实现的帧速率。平滑一致的帧速率产生比不规律变化的帧速率更令人愉快的用户体验。&lt;/p&gt;

&lt;h4 id=&quot;使用glkit-view-controller&quot;&gt;使用GLKit View Controller&lt;/h4&gt;

&lt;p&gt;下面代码演示了使用GLKViewController子类和GLKView实例呈现动画OpenGL ES内容的典型策略。&lt;/p&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;PlanetViewController&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// subclass of GLKViewController
&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;viewDidLoad&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;viewDidLoad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
 
    &lt;span class=&quot;c1&quot;&gt;// Create an OpenGL ES context and assign it to the view loaded from storyboard
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;GLKView&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GLKView&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EAGLContext&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;initWithAPI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kEAGLRenderingAPIOpenGLES2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
 
    &lt;span class=&quot;c1&quot;&gt;// Set animation frame rate
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;preferredFramesPerSecond&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;60&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 
    &lt;span class=&quot;c1&quot;&gt;// Not shown: load shaders, textures and vertex arrays, set up projection matrix
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setupGL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;update&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_rotation&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timeSinceLastUpdate&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M_PI_2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// one quarter rotation per second
&lt;/span&gt; 
    &lt;span class=&quot;c1&quot;&gt;// Set up transform matrices for the rotating planet
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;GLKMatrix4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modelViewMatrix&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLKMatrix4MakeRotation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_rotation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_normalMatrix&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLKMatrix3InvertAndTranspose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GLKMatrix4GetMatrix3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;modelViewMatrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_modelViewProjectionMatrix&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLKMatrix4Multiply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_projectionMatrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modelViewMatrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;glkView&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GLKView&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;drawInRect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CGRect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rect&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Clear the framebuffer
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;glClearColor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;glClear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GL_COLOR_BUFFER_BIT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GL_DEPTH_BUFFER_BIT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 
    &lt;span class=&quot;c1&quot;&gt;// Set shader uniforms to values calculated in -update
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;glUseProgram&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_diffuseShading&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;glUniformMatrix4fv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_uniformModelViewProjectionMatrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_modelViewProjectionMatrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;glUniformMatrix3fv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_uniformNormalMatrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_normalMatrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 
    &lt;span class=&quot;c1&quot;&gt;// Draw using previously configured texture and vertex array
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;glBindTexture&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GL_TEXTURE_2D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_planetTexture&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;glBindVertexArrayOES&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_planetMesh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;glDrawElements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GL_TRIANGLE_STRIP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GL_UNSIGNED_SHORT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在这个例子中，一个PlanetViewController类的实例（一个自定义的GLKViewController子类）从storyboard加载，以及一个标准的GLKView实例及其可绘制属性。 viewDidLoad方法创建一个OpenGL ES上下文并将其提供给视图，并且还设置动画循环的帧速率。&lt;/p&gt;

&lt;p&gt;视图控制器自动成为其视图的代理，因此它实现了动画循环的更新和显示阶段。 在更新方法中，它会计算显示旋转行星所需的变换矩阵。 在&lt;code class=&quot;highlighter-rouge&quot;&gt;glkView:drawInRect:&lt;/code&gt;方法中，它将这些矩阵提供给着色器程序并提交绘制命令来渲染行星几何。&lt;/p&gt;

&lt;h3 id=&quot;五绘制到其他渲染目标&quot;&gt;五、绘制到其他渲染目标&lt;/h3&gt;

&lt;p&gt;帧缓冲区对象是渲染命令的目的地。&lt;/p&gt;

&lt;p&gt;当您创建帧缓冲区对象时，您可以精确控制其颜色，深度和模板数据的存储。 您通过将图像附加到帧缓冲区来提供此存储，如下图所示。 最常见的图像附件是一个渲染缓冲区对象。 您还可以将OpenGL ES纹理附加到帧缓冲区的颜色附着点，这意味着任何绘图命令都将渲染到纹理中。 之后，纹理可以作为输入给以后的渲染命令。 您也可以在单个渲染上下文中创建多个帧缓冲区对象。 您可能会这样做，以便您可以在多个帧缓冲区之间共享相同的渲染管线和OpenGL ES资源。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_6/08.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;所有这些方法都需要手动创建帧缓冲区和渲染缓冲区对象来存储OpenGL ES上下文的渲染结果，以及编写其他代码以将其内容呈现在屏幕上，并在需要时运行动画循环。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h4 id=&quot;创建帧缓冲区对象&quot;&gt;创建帧缓冲区对象&lt;/h4&gt;
&lt;/blockquote&gt;

&lt;p&gt;根据您的应用打算执行的任务，您的应用配置不同的对象以附加到帧缓冲区对象。 在大多数情况下，配置帧缓冲区的不同之处在于哪个对象连接到帧缓冲区对象的颜色附着点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;要将帧缓冲区用于离屏图像处理，请附加渲染缓冲区。 请参阅创建离屏帧缓冲区对象。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;要将帧缓冲区图像用作稍后渲染步骤的输入，请附加纹理。 请参阅使用帧缓冲区对象渲染到纹理。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;要在核心动画层组合中使用帧缓冲区，请使用特殊的支持Core Animation的渲染缓冲区。 请参阅渲染到Core Animation Layer&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;创建离屏帧缓冲区对象&quot;&gt;创建离屏帧缓冲区对象&lt;/h4&gt;

&lt;p&gt;用于离屏渲染的帧缓冲区将其所有附件分配为OpenGL ES渲染缓冲区。 以下代码使用颜色和深度附件分配framebuffer对象。&lt;/p&gt;

&lt;p&gt;1、创建帧缓冲并将其绑定。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GLuint framebuffer;
glGenFramebuffers(1, &amp;amp;framebuffer);
glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2、创建一个颜色渲染缓冲区，为其分配存储空间，并将其附加到帧缓冲区的颜色附着点。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GLuint colorRenderbuffer;
glGenRenderbuffers(1, &amp;amp;colorRenderbuffer);
glBindRenderbuffer(GL_RENDERBUFFER, colorRenderbuffer);
glRenderbufferStorage(GL_RENDERBUFFER, GL_RGBA8, width, height);
glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, colorRenderbuffer);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3、创建深度或深度/模板渲染缓冲区，为其分配存储空间，并将其附加到帧缓冲区的深度附着点。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GLuint depthRenderbuffer;
glGenRenderbuffers(1, &amp;amp;depthRenderbuffer);
glBindRenderbuffer(GL_RENDERBUFFER, depthRenderbuffer);
glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT16, width, height);
glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthRenderbuffer);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;4、测试帧缓冲区的完整性。 只有在帧缓冲区的配置发生变化时才需要执行此测试。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GLenum status = glCheckFramebufferStatus(GL_FRAMEBUFFER) ;
if(status != GL_FRAMEBUFFER_COMPLETE) {
    NSLog(@&quot;failed to make complete framebuffer object %x&quot;, status);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在绘制到离屏渲染缓冲区之后，您可以使用glReadPixels函数将其内容返回给CPU进一步处理。&lt;/p&gt;

&lt;h4 id=&quot;使用帧缓冲区对象渲染到纹理&quot;&gt;使用帧缓冲区对象渲染到纹理&lt;/h4&gt;

&lt;p&gt;创建此帧缓冲区的代码与离屏示例几乎相同，但现在纹理已分配并附加到颜色附着点。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建帧缓冲区对象（使用与创建离线帧缓冲区对象相同的过程）。&lt;/li&gt;
  &lt;li&gt;创建目标纹理，并将其附加到帧缓冲区的颜色附着点。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// create the texture
GLuint texture;
glGenTextures(1, &amp;amp;texture);
glBindTexture(GL_TEXTURE_2D, texture);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8,  width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);
glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture, 0);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3.分配并附加深度缓冲区（与以前一样）。&lt;/p&gt;

&lt;p&gt;4.测试framebuffer的完整性（和以前一样）。&lt;/p&gt;

&lt;p&gt;尽管此示例假定您正在渲染为彩色纹理，但其他选项也是可能的。 例如，使用OES_depth_texture扩展名，您可以将纹理附加到深度附着点，以将来自场景的深度信息存储到纹理中。 您可以使用此深度信息来计算最终渲染场景中的阴影。&lt;/p&gt;

&lt;h4 id=&quot;渲染到core-animation-layer&quot;&gt;渲染到Core Animation Layer&lt;/h4&gt;

&lt;p&gt;Core Animation是iOS上图形渲染和动画的中心基础设施。 您可以使用托管使用不同iOS子系统（例如UIKit，Quartz 2D和OpenGL ES）呈现的内容的图层来组合应用的用户界面或其他可视化显示。 OpenGL ES通过CAEAGLLayer类连接到Core Animation，这是一种特殊类型的Core Animation Layer，其内容来自OpenGL ES渲染缓冲区。 Core Animation将渲染缓冲区的内容与其他图层进行合成，并在屏幕上显示结果图像。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_6/09.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;CAEAGLLayer通过提供两个关键功能为OpenGL ES提供此支持。 首先，它为渲染缓冲区分配共享存储空间。 其次，它将渲染缓冲区呈现给Core Animation，用渲染缓冲区中的数据替换该图层以前的内容。 这种模式的一个优点是核心动画层的内容不需要在每一帧中绘制，只有当渲染的图像改变时。&lt;/p&gt;

&lt;p&gt;注意：GLKView类自动执行以下步骤，所以当您想在视图的内容层中使用OpenGL ES进行绘制时应该使用它。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;创建一个CAEAGLLayer对象并配置其属性。
为了获得最佳性能，请将图层的不透明属性值设置为YES。请注意核心动画合成性能。&lt;/p&gt;

    &lt;p&gt;（可选）通过为CAEAGLLayer对象的drawableProperties属性分配一个新的字典值来配置渲染表面的表面属性。您可以指定渲染缓冲区的像素格式，并指定渲染缓冲区的内容在发送到Core Animation后是否被丢弃。有关允许的密钥列表，请参阅EAGLDrawable协议参考。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;分配OpenGL ES上下文并将其作为当前上下文。请参阅配置OpenGL ES上下文。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;创建帧缓冲区对象（如上面的创建屏幕外帧缓冲区对象）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;创建一个颜色渲染缓冲区，通过调用上下文的renderbufferStorage：fromDrawable：方法并传递图层对象作为参数来分配其存储空间。宽度，高度和像素格式取自图层并用于为渲染缓冲区分配存储空间。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GLuint colorRenderbuffer;
glGenRenderbuffers(1, &amp;amp;colorRenderbuffer);
glBindRenderbuffer(GL_RENDERBUFFER, colorRenderbuffer);
[myContext renderbufferStorage:GL_RENDERBUFFER fromDrawable:myEAGLLayer];
glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, colorRenderbuffer);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;检索颜色渲染缓冲区的高度和宽度。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GLint width;
GLint height;
glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_WIDTH, &amp;amp;width);
glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_HEIGHT, &amp;amp;height);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;在前面的例子中，渲染缓冲区的宽度和高度被明确提供来为缓冲区分配存储空间。 这里，代码在分配存储空间后从颜色渲染缓冲区中检索宽度和高度。 你的应用程序这样做是因为颜色渲染缓冲区的实际尺寸是根据图层的边界和比例因子来计算的。 附加到帧缓冲区的其他渲染缓冲区必须具有相同的尺寸。 除了使用高度和宽度分配深度缓冲区外，还可以使用它们分配OpenGL ES视口并帮助确定应用纹理和模型中所需的详细程度。 请参阅支持高分辨率显示。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;分配并附加深度缓冲区（与以前一样）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;测试framebuffer的完整性（和以前一样）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过将CAEAGLLayer对象传递给可见图层的&lt;code class=&quot;highlighter-rouge&quot;&gt;addSublayer：&lt;/code&gt;方法，将CAEAGLLayer对象添加到Core Animation图层层次结构中。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;绘制到帧缓冲区对象&quot;&gt;绘制到帧缓冲区对象&lt;/h3&gt;
&lt;/blockquote&gt;

&lt;p&gt;现在你有一个framebuffer对象，你需要填充它。 本节介绍渲染新帧并将其呈现给用户所需的步骤。 渲染到纹理或离屏帧缓冲区的行为相似，只是在应用程序使用最终帧的方式上有所不同。&lt;/p&gt;

&lt;h4 id=&quot;按需渲染或动画循环渲染&quot;&gt;按需渲染或动画循环渲染&lt;/h4&gt;

&lt;p&gt;在渲染到Core Animation层时，您必须选择何时绘制OpenGL ES内容，就像使用GLKit视图和视图控制器进行绘制时一样。 如果渲染到离屏帧缓冲区或纹理，请在适合使用这些类型的帧缓冲区的情况下进行绘制。&lt;/p&gt;

&lt;p&gt;对于按需绘制，实现您自己的方法来绘制并呈现您的渲染缓冲区，并在您想要显示新内容时调用它。&lt;/p&gt;

&lt;p&gt;要使用动画循环进行绘制，请使用CADisplayLink对象。 Display link是Core Animation提供的一种计时器，可让您将绘图与屏幕的刷新速率同步。&lt;/p&gt;

&lt;p&gt;注意：GLKViewController类自动使用CADisplayLink对象来动画GLKView内容。 只有当您需要超出GLKit框架提供的行为时，才可以直接使用CADisplayLink类。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;displayLink = [myView.window.screen displayLinkWithTarget:self selector:@selector(drawFrame)];
[displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在实现drawFrame方法的内部，读取displaylink的timestamp属性以获取要渲染的下一帧的时间戳。 它可以使用该值来计算下一帧中对象的位置。&lt;/p&gt;

&lt;p&gt;通常，每次刷新屏幕时都会触发displaylink对象; 该值通常为60 Hz，但在不同设备上可能会有所不同。 大多数应用程序不需要每秒刷新屏幕60次。 您可以将displaylink的frameInterval属性设置为调用方法之前的实际帧数。 例如，如果帧间隔设置为3，则应用程序每隔三帧调用一次，或每秒大约20帧。&lt;/p&gt;

&lt;p&gt;注意：为获得最佳效果，请选择您的应用可以始终实现的帧速率。 平滑一致的帧速率产生比不规律变化的帧速率更令人愉快的用户体验。&lt;/p&gt;

&lt;h4 id=&quot;渲染一帧&quot;&gt;渲染一帧&lt;/h4&gt;

&lt;p&gt;下图展示了OpenGL ES应用程序在iOS上呈现并呈现帧的步骤。 这些步骤包括许多提示，以提高应用程序的性能。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_6/10.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;清缓存&quot;&gt;清缓存&lt;/h5&gt;

&lt;p&gt;在每个帧的开始处，擦除所有帧缓冲区附件的内容，其内容不需要先前的帧来绘制下一帧。 调用glClear函数，将所有缓冲区的位掩码传入以清除&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);
glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对OpenGL ES使用glClear可以放弃渲染缓冲区或纹理的现有内容，从而避免将以前内容加载到内存中的代价高昂的操作。&lt;/p&gt;

&lt;h5 id=&quot;准备资源并执行绘图命令&quot;&gt;准备资源并执行绘图命令&lt;/h5&gt;

&lt;p&gt;这两个步骤涵盖了您在设计应用程序体系结构时所做的大部分关键决策。首先，您决定要向用户显示哪些内容，并配置相应的OpenGL ES对象（例如顶点缓冲区对象，纹理，着色器程序及其输入变量），以便上传到GPU。接下来，您提交绘图命令，告诉GPU如何使用这些资源来渲染帧。&lt;/p&gt;

&lt;p&gt;渲染器设计在OpenGL ES设计指南中有更详细的介绍。现在，要注意的最重要的性能优化是，如果只在渲染新帧时开始修改OpenGL ES对象，则应用运行得更快。虽然您的应用程序可以在修改对象和提交绘图命令（如图4-3中的虚线所示）之间进行切换，但如果每帧仅执行一次每一步，则运行速度会更快。&lt;/p&gt;

&lt;h5 id=&quot;执行绘图命令&quot;&gt;执行绘图命令&lt;/h5&gt;

&lt;p&gt;这一步将获取您在上一步中准备的对象并提交绘图命令以使用它们。在OpenGL ES设计指南中详细介绍了设计这部分渲染代码以便高效运行。目前，要注意的最重要的性能优化是，如果您的应用在渲染新帧时只修改OpenGL ES对象，则运行速度会更快。虽然您的应用程序可以在修改对象和提交绘图命令之间进行切换（如虚线所示），但如果只执行一次每个步骤，则运行速度会更快。&lt;/p&gt;

&lt;h5 id=&quot;解决多重采样&quot;&gt;解决多重采样&lt;/h5&gt;

&lt;p&gt;如果您的应用使用多重采样来提高图像质量，则应用必须在将像素呈现给用户之前先解析这些像素。多重采样在使用多重采样来提高图像质量方面有详细的介绍。&lt;/p&gt;

&lt;h5 id=&quot;放弃不需要的渲染缓冲区&quot;&gt;放弃不需要的渲染缓冲区&lt;/h5&gt;

&lt;p&gt;丢弃操作是一个性能提示，告诉OpenGL ES不再需要一个或多个渲染缓冲区的内容。通过暗示OpenGL ES您不需要渲染缓冲区的内容，缓冲区中的数据可以被丢弃，并且可以避免昂贵的任务来保持这些缓冲区的内容更新。&lt;/p&gt;

&lt;p&gt;在渲染循环的这个阶段，你的应用程序已经提交了该帧的所有绘图命令。虽然您的应用程序需要颜色渲染缓冲区才能显示到屏幕上，但它可能不需要深度缓冲区的内容。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const GLenum discards[]  = {GL_DEPTH_ATTACHMENT};
glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);
glDiscardFramebufferEXT(GL_FRAMEBUFFER,1,discards);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注意：glDiscardFramebufferEXT函数由OpenGL ES 1.1和2.0的EXT_discard_framebuffer扩展提供。 在OpenGL ES 3.0上下文中，改用glInvalidateFramebuffer函数。&lt;/p&gt;

&lt;h4 id=&quot;给core-animation展示结果&quot;&gt;给Core Animation展示结果&lt;/h4&gt;

&lt;p&gt;在此步骤中，颜色渲染缓冲区保存完成的帧，因此您只需将其呈现给用户即可。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;glBindRenderbuffer(GL_RENDERBUFFER, colorRenderbuffer);
[context presentRenderbuffer:GL_RENDERBUFFER];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;默认情况下，您必须假设在您的应用呈现渲染缓冲区后渲染缓冲区的内容将被丢弃。 这意味着每次您的应用呈现一个框架时，它必须在呈现新框架时完全重新创建框架的内容。 出于这个原因，上面的代码总是会擦除颜色缓冲区。&lt;/p&gt;

&lt;p&gt;如果您的应用想要在帧之间保留颜色渲染缓冲区的内容，请将kEAGLDrawablePropertyRetainedBacking键添加到存储在CAEAGLLayer对象的drawableProperties属性中的字典中，并从先前的glClear函数调用中移除GL_COLOR_BUFFER_BIT常量。 保留的支持可能需要iOS分配额外的内存来保存缓冲区的内容，这可能会降低应用程序的性能。&lt;/p&gt;

&lt;h4 id=&quot;使用多重采样提高图像质量&quot;&gt;使用多重采样提高图像质量&lt;/h4&gt;

&lt;p&gt;多重采样是抗锯齿的一种形式，可平滑锯齿边缘并提高大多数3D应用程序的图像质量。 OpenGL ES 3.0包括多重采样作为核心规范的一部分，iOS通过APPLE_framebuffer_multisample扩展在OpenGL ES 1.1和2.0中提供。多重采样使用更多的内存和片段处理时间来渲染图像，但与使用其他方法相比，它可以以更低的性能成本提高图像质量。&lt;/p&gt;

&lt;p&gt;下图显示了多采样如何工作。您的应用程序不会创建一个帧缓冲区对象，而是创建两个。多重采样缓冲区包含呈现您的内容所需的所有附件（通常为颜色和深度缓冲区）。解析缓冲区仅包含向用户显示渲染图像所需的附件（通常是颜色渲染缓冲区，但可能是纹理），它使用创建帧缓冲区对象的相应过程创建。多采样渲染缓冲区使用与解析帧缓冲区相同的尺寸进行分配，但每个渲染缓冲区都包含一个附加参数，该参数指定要为每个像素存储的采样数量。您的应用将其所有渲染执行到多重采样缓冲区，然后通过将这些样本解析到解析缓冲区来生成最终的抗锯齿图像。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_6/11.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面显示了创建多重采样缓冲区的代码。 此代码使用先前创建的缓冲区的宽度和高度。 它调用glRenderbufferStorageMultisampleAPPLE函数为渲染缓冲区创建多重采样存储&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;glGenFramebuffers(1, &amp;amp;sampleFramebuffer);
glBindFramebuffer(GL_FRAMEBUFFER, sampleFramebuffer);
 
glGenRenderbuffers(1, &amp;amp;sampleColorRenderbuffer);
glBindRenderbuffer(GL_RENDERBUFFER, sampleColorRenderbuffer);
glRenderbufferStorageMultisampleAPPLE(GL_RENDERBUFFER, 4, GL_RGBA8_OES, width, height);
glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, sampleColorRenderbuffer);
 
glGenRenderbuffers(1, &amp;amp;sampleDepthRenderbuffer);
glBindRenderbuffer(GL_RENDERBUFFER, sampleDepthRenderbuffer);
glRenderbufferStorageMultisampleAPPLE(GL_RENDERBUFFER, 4, GL_DEPTH_COMPONENT16, width, height);
glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, sampleDepthRenderbuffer);
 
if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)
    NSLog(@&quot;Failed to make complete framebuffer object %x&quot;, glCheckFramebufferStatus(GL_FRAMEBUFFER));
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以下是修改您的渲染代码以支持多重采样的步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;在清除缓冲区步骤中，清除多重采样帧缓冲区的内容。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;glBindFramebuffer(GL_FRAMEBUFFER, sampleFramebuffer);
glViewport(0, 0, framebufferWidth, framebufferHeight);
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;提交绘图命令后，您将内容从多重采样缓冲区解析到解析缓冲区。 为每个像素存储的样本在解析缓冲区中合并为一个样本。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;glBindFramebuffer(GL_DRAW_FRAMEBUFFER_APPLE, resolveFrameBuffer);
glBindFramebuffer(GL_READ_FRAMEBUFFER_APPLE, sampleFramebuffer);
glResolveMultisampleFramebufferAPPLE();
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在放弃步骤中，您可以放弃连接到多采样帧缓冲区的两个渲染缓冲区。 这是因为您打算呈现的内容存储在解析帧缓冲区中。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const GLenum discards[]  = {GL_COLOR_ATTACHMENT0,GL_DEPTH_ATTACHMENT};
glDiscardFramebufferEXT(GL_READ_FRAMEBUFFER_APPLE,2,discards);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在“当前结果”步骤中，您将呈现附加到解析帧缓冲区的颜色渲染缓冲区。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;glBindRenderbuffer(GL_RENDERBUFFER, colorRenderbuffer);
[context presentRenderbuffer:GL_RENDERBUFFER];
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;多重采样不是免费的; 需要额外的内存来存储额外的样本，并且将样本解析到解析帧缓冲区需要时间。 如果您向应用添加多重采样，请始终测试应用的性能以确保其可接受性。&lt;/p&gt;

&lt;p&gt;注意：上面的代码假定有一个OpenGL ES 1.1或2.0上下文。 多重采样是核心OpenGL ES 3.0 API的一部分，但功能不同。&lt;/p&gt;</content><author><name>Ted</name></author><category term="基础" /><summary type="html">本文翻译自苹果官方文档OpenGL ES Programming Guide</summary></entry><entry><title type="html">OpenGL ES编程指南（一）</title><link href="http://www.helloted.com/%E5%9F%BA%E7%A1%80/2018/03/20/OpenGL_1/" rel="alternate" type="text/html" title="OpenGL ES编程指南（一）" /><published>2018-03-20T20:00:00+08:00</published><updated>2018-03-20T20:00:00+08:00</updated><id>http://www.helloted.com/%E5%9F%BA%E7%A1%80/2018/03/20/OpenGL_1</id><content type="html" xml:base="http://www.helloted.com/%E5%9F%BA%E7%A1%80/2018/03/20/OpenGL_1/">&lt;p&gt;本文翻译自苹果官方文档&lt;a href=&quot;https://developer.apple.com/library/content/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008793-CH1-SW1&quot;&gt;OpenGL ES Programming Guide&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;一关于opengl-es&quot;&gt;一、关于OpenGL ES&lt;/h3&gt;

&lt;h4 id=&quot;什么是opengl&quot;&gt;什么是OpenGL&lt;/h4&gt;

&lt;p&gt;OpenGL（全写Open Graphics Library）是指定义了一个跨编程语言、跨平台的编程接口规格的专业的图形程序接口。它用于三维图像（二维的亦可），是一个功能强大，调用方便的底层图形库。&lt;/p&gt;

&lt;p&gt;OpenGL™ 是行业领域中最为广泛接纳的 2D/3D 图形 API，其自诞生至今已催生了各种计算机平台及设备上的数千优秀应用程序。OpenGL™ 是独立于视窗操作系统或其它操作系统的，亦是网络透明的。在包含CAD、内容创作、能源、娱乐、游戏开发、制造业、制药业及虚拟现实等行业领域中，OpenGL™ 帮助程序员实现在 PC、工作站、超级计算机等硬件设备上的高性能、极具冲击力的高视觉表现力图形处理软件的开发。&lt;/p&gt;

&lt;h4 id=&quot;opengl主要功能是什么&quot;&gt;OpenGL主要功能是什么？&lt;/h4&gt;

&lt;p&gt;OpenGL是一个开放的三维图形软件包，它独立于窗口系统和操作系统，以它为基础开发的应用程序可以十分方便地在各种平台间移植；OpenGL可以与Visual C++紧密接口，便于实现机械手的有关计算和图形算法，可保证算法的正确性和可靠性；OpenGL使用简便，效率高。它具有七大功能：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1、建模：OpenGL图形库除了提供基本的点、线、多边形的绘制函数外，还提供了复杂的三维物体（球、锥、多面体、茶壶等）以及复杂曲线和曲面绘制函数。&lt;/li&gt;
  &lt;li&gt;2、变换：OpenGL图形库的变换包括基本变换和投影变换。基本变换有平移、旋转、缩放、镜像四种变换，投影变换有平行投影（又称正射投影）和透视投 影两种变换。其变换方法有利于减少算法的运行时间，提高三维图形的显示速度。&lt;/li&gt;
  &lt;li&gt;3、颜色模式设置：OpenGL颜色模式有两种，即RGBA模式和颜色索引（Color Index）。&lt;/li&gt;
  &lt;li&gt;4、光照和材质设置：OpenGL光有自发光（Emitted Light）、环境光（Ambient Light）、漫反射光（Diffuse Light）和高光（Specular Light）。材质是用光反射率来表示。场景（Scene）中物体最终反映到人眼的颜色是光的红绿蓝分量与材质红绿蓝分量的反射率相乘后形成的颜色。&lt;/li&gt;
  &lt;li&gt;5、纹理映射（Texture Mapping）。利用OpenGL纹理映射功能可以十分逼真地表达物体表面细节。&lt;/li&gt;
  &lt;li&gt;6、位图显示和图象增强图象功能除了基本的拷贝和像素读写外，还提供融合（Blending）、抗锯齿（反走样）（Antialiasing）和雾（fog）的特殊图象效果处理。以上三条可使被仿真物更具真实感，增强图形显示的效果。&lt;/li&gt;
  &lt;li&gt;7、双缓存动画（Double Buffering）双缓存即前台缓存和后台缓存，简言之，后台缓存计算场景、生成画面，前台缓存显示后台缓存已画好的画面。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;opengl-es是什么&quot;&gt;OpenGL ES是什么？&lt;/h4&gt;

&lt;p&gt;OpenGL ES (OpenGL for Embedded Systems) 是 OpenGL 三维图形 API 的子集，针对手机、PDA和游戏主机等嵌入式设备而设计。该API由Khronos集团定义推广，Khronos是一个图形软硬件行业协会，该协会主要关注图形和多媒体方面的开放标准。&lt;/p&gt;

&lt;h4 id=&quot;opengl-vs-opencv&quot;&gt;OpenGL VS OpenCV&lt;/h4&gt;

&lt;p&gt;Open CV是 Open Source Computer Vision Library
Open GL是 Open Graphics Library
Open CV主要是提供图像处理和视频处理的基础算法库，还涉及一些机器学习的算法。比如你想实现视频的降噪、运动物体的跟踪、目标（比如人脸）的识别这些都是CV的领域
OpenGL则专注在Graphics，3D绘图。
其实两者的区别就是Computer Vision和Computer Graphics这两个学科之间的区别，前者专注于从采集到的视觉图像中获取信息，是用机器来理解图像；后者是用机器绘制合适的视觉图像给人看。(摘自知乎)&lt;/p&gt;

&lt;h4 id=&quot;预览&quot;&gt;预览&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Open Graphics Library&lt;/em&gt;（OpenGL）用于可视化2D和3D数据。 它是一个多用途的开放标准图形库，支持2D和3D数字内容创建，机械和建筑设计，虚拟样机，飞行模拟，视频游戏等应用。 您可以使用OpenGL来配置3D图形管道并向其提交数据。 顶点被转换并且被点亮，然后组装成图元，并被光栅化用以创建2D图像。 OpenGL旨在将函数调用转换为可发送到底层图形硬件的图形命令。 由于底层硬件专用于处理图形命令，所以OpenGL绘图通常非常快速。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;OpenGL for Embedded Systems (OpenGL ES)&lt;/em&gt; 是OpenGL的简化版本，它消除了冗余功能，提供了一个易于学习和易于在移动图形硬件中实现的库。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_6/04.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;OpenGL ES允许应用程序利用底层图形处理器的强大功能。 iOS设备上的GPU可以执行复杂的2D和3D绘图，以及最终图像中每个像素的复杂阴影计算。 如果您的应用程序的设计要求需要最直接，最全面地访问GPU硬件，则应该使用OpenGL ES。 OpenGL ES的典型客户端包括呈现3D图形的视频游戏和模拟。&lt;/p&gt;

&lt;p&gt;OpenGL ES是一个底层的，以硬件为中心的API。 虽然它提供了最强大和最灵活的图形处理工具，但它的学习曲线陡峭，对应用程序的整体设计也有重大影响。 对于需要高性能图形以进行更多专业用途的应用程序，iOS提供了几个更高层的框架：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Sprite Kit框架提供了一个为创建2D游戏而优化的硬件加速动画系统。&lt;/li&gt;
  &lt;li&gt;Core Image框架为静止和视频图像提供实时滤镜和分析。&lt;/li&gt;
  &lt;li&gt;Core Animation为所有iOS应用程序提供了硬件加速的图形渲染和动画基础结构，以及一个简单的声明式编程模型，使得实现复杂的用户界面动画变得非常简单。&lt;/li&gt;
  &lt;li&gt;您可以使用UIKit框架中的功能为Cocoa Touch用户界面添加动画，基于物理的动态效果和其他特殊效果。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;二构建适用于ios-app的opengl-es清单&quot;&gt;二、构建适用于iOS APP的OpenGL ES清单&lt;/h3&gt;

&lt;p&gt;OpenGL ES规范定义了一系列独立于平台的API，用于使用GPU硬件渲染图形。实现OpenGL ES的平台提供了：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个渲染上下文用于执行OpenGL ES命令,&lt;/li&gt;
  &lt;li&gt;帧缓冲区用于保存渲染结果，&lt;/li&gt;
  &lt;li&gt;一个或多个渲染目标用以呈现帧缓冲区内容以供显示。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在iOS中，&lt;code class=&quot;highlighter-rouge&quot;&gt;EAGLContext&lt;/code&gt;类实现了渲染上下文。 iOS只提供一种类型的帧缓冲区也就是OpenGL ES framebuffer对象，GLKView和CAEAGLLayer类实现渲染目标。&lt;/p&gt;

&lt;p&gt;在iOS中构建OpenGL ES应用程序需要考虑几个问题，其中一些是OpenGL ES编程通用的，其中一些针对iOS。按照此清单以及下面的详细部分进行使用：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;确定哪些版本的OpenGL ES为有您的应用程序需要的功能，并创建OpenGL ES上下文。&lt;/li&gt;
  &lt;li&gt;在运行时验证设备是否支持您要使用的OpenGL ES功能。&lt;/li&gt;
  &lt;li&gt;选择渲染OpenGL ES内容的位置。&lt;/li&gt;
  &lt;li&gt;确保您的应用在iOS中正常运行。&lt;/li&gt;
  &lt;li&gt;实现你的渲染引擎。&lt;/li&gt;
  &lt;li&gt;使用Xcode和Instruments调试您的OpenGL ES应用程序并调整它以获得最佳性能。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;选择版本&quot;&gt;选择版本&lt;/h4&gt;

&lt;p&gt;确定您的应用是否应该支持OpenGL ES 3.0，OpenGL ES 2.0，OpenGL ES 1.1或多个版本。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;OpenGL ES 3.0是iOS 7中的新功能。它增加了许多新功能，可以实现更高性能，通用GPU计算技术以及以前只能在桌面级硬件和游戏控制台上实现的更复杂的视觉效果。&lt;/li&gt;
  &lt;li&gt;OpenGL ES 2.0是iOS设备的基准配置文件，具有基于可编程着色器的可配置图形管道。&lt;/li&gt;
  &lt;li&gt;OpenGL ES 1.1只提供了一个基本的固定功能图形管道，并且在iOS中主要用于向后兼容。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;验证opengl-es功能&quot;&gt;验证OpenGL ES功能&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/content/documentation/DeviceInformation/Reference/iOSDeviceCompatibility/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013599&quot;&gt;&lt;em&gt;iOS Device Compatibility Reference&lt;/em&gt; &lt;/a&gt;总结了在iOS设备上可用的功能和拓展，但是为了尽可能多的系统版本和设备能够运行，你的APP应该总是在运行时查询OpenGL ES声明来检测功能。&lt;/p&gt;

&lt;p&gt;要确定特定实现的限制（如最大纹理大小或顶点属性的最大数量），请使用适当的glGet函数查找其数据，查找相应标记的值（如gl_h头中的MAX_TEXTURE_SIZE或MAX_VERTEX_ATTRIBS） 类型。&lt;/p&gt;

&lt;p&gt;要检查OpenGL ES 3.0扩展，请使用&lt;code class=&quot;highlighter-rouge&quot;&gt;glGetIntegerv&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;glGetStringi&lt;/code&gt;函数，如下面的代码示例所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;BOOL CheckForExtension(NSString *searchName)
{
    // Create a set containing all extension names.
    // (For better performance, create the set only once and cache it for future use.)
    int max = 0;
    glGetIntegerv(GL_NUM_EXTENSIONS, &amp;amp;max);
    NSMutableSet *extensions = [NSMutableSet set];
    for (int i = 0; i &amp;lt; max; i++) {
        [extensions addObject: @( (char *)glGetStringi(GL_EXTENSIONS, i) )];
    }
    return [extensions containsObject: searchName];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;要检查OpenGL ES 1.1和2.0扩展，请调用&lt;code class=&quot;highlighter-rouge&quot;&gt;glGetString&lt;/code&gt;（GL_EXTENSIONS）以获取所有扩展名的列表。&lt;/p&gt;

&lt;h4 id=&quot;选择一个渲染目标&quot;&gt;选择一个渲染目标&lt;/h4&gt;

&lt;p&gt;在iOS中，帧缓冲区对象存储绘图命令的结果。 （iOS不实现窗口系统提供的帧缓冲区。）你可以以多种方式使用帧缓冲区对象的内容：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;GLKit框架提供了一个View，该View绘制OpenGL ES内容并管理其自己的帧缓冲区对象，以及支持动画OpenGL ES内容的View Controller。使用这些类创建全屏views或将您的OpenGL ES内容合并到UIKit视图层次结构中。&lt;/li&gt;
  &lt;li&gt;CAEAGLLayer类提供了一种将OpenGL ES内容绘制为Core Animation Layer组成部分的方法。使用此类时，您必须创建自己的帧缓冲区对象。&lt;/li&gt;
  &lt;li&gt;与任何OpenGL ES实现一样，您还可以使用帧缓冲器进行离屏图形处理或渲染纹理，以用于图形管道中的其他位置。借助OpenGL ES 3.0，可以在使用多个渲染目标的渲染算法中使用离屏缓冲区。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;与ios集成&quot;&gt;与iOS集成&lt;/h4&gt;

&lt;p&gt;iOS应用程序默认支持多任务处理，但在OpenGL ES应用程序中正确处理此功能需要额外考虑。不正确地使用OpenGL ES会导致您的应用在后台被系统杀死。&lt;/p&gt;

&lt;p&gt;许多iOS设备都包含高分辨率显示器，因此您的应用应支持多种显示屏尺寸和分辨率&lt;/p&gt;

&lt;h4 id=&quot;实现渲染引擎&quot;&gt;实现渲染引擎&lt;/h4&gt;

&lt;p&gt;设计OpenGL ES绘图代码有许多可能的策略，其全部细节超出了本文档的范围。渲染引擎设计的许多方面对于OpenGL和OpenGL ES的所有实现都是通用的。&lt;/p&gt;

&lt;h4 id=&quot;调试和分析&quot;&gt;调试和分析&lt;/h4&gt;

&lt;p&gt;Xcode和Instruments提供了许多工具来跟踪渲染问题并分析应用程序中的OpenGL ES性能。&lt;/p&gt;

&lt;h3 id=&quot;三配置opengl-es上下文&quot;&gt;三、配置OpenGL ES上下文&lt;/h3&gt;

&lt;p&gt;OpenGL ES的每个实现都提供了一种方式来创建渲染上下文来管理OpenGL ES规范所需状态。 通过把上述状态放入上下文中，多个应用程序可以轻松共享图形硬件而不会相互干扰&lt;/p&gt;

&lt;h4 id=&quot;先初始化&quot;&gt;先初始化&lt;/h4&gt;

&lt;p&gt;在您的应用程序可以调用任何OpenGL ES函数之前，它必须初始化一个EAGLContext对象。 &lt;code class=&quot;highlighter-rouge&quot;&gt;EAGLContext&lt;/code&gt;类还提供了用于将OpenGL ES内容与Core Animation集成的方法。&lt;/p&gt;

&lt;h4 id=&quot;当前上下文&quot;&gt;当前上下文&lt;/h4&gt;

&lt;p&gt;iOS应用程序中的每个线程都有一个当前上下文; 当您调用OpenGL ES函数时，其实是上下文的状态发生了改变&lt;/p&gt;

&lt;p&gt;要设置线程的当前上下文，请在该线程上执行时调用EAGLContext类方法setCurrentContext：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[EAGLContext setCurrentContext: myContext];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注意：如果您的应用程序在同一线程中的两个或更多个上下文之间主动切换，请在将新上下文设置为当前上下文之前调用glFlush函数。 这确保以前提交的命令及时传送到图形硬件。&lt;/p&gt;

&lt;p&gt;获取线程的当前上下文可以用这个：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[EAGLContext currentContext];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;OpenGL ES持有与当前上下文对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;EAGLContext&lt;/code&gt;对象的强引用。 （如果您正在使用手动引用计数，则OpenGL ES将保留此对象。）当您调用setCurrentContext：方法更改当前上下文时，OpenGL ES不再引用上一个上下文。 （如果使用手动引用计数，OpenGL ES会释放EAGLContext对象。）为防止EAGLContext对象在不是当前上下文时被释放，您的应用程序必须对这些对象进行强引用（或保留）。&lt;/p&gt;

&lt;h4 id=&quot;每个上下文都针对特定版本的opengl-es&quot;&gt;每个上下文都针对特定版本的OpenGL ES&lt;/h4&gt;

&lt;p&gt;一个&lt;code class=&quot;highlighter-rouge&quot;&gt;EAGLContext&lt;/code&gt;对象只支持一个版本的OpenGL ES。例如，为OpenGL ES 1.1编写的代码与OpenGL ES 2.0或3.0上下文不兼容。使用核心OpenGL ES 2.0功能的代码与OpenGL ES 3.0上下文兼容，并且为OpenGL ES 2.0扩展设计的代码通常可以在OpenGL ES 3.0上下文中使用，只需稍作更改。许多新的OpenGL ES 3.0功能和增强的硬件功能需要OpenGL ES 3.0上下文。&lt;/p&gt;

&lt;p&gt;您的应用在创建并初始化EAGLContext对象时决定支持哪种版本的OpenGL ES。如果设备不支持请求的OpenGL ES版本，则initWithAPI：方法返回nil。在使用它之前，您的应用必须进行测试以确保上下文已成功初始化。&lt;/p&gt;

&lt;p&gt;要在应用中支持多个版本的OpenGL ES作为渲染选项，应首先尝试初始化要定位的最新版本的渲染上下文。如果返回的对象为零，请改为初始化旧版本的上下文。下面的代码表示如何执行此操作&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;EAGLContext* CreateBestEAGLContext()
{
   EAGLContext *context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES3];
   if (context == nil) {
      context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];
   }
   return context;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上下文的API属性指定上下文支持哪个版本的OpenGL ES。 您的应用程序应该测试上下文的API属性并使用它来选择正确的呈现路径。 实现此行为的常见模式是为每个呈现路径创建一个类。 您的应用程序在初始化时测试上下文并创建一次渲染器。&lt;/p&gt;

&lt;h4 id=&quot;eagl-sharegroup为上下文管理opengl-es对象&quot;&gt;EAGL Sharegroup为上下文管理OpenGL ES对象&lt;/h4&gt;

&lt;p&gt;尽管上下文保存了OpenGL ES状态，但它不直接管理OpenGL ES对象。相反，OpenGL ES对象由&lt;code class=&quot;highlighter-rouge&quot;&gt;EAGLSharegroup&lt;/code&gt;对象创建和维护。每个上下文都包含一个&lt;code class=&quot;highlighter-rouge&quot;&gt;EAGLSharegroup&lt;/code&gt;对象，它将对象创建委托给它。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_6/05.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如图所示，当两个或两个以上的上下文引用相同的Sharegroup时，Sharegroup的优点变得明显。当多个上下文连接到一个公共Sharegroup时，任何上下文创建的OpenGL ES对象都可用于所有上下文;如果绑定到与创建它的另一个上下文相同的对象标识符，则引用相同的OpenGL ES对象。移动设备上的资源往往很少;在多个上下文中创建相同内容的多个副本是浪费的。共享公共资源可以更好地利用设备上的可用图形资源。&lt;/p&gt;

&lt;p&gt;Sharegroup是一个不透明的对象;它没有应用程序可以调用的方法或属性。使用共享组对象的上下文保持强烈的引用。&lt;/p&gt;

&lt;p&gt;在两种特定情况下，Sharegroup是最有用的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当上下文之间共享的大部分资源不变时。&lt;/li&gt;
  &lt;li&gt;当您希望您的应用程序能够在渲染器的主线程以外的线程上创建新的OpenGL ES对象时。 在这种情况下，第二个上下文运行在单独的线程上，专门用于获取数据和创建资源。 资源加载后，第一个上下文可以绑定到对象并立即使用它。 &lt;code class=&quot;highlighter-rouge&quot;&gt;GLKTextureLoader&lt;/code&gt;类使用此模式来提供异步纹理加载。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;要创建引用相同Sharegroup的多个上下文，首先通过调用initWithAPI来初始化第一个上下文： 会自动为上下文创建Sharegroup。 通过调用&lt;code class=&quot;highlighter-rouge&quot;&gt;initWithAPI:sharegroup:&lt;/code&gt; 方法，第二个和之后的上下文被初始化为使用第一个上下文的Sharegroup。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;EAGLContext* firstContext = CreateBestEAGLContext();
EAGLContext* secondContext = [[EAGLContext alloc] initWithAPI:[firstContext API] sharegroup: [firstContext sharegroup]];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;重要提示&lt;/strong&gt;：与同一Sharegroup关联的所有上下文必须使用与初始上下文相同版本的OpenGL ES API。&lt;/p&gt;

&lt;p&gt;当Sharegroup由多个上下文共享时，您的应用程序有责任管理对OpenGL ES对象的状态更改。 下面是规则：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果对象未被修改，您的应用程序可能会同时访问多个上下文中的对象。&lt;/li&gt;
  &lt;li&gt;当对象被发送到上下文的命令修改时，不得在任何其他上下文中读取或修改该对象。&lt;/li&gt;
  &lt;li&gt;对象修改后，所有上下文都必须重新绑定对象才能看到更改。 如果上下文在绑定它之前引用它，则该对象的内容是未定义的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以下是您的应用程序应该遵循的更新OpenGL ES对象的步骤：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在每个可能使用该对象的上下文中调用glFlush。&lt;/li&gt;
  &lt;li&gt;在想要修改对象的上下文中，调用一个或多个OpenGL ES函数来更改对象。&lt;/li&gt;
  &lt;li&gt;在接收到状态修改命令的上下文中调用glFlush。&lt;/li&gt;
  &lt;li&gt;在其他任何情况下，重新绑定对象标识符。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Ted</name></author><category term="基础" /><summary type="html">本文翻译自苹果官方文档OpenGL ES Programming Guide</summary></entry></feed>