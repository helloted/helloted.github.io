<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://www.helloted.com/feed.xml" rel="self" type="application/atom+xml" /><link href="http://www.helloted.com/" rel="alternate" type="text/html" /><updated>2024-10-31T18:00:13+08:00</updated><id>http://www.helloted.com/feed.xml</id><title type="html">Helloted Blog</title><subtitle>曹浩之Helloted的技术博客，用于记录一些技术成长过程中的技术分享，包括客户端iOS/Android，后台Pyhon/Java，跨平台开发Flutter</subtitle><entry><title type="html">直播间秒杀抢券方案</title><link href="http://www.helloted.com/%E6%9E%B6%E6%9E%84/2023/08/10/buy/" rel="alternate" type="text/html" title="直播间秒杀抢券方案" /><published>2023-08-10T20:00:00+08:00</published><updated>2023-08-10T20:00:00+08:00</updated><id>http://www.helloted.com/%E6%9E%B6%E6%9E%84/2023/08/10/buy</id><content type="html" xml:base="http://www.helloted.com/%E6%9E%B6%E6%9E%84/2023/08/10/buy/">&lt;h3 id=&quot;一业务背景&quot;&gt;&lt;strong&gt;一、业务背景&lt;/strong&gt;&lt;/h3&gt;

&lt;h4 id=&quot;11-秒杀说明&quot;&gt;&lt;strong&gt;1.1. 秒杀说明&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;在当今的电商环境中，直播带货已成为一种重要的销售渠道，吸引了大量用户参与。为了提升用户的购买体验和参与感，超核直播间引入了“优惠券秒杀”功能。这一功能不仅能够激发用户的购买欲望，还能有效提升直播间的互动性和活跃度。&lt;/p&gt;

&lt;p&gt;优惠券秒杀功能允许主播在直播过程中通过口播的方式实时上架优惠券。用户在观看直播时，可以通过抢券的方式获取大额优惠券，从而提高购买转化率。该功能的设计旨在增强用户的参与感和紧迫感，提升直播间的整体活跃度。&lt;/p&gt;

&lt;p&gt;这些优惠券通常是游戏道具的大额满减，对于观看直播的玩家具有很大吸引力，所以秒杀活动参与热情很高。&lt;/p&gt;

&lt;h4 id=&quot;12-参与角色&quot;&gt;&lt;strong&gt;1.2 参与角色&lt;/strong&gt;&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;主播：在直播过程中，主播负责通过口播的方式介绍并上架优惠券。主播的表现和互动能力直接影响用户的参与度和购买意愿。&lt;/li&gt;
  &lt;li&gt;运营团队：运营团队在后台系统中负责录入和发布优惠券信息，包括优惠券的类型、数量、有效期等。运营团队需要确保信息的准确性和及时性，以便用户能够顺利参与抢券活动。&lt;/li&gt;
  &lt;li&gt;用户：用户在观看直播时，会看到前端页面显示的倒计时弹窗，提示“30秒后开始抢券”。用户需要在倒计时结束后，点击抢券按钮参与活动。&lt;/li&gt;
  &lt;li&gt;技术团队：通过综合考虑高并发处理、数据一致性、用户体验和安全性等多个方面，设计一个高效、稳定、安全的优惠券秒杀抢购方案，确保秒杀活动的顺利进行和用户的良好体验。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;13-业务流程&quot;&gt;&lt;strong&gt;1.3 业务流程&lt;/strong&gt;&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;优惠券录入：
    &lt;ul&gt;
      &lt;li&gt;提前录入：运营团队在直播开始前在后台系统中录入相关的优惠券信息，确保优惠券的发放和使用规则准确无误。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;优惠券上架：
    &lt;ul&gt;
      &lt;li&gt;主播口播：在直播过程中，主播通过口播的方式告知观众即将上架的优惠券信息，包括优惠券的类型、数量、使用条件等。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;运营推送：运营团队在后台系统中发布提前录入的相关的优惠券信息，并推送zhi。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;倒计时提示：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;前端页面显示倒计时弹窗：在优惠券上架的同时，前端页面会显示一个倒计时弹窗，提示用户“30秒后开始抢券”，并开始倒计时。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;倒计时逻辑：倒计时逻辑由前端实现，确保倒计时的准确性和用户体验。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;抢券开始：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;倒计时结束：当倒计时结束后，抢券按钮将变为可点击状态，用户可以点击该按钮开始抢券。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;用户点击抢券：用户点击抢券按钮后，前端将请求发送到后端服务器，进行抢券操作。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;抢券处理：
    &lt;ul&gt;
      &lt;li&gt;后端处理请求：后端服务器接收到用户的抢券请求后，进行相应的处理，包括验证用户资格、检查优惠券库存、生成优惠券等。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;反馈结果：后端处理完成后，将结果反馈给前端，前端根据结果显示相应的提示信息，如“抢券成功”或“优惠券已抢完”。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/img/Simple_1/56.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;二技术方案&quot;&gt;&lt;strong&gt;二、技术方案&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;高并发处理：秒杀活动通常会有大量用户同时访问，导致服务器压力剧增，需要设计高效的并发处理方案。&lt;/p&gt;

&lt;p&gt;有以下的技术挑战：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;用户体验：秒杀活动需要快速响应用户请求，提供良好的用户体验，避免长时间的等待和页面卡顿。&lt;/li&gt;
  &lt;li&gt;高并发处理：秒杀活动通常会有大量用户同时访问，导致服务器压力剧增，需要设计高效的并发处理方案。&lt;/li&gt;
  &lt;li&gt;安全性：秒杀活动容易受到恶意攻击，如刷单、爬虫等，需要设计有效的安全防护措施。&lt;/li&gt;
  &lt;li&gt;公平性：秒杀活动是在倒计时结束后统一启动，所以需要保证好前端时间同步，用户能在同一时间开始秒杀。&lt;/li&gt;
  &lt;li&gt;数据一致性：在高并发场景下，保证优惠券库存和用户抢券结果的一致性是一个挑战。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;21-用户体验&quot;&gt;&lt;strong&gt;2.1 用户体验&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;目标&lt;/strong&gt;：提供快速响应的用户体验，避免长时间的等待和页面卡顿。&lt;/p&gt;

&lt;p&gt;快速反馈：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;异步处理：将抢券请求异步处理，快速返回请求已接收的反馈，减少用户等待时间。&lt;/li&gt;
  &lt;li&gt;前端提示：在前端页面显示请求处理中提示，提升用户体验。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;页面优化：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;静态资源优化：优化前端静态资源的加载速度，减少页面加载时间。&lt;/li&gt;
  &lt;li&gt;CDN加速：使用CDN加速前端资源的分发，提升页面响应速度。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;降级策略：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;功能降级：在系统压力过大时，适当关闭部分非核心功能，保证核心秒杀功能的稳定性。&lt;/li&gt;
  &lt;li&gt;限流降级：在高并发场景下，适当降低限流阈值，保证系统稳定运行。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;22-高并发处理&quot;&gt;&lt;strong&gt;2.2 高并发处理&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;目标&lt;/strong&gt;：在秒杀活动中处理大量并发请求，确保系统稳定性和响应速度。&lt;/p&gt;

&lt;p&gt;前端限流：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;限流策略：在前端对用户请求进行限流，限制每个用户在一定时间内的请求次数。&lt;/li&gt;
  &lt;li&gt;倒计时提示：在秒杀开始前，通过倒计时提示用户，减少无效请求。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;后端限流：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;限流：在北极星引使用限流算法，在对请求进行限流，防止瞬时高并发请求压垮服务器。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;消息队列：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;异步处理：将用户的抢券请求通过消息队列异步处理，削峰填谷，缓解瞬时高并发压力。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;缓存：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;缓存热点数据：将优惠券库存等热点数据缓存到Redis等高性能缓存中，减少数据库访问压力。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;23--安全性&quot;&gt;&lt;strong&gt;2.3  安全性&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;目标&lt;/strong&gt;：防止恶意攻击，如刷单、爬虫等，保障系统安全。&lt;/p&gt;

&lt;p&gt;用户权限限制：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;资格认证：只有超核用户才能够参与秒杀抢券&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;验证码：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;图形验证码：在用户抢券前，要求用户输入图形验证码，防止恶意刷单。&lt;/li&gt;
  &lt;li&gt;行为验证码：使用滑动验证等行为验证码，提升安全性。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;IP限流：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;IP黑名单：对恶意IP进行黑名单处理，禁止其访问系统。&lt;/li&gt;
  &lt;li&gt;IP限流策略：对单个IP的请求频率进行限制，防止恶意攻击。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;24-公平性&quot;&gt;&lt;strong&gt;2.4 公平性&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;目标&lt;/strong&gt;：保证秒杀活动在倒计时结束后统一启动，确保所有用户在同一时间开始秒杀，提升活动的公平性&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;时间同步：&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;NTP时间同步：在服务器端使用NTP（网络时间协议）进行时间同步，确保所有服务器的时间一致。&lt;/li&gt;
  &lt;li&gt;前端时间校准：在前端页面加载时，通过与服务器进行时间校准，确保前端显示的倒计时与服务器时间一致。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;25-数据一致性&quot;&gt;&lt;strong&gt;2.5 数据一致性&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;目标&lt;/strong&gt;：保证在尽量提升性能的情况下，保证券不出现超卖现象&lt;/p&gt;

&lt;h3 id=&quot;三高并发防止超卖&quot;&gt;&lt;strong&gt;三、高并发防止超卖&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;高并发抢券，可能会出现超卖问题，针对超卖问题，业界有以下几种解决方案：&lt;/p&gt;

&lt;h4 id=&quot;31-数据库悲观锁&quot;&gt;&lt;strong&gt;3.1. 数据库悲观锁&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;在进行库存查询和更新时，使用数据库的悲观锁机制（如 SELECT … FOR UPDATE）来锁定库存记录，确保在同一时间只有一个请求可以修改库存。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;优势&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;通过锁机制，确保在并发情况下库存数据的一致性。&lt;/li&gt;
  &lt;li&gt;在现有的数据库架构中，直接使用锁机制即可实现。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;劣势&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在高并发情况下，锁会导致请求排队，影响系统性能。&lt;/li&gt;
  &lt;li&gt;如果不当使用，可能会导致死锁，影响系统稳定性。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;可能出现的问题&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在高并发情况下，锁竞争严重，可能导致用户体验下降。&lt;/li&gt;
  &lt;li&gt;需要合理设置锁的超时时间，以避免长时间锁定导致的性能问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;32-数据库乐观锁&quot;&gt;&lt;strong&gt;3.2. 数据库乐观锁&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;在库存更新时，使用乐观锁机制（如版本号或时间戳）来判断库存是否被其他请求修改。只有在版本号匹配的情况下才进行更新。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;优势&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;高并发性能：乐观锁在没有冲突时性能较好，适合读多写少的场景。&lt;/li&gt;
  &lt;li&gt;避免锁竞争：减少了锁的使用，降低了死锁的风险。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;劣势&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;冲突重试：在高并发情况下，可能会频繁出现更新失败的情况，需要重试，增加了复杂性。&lt;/li&gt;
  &lt;li&gt;数据库压力较大，容易成为瓶颈。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;可能出现的问题&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在高并发情况下，频繁的重试可能导致性能下降。&lt;/li&gt;
  &lt;li&gt;需要合理设计重试机制，以避免无限重试导致的资源浪费。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;33-redis-分布式锁&quot;&gt;&lt;strong&gt;3.3. Redis 分布式锁&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;使用 Redis 的分布式锁机制（如 Redisson 或 Lua 脚本）来控制对库存的访问。通过设置锁的过期时间，确保在高并发情况下的安全性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;优势&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;高性能：Redis 的性能优于传统数据库，能够处理高并发请求。&lt;/li&gt;
  &lt;li&gt;灵活性：可以设置锁的过期时间，避免长时间锁定。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;劣势&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;流程需要引入 Redis，增加了系统的复杂性。&lt;/li&gt;
  &lt;li&gt;锁失效风险：如果在持有锁的过程中发生故障，可能导致锁失效，影响系统稳定性。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;可能出现的问题&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;需要处理锁的过期和续期逻辑，以避免锁失效导致的超卖。&lt;/li&gt;
  &lt;li&gt;Redis 的单点故障问题需要考虑，建议使用 Redis 集群。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;34-redis库存预减&quot;&gt;&lt;strong&gt;3.4. Redis库存预减&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;在秒杀开始前，将库存数据预加载到Redis中。用户请求到达时，先在Redis中预减库存，成功后再进行后续操作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;优势&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;高性能，Redis操作速度快，适合高并发场景。&lt;/li&gt;
  &lt;li&gt;减少数据库压力，提升系统整体性能。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;劣势&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;需要处理Redis和数据库的一致性问题，增加实现复杂度。&lt;/li&gt;
  &lt;li&gt;Redis数据丢失可能导致库存不一致。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;可能出现的问题&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Redis和数据库数据不一致，导致超卖或库存浪费。&lt;/li&gt;
  &lt;li&gt;Redis数据丢失导致库存数据不准确。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;35-队列限流&quot;&gt;&lt;strong&gt;3.5. 队列限流&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;在秒杀活动开始时，使用消息队列来控制请求的流量。用户请求先进入队列，后端系统按顺序处理请求。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;优势&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;流量控制：有效控制并发请求的数量，避免瞬时流量冲击数据库。&lt;/li&gt;
  &lt;li&gt;解耦：将请求处理与库存更新解耦，提高系统的可扩展性。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;劣势&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;需要引入消息队列，增加了系统的复杂性。&lt;/li&gt;
  &lt;li&gt;由于请求需要排队处理，可能导致性能下降。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;可能出现的问题&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;需要合理设计队列的消费速率，以避免队列积压。&lt;/li&gt;
  &lt;li&gt;消息丢失或重复消费的风险需要处理。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;36综合对比&quot;&gt;&lt;strong&gt;3.6、综合对比&lt;/strong&gt;&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;方案&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;优势&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;劣势&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;可能出现的问题&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;数据库乐观锁&lt;/td&gt;
      &lt;td&gt;实现简单，维护成本低&lt;/td&gt;
      &lt;td&gt;重试次数多，数据库压力大&lt;/td&gt;
      &lt;td&gt;性能下降，锁竞争激烈&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;数据库悲观锁&lt;/td&gt;
      &lt;td&gt;数据一致性强，避免超卖&lt;/td&gt;
      &lt;td&gt;锁竞争激烈，性能瓶颈&lt;/td&gt;
      &lt;td&gt;锁等待时间长，数据库性能下降&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Redis分布式锁&lt;/td&gt;
      &lt;td&gt;高性能，适合高并发场景&lt;/td&gt;
      &lt;td&gt;实现复杂度高，Redis单点故障&lt;/td&gt;
      &lt;td&gt;锁超时导致数据不一致，Redis故障导致锁失效&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Redis库存预减&lt;/td&gt;
      &lt;td&gt;高性能，减少数据库压力&lt;/td&gt;
      &lt;td&gt;实现复杂度高，需要处理一致性问题&lt;/td&gt;
      &lt;td&gt;Redis和数据库数据不一致，Redis数据丢失&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;消息队列异步处理&lt;/td&gt;
      &lt;td&gt;削峰填谷，保证请求按顺序处理&lt;/td&gt;
      &lt;td&gt;实现复杂度高，用户等待时间长&lt;/td&gt;
      &lt;td&gt;消息队列故障导致请求丢失或处理延迟&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;四超核抢券秒杀的方案&quot;&gt;&lt;strong&gt;四、超核抢券秒杀的方案&lt;/strong&gt;&lt;/h3&gt;

&lt;h4 id=&quot;41-超核秒杀流程&quot;&gt;&lt;strong&gt;4.1 超核秒杀流程&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;综合几个防止超卖的方案，结合超核的实际情况，超核的最终抢券秒杀方案的流程如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;运营提前配置待抢购的券&lt;/li&gt;
  &lt;li&gt;主播口播即将开始下一轮抢券&lt;/li&gt;
  &lt;li&gt;运营将下一轮抢券通知推送到C端，服务端将改券信息做缓存预热。&lt;/li&gt;
  &lt;li&gt;C端接受下一轮通知，进行时间同步&lt;/li&gt;
  &lt;li&gt;C端开始倒计时&lt;/li&gt;
  &lt;li&gt;C端倒计时结束，用户开始抢券，发送抢券请求&lt;/li&gt;
  &lt;li&gt;服务端接受用户抢券请求，并验证用户是否有资格参与，如果是，则将抢券请求放入消息队列。&lt;/li&gt;
  &lt;li&gt;C端接受服务端返回用户是否参与抢券，并显示”抢券中”。&lt;/li&gt;
  &lt;li&gt;服务端消费抢券请求，通过Redis+lua进行单线程库存预减。&lt;/li&gt;
  &lt;li&gt;处理预减结果：&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;预减成功，写入数据库，告知前端用户抢券成功&lt;/li&gt;
  &lt;li&gt;预减失败，推送告知前端用户抢券失败&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;复盘统计本次抢券结果。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/img/Simple_1/57.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;42技术挑战如何解决的&quot;&gt;&lt;strong&gt;4.2、技术挑战如何解决的&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;用户体验：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;解决方案：在用户发起秒杀请求时，首先在Redis中进行资格验证（如是否为超核用户、同一IP是否已参与等），验证通过后立即返回结果，并将请求写入消息队列进行后续处理。&lt;/li&gt;
  &lt;li&gt;效果：用户在秒杀请求时，只需进行资格验证即可立即返回结果，不会有长时间的等待。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;高并发处理：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;解决方案：使用消息队列来缓冲高并发请求，后端系统按顺序从队列中读取请求并处理，避免瞬时高并发对系统的冲击。&lt;/li&gt;
  &lt;li&gt;效果：削峰控制并发流量。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;安全性：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;解决方案：在Redis中存储用户资格信息和IP参与记录，确保每个用户和IP只能参与一次。&lt;/li&gt;
  &lt;li&gt;效果：避免非超核用户参与可以保证安全性。同一个IP只能参与一次。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;公平性&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;解决方案：使用NTP（网络时间协议）进行时间同步，确保前后端时间一致。&lt;/li&gt;
  &lt;li&gt;效果：前后端时间同步，保证同一时间开启秒杀。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;数据一致性：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;解决方案：使用Redis和Lua脚本进行库存预减操作，Lua脚本在Redis中是原子执行的，确保库存检查和预减操作在一个原子操作中完成，避免并发问题导致的超卖。&lt;/li&gt;
  &lt;li&gt;效果：在处理库存更新时，Redis+Lua的预减方案，原子操作不会出现超卖。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;性能：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;解决方案：利用Redis的高性能和Lua脚本的原子性，快速处理高并发请求。同时，通过消息队列缓冲请求，进一步提高系统的处理能力。&lt;/li&gt;
  &lt;li&gt;效果：高效处理高并发请求。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;高可用&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;解决方案：使用Redis集群，避免单点故障&lt;/li&gt;
  &lt;li&gt;效果：避免单点故障&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;五业界秒杀方案补充&quot;&gt;&lt;strong&gt;五、业界秒杀方案补充&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;针对秒杀活动场景，业界还有一些提高性能和稳定性的方案：&lt;/p&gt;

&lt;h4 id=&quot;51-热点隔离&quot;&gt;&lt;strong&gt;5.1 热点隔离&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;秒杀系统设计的第一个原则就是将这种热点数据隔离出来，不要让1%的请求影响到另外的99%，隔离出来后也更方便对这1%的请求做针对性优化。针对秒杀我们做了多个层次的隔离：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;业务隔离：因为秒杀业务高并发高流量的特殊性，将其从系统中隔离出来，防止影响其他业务。&lt;/li&gt;
  &lt;li&gt;系统隔离。系统隔离更多是运行时的隔离，可以通过分组部署的方式和另外99%分开。甚至可以单独的域名，目的也是让请求落到不同的集群中。&lt;/li&gt;
  &lt;li&gt;数据隔离。秒杀所调用的数据大部分都是热数据，这部分数据库可以做隔离。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;实现隔离很有多办法，如可以按照用户来区分，给不同用户分配不同cookie，在接入层路由到不同服务接口中；还有在接入层可以对URL的不同Path来设置限流策略等。服务层通过调用不同的服务接口；数据层可以给数据打上特殊的标来区分。目的都是把已经识别出来的热点和普通请求区分开来。&lt;/p&gt;

&lt;h4 id=&quot;52-动静分离&quot;&gt;&lt;strong&gt;5.2 动静分离&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;在秒杀页面用户可能会不断刷鞋页面：通过以下措施将静态数据与动态数据隔离：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;把整个页面Cache在用户浏览器&lt;/li&gt;
  &lt;li&gt;如果强制刷新整个页面，也会请求到CDN&lt;/li&gt;
  &lt;li&gt;实际有效请求只是“刷新抢券”按钮&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这样把90%的静态数据缓存在用户端或者CDN上，当真正秒杀时用户只需要点击特殊的按钮“刷新抢券”即可，而不需要刷新整个页面，这样只向服务端请求很少的有效数据，而不需要重复请求大量静态数据。秒杀的动态数据和普通的详情页面的动态数据相比更少，性能也比普通的详情提升3倍以上。&lt;/p&gt;

&lt;h4 id=&quot;53-基于时间分片削峰&quot;&gt;&lt;strong&gt;5.3 基于时间分片削峰&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;倒计时结束，用户开始秒杀，可以在此阶段对用户分流，比如增加人机验证，答题验证，从而达到基于时间分片在前端就进行了削峰&lt;/p&gt;

&lt;h4 id=&quot;54-数据分层校验&quot;&gt;&lt;strong&gt;5.4 数据分层校验&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_1/58.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对大流量系统的数据做分层校验也是最重要的设计原则，所谓分层校验就是对大量的请求做成“漏斗”式设计，如所示：在不同层次尽可能把无效的请求过滤，“漏斗”的最末端才是有效的请求，要达到这个效果必须对数据做分层的校验，下面是一些原则：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;先做数据的动静分离&lt;/li&gt;
  &lt;li&gt;将90%的数据缓存在客户端浏览器&lt;/li&gt;
  &lt;li&gt;将动态请求的读数据Cache在Web端&lt;/li&gt;
  &lt;li&gt;对读数据不做强一致性校验&lt;/li&gt;
  &lt;li&gt;对写数据进行基于时间的合理分片&lt;/li&gt;
  &lt;li&gt;对写请求做限流保护&lt;/li&gt;
  &lt;li&gt;对写数据进行强一致性校验&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Ted</name></author><category term="架构" /><summary type="html">一、业务背景</summary></entry><entry><title type="html">直播后台架构选型</title><link href="http://www.helloted.com/%E6%9E%B6%E6%9E%84/2023/08/02/live/" rel="alternate" type="text/html" title="直播后台架构选型" /><published>2023-08-02T20:00:00+08:00</published><updated>2023-08-02T20:00:00+08:00</updated><id>http://www.helloted.com/%E6%9E%B6%E6%9E%84/2023/08/02/live</id><content type="html" xml:base="http://www.helloted.com/%E6%9E%B6%E6%9E%84/2023/08/02/live/">&lt;h3 id=&quot;一项目背景&quot;&gt;&lt;strong&gt;一、项目背景&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;【超核直播间】是一个提供给腾讯游戏管家与超 R 用户直播互动的平台。有以下主要功能：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;主播：主播是直播平台的核心，负责内容的创作和与观众的互动，包含主播的上下架管理、主播资料、主播直播信息、数据分析等功能&lt;/li&gt;
  &lt;li&gt;直播：直播模块是平台的核心功能，提供实时视频流和互动体验。包含到直播推拉流、直播间聊天/弹幕等功能。&lt;/li&gt;
  &lt;li&gt;券：券模块用于吸引用户消费和提高用户粘性。包含券资源管理，券上下架、玩家领券、玩家抢券等功能。&lt;/li&gt;
  &lt;li&gt;商品：商品模块是直播平台的商业化部分，主播可以通过直播销售商品。包含商品资源管理、商品上下架、商品购买等功能&lt;/li&gt;
  &lt;li&gt;积分：积分模块用于增强用户的参与感和忠诚度，包含积分获取、积分查询、积分排名、积分活动等功能。&lt;/li&gt;
  &lt;li&gt;抽奖：抽奖模块用于增加用户的参与感和娱乐性，包含抽奖创建、抽奖参与、抽奖结果公布、奖品发放、抽奖统计分析等功能。&lt;/li&gt;
  &lt;li&gt;PK对战：PK对战用于增加玩家互动性，包含PK创建、规则设定、参与PK、PK实时更新、PK结果、历史与统计。&lt;/li&gt;
  &lt;li&gt;其他功能：投票，公众号订阅。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;平台面向的用户是300万超核玩家，单场直播在线人数同时最高1万左右，多场直播同时在线总计最高5万左右。&lt;/p&gt;

&lt;h3 id=&quot;二业界典型架构对比&quot;&gt;&lt;strong&gt;二、业界典型架构对比&lt;/strong&gt;&lt;/h3&gt;

&lt;h4 id=&quot;21-传统三层架构&quot;&gt;2.1 传统三层架构：&lt;/h4&gt;

&lt;p&gt;传统三层架构的核心理念是分离关注点，通过分层来实现代码的模块化和可维护性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;分层结构&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_1/53.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;接口表示层：用户与系统交互的界面，负责展示数据和接收用户输入，处理请求接口的参数以及简单的封装。&lt;/li&gt;
  &lt;li&gt;业务逻辑层：负责处理业务规则和逻辑。接收来自表示层的请求，进行相应的处理，并将结果返回给表示层。&lt;/li&gt;
  &lt;li&gt;数据访问层：层负责与数据库或其他数据存储进行交互，提供数据的持久化和检索功能。它将数据存储的细节与业务逻辑层隔离开来。&lt;/li&gt;
  &lt;li&gt;基础基础层：基础结构层提供系统所需的基础设施服务，支持其他层的功能实现&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;架构流程&lt;/strong&gt;：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;第一步考虑的是数据库设计，数据表如何建，表之间的关系如何设计；&lt;/li&gt;
  &lt;li&gt;第二步就是搭建数据访问层，如选一个ORM框架或者拼接SQL操作；&lt;/li&gt;
  &lt;li&gt;第三步就是业务逻辑的实现，由于我们先设计了数据库，我们整个的思考都会围绕着数据库，想着怎么写才能把数据正确地写入数据库中，这时CRUD的标准作法就出现了；&lt;/li&gt;
  &lt;li&gt;第四步表示层主要面向用户的输出。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;优势：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;结构清晰，职责分明，易于理解和维护。三层各处理各自的事务，上层向下层引用接口与方法，下层向上层提供接口服务，各层之间调度方法时可能通过Model传值，也可以返回值Model。&lt;/li&gt;
  &lt;li&gt;各层可以独立进行单元测试，便于发现和修复问题，提高软件质量。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;劣势：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先，为各个层面提供服务的“基础结构层”的职责比较紊乱，它可以是纯粹的技术框架，也可以包含或处理一定的业务逻辑，这样一来，业务逻辑层与“基础结构层”之间就会存在依赖关系；&lt;/p&gt;

&lt;p&gt;其次，这种结构过分地突出了“数据访问”的地位，把“数据访问”与 “业务逻辑”放在了等同的地位，也就没有太多考虑面向对象，解耦的事情了，这样的代码对日常的维护自然是越来越困难的&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;试用场景：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;简单业务逻辑：三层架构适用于业务逻辑相对简单、系统功能明确的场景。&lt;/li&gt;
  &lt;li&gt;快速开发：三层架构适合需要快速开发和交付的项目，因为其结构简单，容易实现。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;22-ddd领域驱动设计&quot;&gt;&lt;strong&gt;2.2 DDD(领域驱动设计)&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;DDD的核心理念是将业务领域的复杂性作为设计的中心，通过领域模型来反映业务逻辑和规则，通过领域来驱动开发。DDD强调划分限界上下文，每个上下文内有独立的领域模型，避免不同上下文之间的概念冲突。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_1/54.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;领域层：先从业务逻辑入手开始，设计时不再考虑数据库的实现。将以前的业务逻辑层（BLL）拆分成了领域层和应用层。领域层聚焦业务对象的业务逻辑实现，体现现实世界业务的逻辑变化。它用来表达业务概念、业务状态和业务规则包含了业务所涉及的领域对象（实体、值对象）、领域服务以及它们之间的关系。这部分内容的具体表现形式就是领域模型（Domain Model）。领域驱动设计提倡富领域模型，即尽量将业务逻辑归属到领域对象上，实在无法归属的部分则以领域服务的形式进行定义。&lt;/li&gt;
  &lt;li&gt;应用层：该层不包含任何领域逻辑，但它会对任务进行协调，是各聚合的协调和编排，并可以维护应用程序的状态，因此，它更注重流程性的东西。在某些领域驱动设计的实践中，也会将其称为“工作流层”。它以较粗粒度的封闭为前端接口提供支持。除了提供上层调用外，还可以包括事件和消息的订阅。&lt;/li&gt;
  &lt;li&gt;表现层：跟三层里的表现层意思差不多，是对接口和交互的处理。&lt;/li&gt;
  &lt;li&gt;基础结构层：基础设施层不涉及业务，是数据的出向接口，封装数据调用的技术细节。可为其它任意层提供服务，但为了解决耦合的问题采用了依赖倒置原则。其它层只依赖基础设施的接口，于具体实现进行分离。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;领域对象&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;确定领域对象，通常为业务描述中的名词，这种方式是以对象驱动行为的发生，这种是最常见的一种方式。对象是行为能力的拥有者，也是行为能力的参与者。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;实体对象：具有唯一标识，能单独存在且可变化的对象&lt;/li&gt;
  &lt;li&gt;值对象：不能单独存在或在逻辑层面单独存在无意义，且不可变化的对象&lt;/li&gt;
  &lt;li&gt;聚合：多个对象的集合，对外是一个整体&lt;/li&gt;
  &lt;li&gt;聚合根：聚合中可代表整个业务操作的实体对象，通过它提供对外访问操作，它维护聚合内部的数据一致性，它是聚合中对象的管理者&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;领域服务&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;领域服务是领域对象拥有的行为能力，它必须是以现实业务的角度去识别，不以技术或数据的角度去分析&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;领域服务是对外可提供哪些服务，需要遵循现实业务的操作，这种服务的定义是粗粒度且高内聚的，不以程序逻辑或数据库逻辑来设计定义出增删改查。&lt;/li&gt;
  &lt;li&gt;服务接口的定义，输入输出参数尽量考虑以对象的形式，充分兼容各种场景变化&lt;/li&gt;
  &lt;li&gt;领域服务的实现主要关注逻辑实现，切勿包含技术基础类代码，比如缓存实现，数据库实现，远程调用等&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;领域边界：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;领域边界的划分就是划分功能的实现范围，行为能力的归属，对象间的解耦，明确系统结构关系。划分的标准也是以现实业务对象为参考点。 每个领域相对独立，各自的作用、结构与地位也不一样，有核心域，支撑域，通用域等。各域间明确通讯方式，根据不同的使用场景，有同步的也有异步的，并确认通讯的标准。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;优势&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;增强业务和技术的对齐：DDD通过将重点放在核心业务领域和逻辑上，帮助开发团队更好地理解业务需求。这种方法鼓励使用业务领域的语言（通常称为“通用语言”或“Ubiquitous Language”）来定义所有的业务规则和流程，从而确保技术解决方案与业务目标紧密对齐。&lt;/li&gt;
  &lt;li&gt;提高软件的灵活性和可维护性：DDD推动设计聚焦于领域模型，这使得软件架构更加模块化，每个模块（或称为领域）负责处理特定的业务逻辑。这种模块化的结构不仅有助于代码的重用，还使得系统更容易理解、维护和扩展。当业务需求发生变化时，可以更容易地对系统进行调整，而不会影响到其他不相关的部分。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;劣势&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;实现复杂性：DDD的实施通常比传统的软件开发方法更为复杂。它要求开发团队具有较高的设计技能和对业务领域深入的理解。此外，构建一个准确的领域模型需要大量的前期工作和持续的维护，这可能会增加项目的初期成本和时间。&lt;/li&gt;
  &lt;li&gt;过度工程的风险：在某些情况下，尤其是在较小或较简单的项目中，采用DDD可能会导致过度工程。如果项目的复杂性不足以证明采用DDD所需的额外努力和资源，那么这种方法可能会导致不必要的复杂性和开发延迟。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;适用场景&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;复杂业务领域：当业务逻辑复杂且变化频繁时，DDD能够帮助团队更好地理解和应对这些复杂性。&lt;/li&gt;
  &lt;li&gt;大型项目：在大型项目中，DDD的分层架构和领域模型能够提供良好的组织结构，便于团队协作。&lt;/li&gt;
  &lt;li&gt;需要高可维护性的系统：当系统需要频繁更新和维护时，DDD的设计原则能够降低维护成本。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;23-两个架构对比&quot;&gt;&lt;strong&gt;2.3 两个架构对比&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;设计焦点和目的&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;传统三层架构：通常包括表示层（用户界面）、业务逻辑层和数据访问层。这种架构的主要目的是将应用程序分解为逻辑上的层，以便管理依赖关系和分离关注点，从而简化开发和维护。它主要关注于技术实现和层次分离，而不深入到业务规则或领域逻辑的细节。&lt;/li&gt;
  &lt;li&gt;领域驱动设计（DDD）：DDD关注于创建一个反映业务领域复杂性的丰富的领域模型。它强调的是深入理解业务领域，并将这种理解融入到软件设计中。DDD使用通用语言来桥接技术人员和非技术业务专家之间的沟通，确保软件紧密地与业务需求对齐。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;模块化和组件划分&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;传统三层架构：层与层之间的分界明确，每层负责特定的功能。表示层负责处理用户交互，业务逻辑层处理业务规则，数据访问层管理与数据源的交互。这种分层有助于开发和维护，但可能导致业务逻辑分散在多个层次中，从而难以管理复杂的业务规则。&lt;/li&gt;
  &lt;li&gt;领域驱动设计（DDD）：在DDD中，软件的划分基于业务领域的边界，形成多个领域模型或有界上下文（Bounded Contexts）。每个有界上下文内部可能包含多个层（如UI、应用层、领域层、基础设施层），但这些层都服务于同一个领域模型。这种方法更便于管理复杂的业务逻辑，并保持模型的内聚性。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;适用性和复杂性管理&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;传统三层架构：适用于多种类型的应用程序，特别是那些业务逻辑相对简单或标准化的项目。它的结构简单、直观，易于实现和维护，但可能在处理复杂的业务逻辑时显得力不从心。&lt;/li&gt;
  &lt;li&gt;领域驱动设计（DDD）：特别适合于业务规则复杂、业务逻辑深度与广度都很大的系统。DDD能够有效地管理复杂性，但其实施难度较高，需要团队具备较强的业务理解能力和设计能力。此外，DDD可能在项目初期增加额外的开发成本和时间。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;业务和技术的对齐&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;传统三层架构：虽然提供了技术层面的清晰结构，但可能缺乏与业务需求的深度对齐。业务规则可能被分散在多个层中，使得对业务逻辑的更改更加困难。&lt;/li&gt;
  &lt;li&gt;领域驱动设计（DDD）：强调与业务需求的紧密对齐，通过在设计和开发过程中使用通用语言和深入的领域模型，确保软件解决方案能够准确反映业务逻辑。这种方法有助于确保任何技术实现都能直接支持业务目标，使得对业务规则的更改更加直接和高效。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对于那些业务逻辑较为简单或标准化的应用程序，传统三层架构提供了一个清晰、易于管理的结构，可以快速实施并容易维护。&lt;/li&gt;
  &lt;li&gt;对于业务规则复杂、需要深入业务领域以支持持续发展和迭代的项目，DDD提供了更好的解决方案。它通过深化对业务的理解和反映这种理解在软件设计中，帮助创建更灵活、可扩展的系统。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;三超核直播平台实施的方案&quot;&gt;&lt;strong&gt;三、超核直播平台实施的方案&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;鉴于直播平台的业务功能和复杂性，在传统的三层架构基础上，融入了DDD的设计原则，以实现系统的高内聚、低耦合、易维护和高扩展性。&lt;/p&gt;

&lt;p&gt;原则：&lt;/p&gt;

&lt;p&gt;按照DDD的原则定义业务功能的有界上下文，确保每个领域内部的模型是一致的。这有助于明确不同业务领域的边界和职责，同时并不完整复用DDD全套概念，不过度设计。&lt;/p&gt;

&lt;h4 id=&quot;31-整体设计过程&quot;&gt;&lt;strong&gt;3.1 整体设计过程&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;1. 定义有界上下文，划分微服务&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先，根据业务功能和需求，将系统分为几个主要的有界上下文（Bounded Contexts）：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;主播管理：处理主播的注册、资料更新、上下架等。&lt;/li&gt;
  &lt;li&gt;直播管理：涵盖直播的创建、推拉流管理、直播信息更新、聊天/弹幕等互动功能。&lt;/li&gt;
  &lt;li&gt;营销工具：处理券的管理、发放和使用等。&lt;/li&gt;
  &lt;li&gt;商品与交易：包括商品的管理、购买以及与之相关的交易处理。&lt;/li&gt;
  &lt;li&gt;用户互动：包括积分系统、抽奖、PK对战、投票等增加用户参与感和互动性的功能。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;并且将完整服务分为，直播服务，商品服务，券服务，互动服务四个微服务。不同微服务直接通过RPC和消息组件来进行通信&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 应用三层架构&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在每个领域内，我们应用分层架构：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;表示层（Presentation Layer）：负责前端应用（H5、小程序，管理端）与后台的交互。接口处理，如API端口、WebSocket连接等。&lt;/li&gt;
  &lt;li&gt;应用层（Application Layer）：协调各个业务流程，如直播的创建流程、直播定时任务等。&lt;/li&gt;
  &lt;li&gt;领域层（Domain Layer）：包含业务逻辑和领域模型，如主播、直播、游戏商品、券、积分等领域实体和相关业务规则。&lt;/li&gt;
  &lt;li&gt;数据访问层（Persistence Layer）：负责数据的持久化，与数据库、Redis交互。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;3. 设计领域模型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对于每个有界上下文，设计详细的领域模型，确保模型能够准确反映业务规则和逻辑。例如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;主播：属性包括ID、姓名、描述、状态（在线、离线）、统计数据等。&lt;/li&gt;
  &lt;li&gt;直播：属性包括直播ID、主播ID、开始时间、状态（准备中、进行中、已结束）、观众互动数据等。&lt;/li&gt;
  &lt;li&gt;…等等&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;32-架构图&quot;&gt;&lt;strong&gt;3.2 架构图&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_1/55.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;33-架构目标&quot;&gt;&lt;strong&gt;3.3 架构目标&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;1、清晰的责任分离&lt;/p&gt;

&lt;p&gt;通过三层架构，系统的表示层、业务逻辑层和数据访问层各自的职责清晰分离。这种分离使得开发和维护各层都更为简单和高效，因为每层都只关注于其责任范围内的问题。&lt;/p&gt;

&lt;p&gt;2、深入的业务理解&lt;/p&gt;

&lt;p&gt;DDD的应用使得设计更加聚焦于业务需求和业务逻辑。通过建立丰富的领域模型和使用有界上下文来封装业务规则，系统能够更好地反映和支持实际业务操作，提高了业务和技术的对齐度。&lt;/p&gt;

&lt;p&gt;3、增强的模块化和可维护性&lt;/p&gt;

&lt;p&gt;将系统划分为多个有界上下文，每个上下文内部应用三层架构，不仅提高了代码的模块化，还降低了不同模块间的依赖。这种高度的模块化使得系统更易于扩展和维护，同时也简化了团队的并行开发工作。&lt;/p&gt;

&lt;p&gt;4、灵活的数据管理和性能优化&lt;/p&gt;

&lt;p&gt;在数据访问层，可以根据每个有界上下文的具体需求选择最合适的存储和查询策略。例如，对于需要高速读写的直播聊天功能，可以选择使用高性能Redis。这种灵活性使得系统能够更好地满足不同业务场景下的性能需求。&lt;/p&gt;

&lt;p&gt;5、更好的扩展性和并发处理&lt;/p&gt;

&lt;p&gt;通过微服务架构的思想，每个有界上下文可以独立部署和扩展，这对于处理高并发和大规模用户基础尤为重要。此外，系统内部使用消息队列和缓存等技术可以有效地处理并发请求，提高系统的响应速度和可用性。&lt;/p&gt;</content><author><name>Ted</name></author><category term="架构" /><summary type="html">一、项目背景</summary></entry><entry><title type="html">Redis之内存结构</title><link href="http://www.helloted.com/redis/2023/03/03/redis/" rel="alternate" type="text/html" title="Redis之内存结构" /><published>2023-03-03T20:00:00+08:00</published><updated>2023-03-03T20:00:00+08:00</updated><id>http://www.helloted.com/redis/2023/03/03/redis</id><content type="html" xml:base="http://www.helloted.com/redis/2023/03/03/redis/">&lt;p&gt;&lt;img src=&quot;/img/Simple_2/82.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;1redisserver&quot;&gt;&lt;strong&gt;1、redisServer&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;redis 的数据是保存在 redisServer 中的 redisDb 结构中。&lt;/p&gt;

&lt;p&gt;Redis 服务器将绝大部分的信息都保存在 server.h/redisServer。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;redisServer&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;redisDb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 数据库列表&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dbnum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// 数据库数量&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;db 中每个redisDb结构代表一个数据库，每个db是相互独立的。&lt;/li&gt;
  &lt;li&gt;dbnum 属性的值由服务器配置的 database 选项决定，默认情况下，该选项的值为16，所以Redis服务器默认会创建16个数据库。&lt;/li&gt;
  &lt;li&gt;每次访问数据时先用SELECT index命令切换数据库然后再操作。&lt;/li&gt;
  &lt;li&gt;实际上，我们只会在redisDb[0]上进行操作。&lt;/li&gt;
  &lt;li&gt;之所以会默认定义这么多db，是最初设计时考虑不同数据存在不同db上，但最后觉得很鸡肋，由于要保持向下兼容，所以就保留了这个功能。虽然实际生产中Redis实例很少会用到多个DB，但每个DB大概1m左右也不是十分耗费资源，所以无伤大雅&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2redisdb-dict&quot;&gt;&lt;strong&gt;2、redisDb-dict&lt;/strong&gt;&lt;/h4&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/* Redis数据库结构体 */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;redisDb&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 数据库键空间，存放着所有的key-value对&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;dict&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 键的过期时间&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;dict&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;expires&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;redisDb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看到，redisDb 的 dict 字典属性保存了数据库中的所有key-value，我们将这个字典称为键空间(key space)，增删改查也就是对 dict 的操作而已。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果，我们在redis中执行以下命令:&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;redis &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; SET str_key str_value
OK
redis &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; RPUSH list_key a b c
&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;integer&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;redis新添加的key-value在dict里是这样的一个结构&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/83.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;3redisdb-expires&quot;&gt;3、redisDb-expires&lt;/h4&gt;

&lt;p&gt;redisDb 中的 expires 属性保存了所有 key 的过期时间，我们姑且就称它为过期字典吧。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;过期字典中的键，是一个指针，指向了真实数据的 key，不会浪费空间多保存一次&lt;/li&gt;
  &lt;li&gt;过期字典中的值，存的是具体的过期时间点，精确到毫秒的时间戳&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个 key 过期时间到了之后，是如何进行删除的呢？Redis 使用了一下两种策略：惰性删除、定期删除&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;惰性删除&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;惰性删除策略指的是：key 在过期之后，没有立即删除，而是在读写 key 的时候，才对过期的 key 进行删除。&lt;/p&gt;

&lt;p&gt;代码实现在 db.c/expireIfNeeded 方法中。所有 key 的读写之前，都会先调用 expireIfNeeded 对 key 进行检查，如果已过期，则删除。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;定期删除&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;定期删除策略指的是：Redis 每隔一段时间，随机从数据库中取出一定量的 key 进行检查，如果已过期，则进行删除。&lt;/p&gt;

&lt;p&gt;代码实现在 expire.c/activeExpireCycle 方法中。&lt;/p&gt;

&lt;p&gt;删除的步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;从过期字典中随机 20 个 key&lt;/li&gt;
  &lt;li&gt;删除这 20 个 key 中已经过期的 key&lt;/li&gt;
  &lt;li&gt;如果过期的 key 比率超过 1/4，那就重复步骤 1&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为什么只是随机挑 一些 key 呢？因为如果把所有 key 都遍历一遍，那这个性能肯定是不能接受的！所以还需要配合惰性删除。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;过期数据的清除从来不容易，为每一条key设置一个timer，到点立刻删除的消耗太大，每秒遍历所有数据消耗也大，Redis使用了一种相对务实的做法： 当client主动访问key会先对key进行超时判断，过时的key会立刻删除。 如果clien永远都不再get那条key呢？ 它会在Master的后台，每秒10次的执行如下操作： 随机选取100个key校验是否过期，如果有25个以上的key过期了，立刻额外随机选取下100个key(不计算在10次之内)。可见，如果过期的key不多，它最多每秒回收200条左右，如果有超过25%的key过期了，它就会做得更多，但只要key不被主动get，它占用的内存什么时候最终被清理掉只有天知道。&lt;/p&gt;

&lt;h4 id=&quot;4dictht&quot;&gt;&lt;strong&gt;4、dictht&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;dictht是redisDb-dict里面存放key-value的全局哈希表，有两个，一个是实际存放key-value的，另外一个是用于rehash。&lt;/p&gt;

&lt;p&gt;ditctht 结构，表示哈希表的结构，结构里存放了哈希表数组，数组中的每个元素都是指向一个哈希表节点结构（dictEntry）的指针；&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dictht&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// HashTable数组，数组的每个元素都是个指向dictEntry结构的指针&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;dictEntry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// HashTable的大小&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// HashTable大小掩码,总是等于size - 1, 通常用来计算索引&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sizemask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 已经使用的节点数,实际上就是HashTable中已经存在的dictEntry数量&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;used&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dictht&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/84.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;5dictentry&quot;&gt;&lt;strong&gt;5、dictEntry&lt;/strong&gt;&lt;/h4&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dictEntry&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 键&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 值&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;union&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 用来指向与当前dictEntry在同一个索引的下一个dictEntry&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dictEntry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dictEntry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;dictEntry是Dictht中结点的表现形式, 每个dictEntry都保存着一个键值对&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;key属性指向键值对的键对象,&lt;/li&gt;
  &lt;li&gt;v属性则保存着键值对的值, Redis采用了联合体来定义v, 使键值对的value既可以存储一个指针, 也可以存储有符号/无符号整形数据,甚至可以存储浮点形数据, Redis使用联合体的形式来存储键值对的值可以让内存使用更加精细灵活,&lt;/li&gt;
  &lt;li&gt;另外, 既然是HashTable, 不可避免会发生两个键不同但是计算出来存放索引相同的情况, 为了解决Hash冲突的问题, dictEntry还有一个next属性, 用来指向与当前dictEntry在同一个索引的下一个dictEntry.多个 dictEntry 可以通过 next 指针串连成链表， 从这里可以看出， dictht 使用链式寻址法来解决hash冲突： 当多个不同的键拥有相同的哈希值时，哈希表用一个链表将这些键连接起来。&lt;/li&gt;
  &lt;li&gt;void * key 和 void * value 指针指向的是 Redis 对象，Redis 中的每个对象都由 redisObject 结构表示&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;6redis对象redisobject&quot;&gt;&lt;strong&gt;6、Redis对象（RedisObject）&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;dictEntry里面的void * key 和 void * value 指针指向的是 Redis 对象，Redis 中的每个对象都由 redisObject 结构表示。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;redisObject&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 数据类型，取值范围为String、List、Set、SortedSet、Hash等五种类型&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 对齐位&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;notused&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 物理编码方式，同一种数据类型可能有不同的编码方式&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;encoding&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// LRU 时间（相对于 server.lruclock）&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lru&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;22&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 引用计数，C语言来管理自己的内存，防止内存溢出。&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;refcount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 指向真正数据，如果是整型值等，则直接存储，如果是很长的字符串，则存放指向数据的地址。&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;robj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;type: 记录了对象所保存的值的类型，它的值可能是以下常量的其中一个（定义位于 redis.h）：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#define OBJ_STRING 0 // 字符串
#define OBJ_LIST 1 // 列表
#define OBJ_SET 2 // 集合
#define OBJ_ZSET 3 // 有序集
#define OBJ_HASH 4 // 哈希表
#define OBJ_MODULE 5    &lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/* Module object. */&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
#define OBJ_STREAM 6    &lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/* Stream object. */&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;encoding 记录了对象所保存的值的编码，它的值可能是以下常量的其中一个（定义位于 redis.h）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define REDIS_ENCODING_RAW 0            // 编码为字符串
#define REDIS_ENCODING_INT 1            // 编码为整数
#define REDIS_ENCODING_HT 2             // 编码为哈希表
#define REDIS_ENCODING_ZIPMAP 3         // 编码为 zipmap
#define REDIS_ENCODING_LINKEDLIST 4     // 编码为双端链表
#define REDIS_ENCODING_ZIPLIST 5        // 编码为压缩列表
#define REDIS_ENCODING_INTSET 6         // 编码为整数集合
#define REDIS_ENCODING_SKIPLIST 7       // 编码为跳跃表
#define OBJ_ENCODING_EMBSTR 8  /* Embedded sds string encoding */
#define OBJ_ENCODING_QUICKLIST 9 /* Encoded as linked list of ziplists */
#define OBJ_ENCODING_STREAM 10 /* Encoded as a radix tree of listpacks */
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ptr 是一个指针，指向实际保存值的数据结构，这个数据结构由 type 属性和 encoding 属性决定。&lt;/p&gt;

&lt;p&gt;举个例子，如果一个 redisObject 的 type 属性为 REDIS_LIST ， encoding 属性为 REDIS_ENCODING_LINKEDLIST ，那么这个对象就是一个 Redis 列表，它的值保存在一个双端链表内，而 ptr 指针就指向这个双端链表；&lt;/p&gt;

&lt;p&gt;另一方面，如果一个 redisObject 的 type 属性为 REDIS_HASH ， encoding 属性为 REDIS_ENCODING_ZIPMAP ，那么这个对象就是一个 Redis 哈希表，它的值保存在一个 zipmap 里，而 ptr 指针就指向这个 zipmap ；诸如此类。&lt;/p&gt;

&lt;p&gt;下图展示了 redisObject 、Redis 所有数据类型、以及 Redis 所有编码方式（底层实现）三者之间的关系：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/85.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;</content><author><name>Ted</name></author><category term="Redis" /><summary type="html"></summary></entry><entry><title type="html">消息队列之Pulsar</title><link href="http://www.helloted.com/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/2023/02/25/pulsar/" rel="alternate" type="text/html" title="消息队列之Pulsar" /><published>2023-02-25T20:00:00+08:00</published><updated>2023-02-25T20:00:00+08:00</updated><id>http://www.helloted.com/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/2023/02/25/pulsar</id><content type="html" xml:base="http://www.helloted.com/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/2023/02/25/pulsar/">&lt;h4 id=&quot;1架构&quot;&gt;&lt;strong&gt;1、架构&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;Apache Pulsar 在架构设计上采用了计算与存储分离的模式，消息发布和订阅相关的计算逻辑在 Broker 中完成，数据存储在 Apache BookKeeper 集群的 Bookie 节点上：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/79.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Broker(经纪人)：Broker 是 Pulsar 的核心服务组件，负责维护连接到它的生产者（Producers）和消费者（Consumers），负责处理客户端请求、管理元数据、协调消息的存储和分发。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;处理生产者和消费者的连接请求。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;管理主题、分区和订阅的元数据。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;将消息写入持久化存储（如 Apache BookKeeper）。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;从持久化存储读取消息并分发给消费者。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;进行负载均衡和故障恢复。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;BookKeeper（存储层）：是 Pulsar 的持久化存储系统，用于存储消息日志。BookKeeper 由多个 Bookie 节点组成，提供高可用性和数据持久性。BookKeeper 的主要职责包括：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;接收和存储来自 Broker 的消息。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;提供高效的日志存储和读取功能。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;通过复制机制确保数据的高可用性和一致性。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ZooKeeper：用于进行集群管理和协调。它负责元数据的管理，包括配置信息、Broker 的负载均衡、BookKeeper Ledger 的元数据等。ZooKeeper 通过维护一致的状态信息，帮助系统实现高可用性和故障恢复。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Topic：消息是通过 Topic 进行组织的。每个 Topic 可以被配置为多个分区，分区可以跨多个 Broker 进行分布，这样可以提高 Topic 的可扩展性和并行处理能力。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Namespace：Namespace 是一种逻辑分组方式，用于对 Topic 进行分组管理。一个 Namespace 可以包含多个 Topic，可以在 Namespace 级别上设置策略，如消息保留策略、认证授权等。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Subscription：订阅是消费者从 Topic 接收消息的方式。Pulsar 支持多种订阅模式，包括 Exclusive、Shared、Failover 和 Key_Shared，这些模式支持不同的消息消费需求和场景。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Geo-Replication：Pulsar 支持跨多个地理区域的数据复制，即 Geo-Replication。这允许在不同区域的 Pulsar 集群之间复制 Topic，确保数据的全球可用性和灾难恢复。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;2-数据流&quot;&gt;&lt;strong&gt;2. 数据流&lt;/strong&gt;&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;生产者到 Broker：生产者（Producers）通过 Pulsar 客户端库连接到 Broker，并将消息发送到指定的主题。Broker 接收到消息后，将其写入 BookKeeper。&lt;/li&gt;
  &lt;li&gt;Broker 到 BookKeeper：Broker 将接收到的消息写入 BookKeeper 的日志。BookKeeper 通过复制机制将消息存储在多个 Bookie 节点上，以确保数据的高可用性和一致性。&lt;/li&gt;
  &lt;li&gt;Broker到消费者：消费者（Consumers）通过 Pulsar 客户端库连接到 Broker，并订阅指定的主题。Broker 从 BookKeeper 读取消息，并将其分发给订阅了该主题的消费者。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/80.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;3高可用性和容错&quot;&gt;&lt;strong&gt;3、高可用性和容错&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;Pulsar 通过以下机制实现高可用性和容错：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;无状态 Broker：Broker 不存储任何持久化数据，所有数据都存储在 BookKeeper 中。这使得 Broker 可以随时重启或替换，而不会丢失数据。&lt;/li&gt;
  &lt;li&gt;ZooKeeper 协调：ZooKeeper 负责管理 Broker 和 Bookie 的注册、主题的分区信息等。当一个 Broker 或 Bookie 发生故障时，ZooKeeper 会检测到并将其从活跃节点列表中移除。&lt;/li&gt;
  &lt;li&gt;自动故障恢复：当一个 Broker 或 Bookie 发生故障时，其他 Broker 或 Bookie 会接管其工作，确保服务的连续性。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;4topic和分区&quot;&gt;&lt;strong&gt;4、Topic和分区&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;在Apache Pulsar中，Topic和分区是两个相关但不同的概念&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Topic（主题）：Topic是消息传递的基本单位，它可以被看作是一个主题或者主题通道，用于发布和订阅消息。每个Topic都有一个唯一的名称，用于标识和区分不同的主题。Topic可以被认为是一个逻辑上的消息容器，用于组织和管理相关的消息。&lt;/li&gt;
  &lt;li&gt;分区：一个Topic可以被分为多个Partition（分区），每个Partition是一个有序的消息队列。分区的目的是实现消息的水平扩展和负载均衡。每个分区都有一个唯一的标识符，可以通过标识符来订阅和消费特定的分区。消费者可以独立地订阅一个或多个分区，从而实现并行处理和提高吞吐量。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;理解Topic和分区的关系：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个Topic可以有一个或多个分区，分区的数量可以根据需求进行动态调整。&lt;/li&gt;
  &lt;li&gt;分区可以用于实现消息的并行处理和负载均衡，多个消费者可以同时消费不同的分区，从而提高系统的吞吐量。&lt;/li&gt;
  &lt;li&gt;分区的数量和分布可以根据消息的特性和负载情况进行调整，以满足不同的需求。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总结来说，Topic是消息传递的基本单位，而分区是Topic的一种划分方式，用于实现消息的水平扩展和负载均衡。通过合理地使用Topic和分区，可以构建高性能、可扩展和可靠的消息传递系统。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;分区特性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;每个分区由一个 Broker 负责管理。Broker 负责处理生产者和消费者的请求，将消息写入 BookKeeper，并从 BookKeeper 读取消息。分区之间是相互独立且无关的。每个分区都是一个独立的有序消息队列，它们之间没有直接的关系或依赖。&lt;/p&gt;

&lt;p&gt;以下是分区之间的一些关系和特点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;独立性：每个分区都是独立的，它们之间没有共享状态或数据。每个分区都有自己的消息序列，消费者可以独立地订阅和消费特定的分区。&lt;/li&gt;
  &lt;li&gt;并行处理：由于分区之间是独立的，多个消费者可以同时消费不同的分区，实现消息的并行处理。这样可以提高系统的吞吐量和处理能力。&lt;/li&gt;
  &lt;li&gt;负载均衡：分区的数量和分布可以根据负载情况进行调整，以实现负载均衡。当系统负载较高时，可以增加分区的数量，从而将负载分散到更多的分区上。&lt;/li&gt;
  &lt;li&gt;顺序保证：每个分区内的消息是有序的，但不同分区之间的消息顺序是无法保证的。如果需要保证全局顺序，可以使用单个分区或者其他机制来实现。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;需要注意的是，分区之间的独立性和并行处理特性使得Pulsar能够实现高吞吐量和可扩展性。&lt;/p&gt;

&lt;h4 id=&quot;5四种订阅模式&quot;&gt;&lt;strong&gt;5、四种订阅模式&lt;/strong&gt;&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Exclusive（独占模式）：一个 Subscription 只能与一个 Consumer 关联，只有这个 Consumer 可以接收到 Topic 的全部消息，如果该 Consumer 出现故障了就会停止消费。Exclusive 订阅模式下，同一个 Subscription 里只有一个 Consumer 能消费 Topic，如果多个 Consumer 订阅则会报错，适用于全局有序消费的场景。&lt;/li&gt;
  &lt;li&gt;Shared（共享模式）：在共享模式下，多个消费者可以共同订阅和消费特定的Topic或分区。消息会被均匀分配给订阅的消费者，每个消费者都可以接收到部分消息。适用于需要多个消费者并行处理消息的场景。&lt;/li&gt;
  &lt;li&gt;Key_Shared（键共享模式）：当存在多个 Consumer 时，将根据消息的 Key 进行分发，Key 相同的消息只会被分发到同一个消费者。这样可以保证具有相同键的消息被同一个消费者处理，从而实现基于键的有序性。适用于需要按照键进行有序处理的场景。&lt;/li&gt;
  &lt;li&gt;灾备模式（Failover）：当存在多个 consumer 时，将会按字典顺序排序，第一个 consumer 被初始化为唯一接受消息的消费者。当第一个 consumer 断开时，所有的消息（未被确认和后续进入的）将会被分发给队列中的下一个 consumer。适用于需要高可用性和故障转移的场景。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这些订阅模式可以根据具体的业务需求选择，以满足不同的消息处理和消费方式。通过灵活使用这些订阅模式，Pulsar可以适应各种不同的应用场景和需求。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/81.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;需要注意的是，上面的订阅模式，指的是一个订阅里，有四种模式，但是一个Topic可以有多个订阅，这样的话，多个订阅，就能达到广播模式。&lt;/p&gt;</content><author><name>Ted</name></author><category term="消息队列" /><summary type="html">1、架构</summary></entry><entry><title type="html">通道Channel</title><link href="http://www.helloted.com/golang/2023/02/11/channel/" rel="alternate" type="text/html" title="通道Channel" /><published>2023-02-11T20:00:00+08:00</published><updated>2023-02-11T20:00:00+08:00</updated><id>http://www.helloted.com/golang/2023/02/11/channel</id><content type="html" xml:base="http://www.helloted.com/golang/2023/02/11/channel/">&lt;h4 id=&quot;1channel介绍&quot;&gt;&lt;strong&gt;1、Channel介绍&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;通过共享内存来通讯和通过通讯来共享内存是并发编程中的两种编程风格。&lt;/p&gt;

&lt;p&gt;当通过共享内存来通讯的时候，我们需要一些传统的并发同步技术（比如互斥锁）来避免数据竞争。&lt;/p&gt;

&lt;p&gt;Go提供了一种独特的并发同步技术来实现通过通讯来共享内存。此技术即为Channel。 我们可以把一个Channel看作是在一个程序内部的一个先进先出（FIFO：first in first out）数据队列。 一些协程可以向此Channel发送数据，另外一些协程可以从此Channel接收数据。Go Channel可以帮助程序员轻松地避免数据竞争。&lt;/p&gt;

&lt;p&gt;尽管Go也支持几种传统的数据同步技术，但是只有Channel为一等公民。 Channel是Go中的一种类型，所以我们可以无需引进任何代码包就可以使用Channel。 几种传统的数据同步技术提供在sync和sync/atomic标准库包中。&lt;/p&gt;

&lt;p&gt;实事求是地说，每种并发同步技术都有它们各自的最佳应用场景，但是Channel的&lt;a href=&quot;https://gfw.go101.org/article/channel-use-cases.html&quot;&gt;应用范围更广&lt;/a&gt;。 使用Channel来做同步常常可以使得代码看上去更整洁和易于理解。&lt;/p&gt;

&lt;h4 id=&quot;2通道类型和值&quot;&gt;&lt;strong&gt;2、通道类型和值&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;通道类型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;和数组、切片以及映射类型一样，每个通道类型也有一个元素类型。 一个通道只能传送它的（通道类型的）元素类型的值。&lt;/p&gt;

&lt;p&gt;通道可以是双向的，也可以是单向的。假设T是一个元素类型&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;chan T  ：双向通道类型。&lt;/li&gt;
  &lt;li&gt;chan&amp;lt;- T  ：单向可发送通道类型，编译器不允许从此类型的值中接收数据。&lt;/li&gt;
  &lt;li&gt;&amp;lt;-chan T  ：单向可接收通道类型。 编译器不允许向此类型的值中发送数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通道箭头&amp;lt;-总是指向左边。类型T总是在最右。&lt;/p&gt;

&lt;p&gt;双向通道chan T可以被隐式转换为单向通道类型chan&amp;lt;- T和&amp;lt;-chan T，但反之不行（即使显式也不行）。 类型chan&amp;lt;- T和&amp;lt;-chan T的值也不能相互转换。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;通道零值&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通道类型的零值也使用nil来表示。&lt;/p&gt;

&lt;p&gt;一个非零通道值必须通过内置的make函数来创建。 比如make(chan int, 10)将创建一个元素类型为int，容量为10的通道值。 第二个参数指定了欲创建的通道的容量。此第二个实参是可选的，它的默认值为0。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;缓存、非缓存&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个容量为0的通道值称为一个非缓冲通道（unbuffered channel）；&lt;/li&gt;
  &lt;li&gt;一个容量不为0的通道值称为一个缓冲通道（buffered channel）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;通道的堵塞：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果 buffered channel 中还有数据，那么，从这个 channel 接收数据的时候就不会阻塞，&lt;/li&gt;
  &lt;li&gt;如果 buffered channel 还未满（“满”指达到其容量），给它发送数据也不会阻塞，否则就会阻塞。&lt;/li&gt;
  &lt;li&gt;unbuffered chan 只有读写都准备好之后才不会阻塞，这也是很多使用 unbuffered chan 时的常见 Bug。&lt;/li&gt;
  &lt;li&gt;nil 是 chan 的零值，是一种特殊的 chan，对值是 nil 的 chan 的发送接收调用者总是会阻塞。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;3通道操作&quot;&gt;&lt;strong&gt;3、通道操作&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;Go中有五种通道相关的操作：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;关闭通道&lt;/li&gt;
  &lt;li&gt;向通道内发送值&lt;/li&gt;
  &lt;li&gt;从通道内接收值&lt;/li&gt;
  &lt;li&gt;查询通道容量&lt;/li&gt;
  &lt;li&gt;查询通道内队列长度&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;假设一个通道（值）为ch，下面列出了这五种操作的语法或者函数调用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.1  关闭通道：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; close(ch) 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;传给close函数调用的实参必须为一个通道，并且此通道值不能为单向接收的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.2 向通道ch发送一个值v：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; ch &amp;lt;- v  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;v必须能够赋值给通道ch的元素类型。 ch不能为单向接收通道。 &amp;lt;-称为数据发送操作符。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.3 从通道ch接收一个值：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;v = &amp;lt;-ch
v, sentBeforeClosed = &amp;lt;-ch
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接收数据时，还可以返回两个值。第一个值是返回的 chan 中的元素，很多人不太熟悉的是第二个值。第二个值是 bool 类型，代表是否成功地从 chan 中读取到一个值，如果第二个参数是 false，chan 已经被 close 而且 chan 中没有缓存的数据，这个时候，第一个值是零值。所以，如果从 chan 读取到一个零值，可能是 sender 真正发送的零值，也可能是 closed 的并且没有缓存元素产生的零值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.4 查询一个通道的容量：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cap(ch) 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中cap是一个已经在&lt;a href=&quot;https://gfw.go101.org/article/container.html#cap-len&quot;&gt;容器类型&lt;/a&gt;一文中介绍过的内置函数。 cap的返回值的类型为内置类型int。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.5 查询一个通道的长度：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;           ```        
            len(ch)      
           ```
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中len是一个已经在&lt;a href=&quot;https://gfw.go101.org/article/container.html#cap-len&quot;&gt;容器类型&lt;/a&gt;一文中介绍过的内置函数。 len的返回值的类型也为内置类型int。 一个通道的长度是指当前有多少个已被发送到此通道但还未被接收出去的元素值。&lt;/p&gt;

&lt;h4 id=&quot;4channel-的五种应用场景&quot;&gt;4、&lt;strong&gt;channel 的五种应用场景&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/78.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1、消息交流&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;channel 的底层是一个循环队列，当队列的长度大于 0 的 时候，它会被当做线程安全队列和 buffer。利用这个特性，一个 goroutine 可以安全的往 channel 中存放数据，另一个 goroutine 可以安全的从 channel 中读取数据，这样就实现了 goroutine 之间的消息交流。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、数据传递&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;数据传递类似游戏“击鼓传花”。鼓响时，花（或者其它物件）从一个人手里传到下一个人，数据就类似这里的花。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、信号通知&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;channel 类型有这样一个特性：如果 channel 为空，那么 recevier 接收数据的时候就会阻塞，直到有新的数据进来或者 channel 被关闭。&lt;/p&gt;

&lt;p&gt;利用这个特性，就可以实现 wait/notify 设计模式。另外还有一个经常碰到的场景，实现程序的 graceful shutdown。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;......&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// 执行业务处理&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

  &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// 处理CTRL+C等中断信号&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;termChan&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Notify&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;termChan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;syscall&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SIGINT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;syscall&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SIGTERM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;termChan&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; 

  &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// 执行退出之前的清理动作&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;doCleanup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
  
  &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;优雅退出&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;4、锁&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;利用 channel 我们也能实现锁的功能。&lt;/p&gt;

&lt;p&gt;sync.Mutex 通过修改持有锁标记位的状态达到占有锁的目的，因此 channel 可以通过转移这个标记位的所有权实现占有锁。&lt;/p&gt;

&lt;p&gt;具体代码如下：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// 使用chan实现互斥锁&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mutex&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// 使用锁需要初始化&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewMutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mutex&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}{}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// 请求锁，直到获取到&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// 解锁&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}{}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;unlock of unlocked mutex&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// 尝试获取锁&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TryLock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;no&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// 加入一个超时的设置&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LockTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Duration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timer&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewTimer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Stop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;no&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// 锁是否已被持有&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IsLocked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewMutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TryLock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;locked v %v&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TryLock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;locked %v&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里实现锁主要利用了向满 channel 发送数组或从空 channel 接收数据会阻塞的特性。另外，利用 select 很容易实现 TryLock 和 Timeout 的功能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5、任务编排&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通过 WaitGroup，我们能很容易的实现 等待一组 goroutine 完成任务这种任务编排需求。同样，我们也可以用 channel 实现。&lt;/p&gt;

&lt;p&gt;但是如果任务编排再复杂一些呢？如果面试官出了下面这个题目：&lt;/p&gt;

&lt;p&gt;有一批任务需要处理，但是机器资源有限，只能承受100的并发度，该如何实现？&lt;/p&gt;

&lt;p&gt;一种解决方案就是使用 channel，代码如下：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{})&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;//执行任务&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}{}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;concurrency100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}{}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;利用 sender 给满员的 channel 发送数据会阻塞的特性，就实现了并发度始终维持在 100 的需求。&lt;/p&gt;</content><author><name>Ted</name></author><category term="Golang" /><summary type="html">1、Channel介绍</summary></entry><entry><title type="html">数据库文件</title><link href="http://www.helloted.com/%E6%95%B0%E6%8D%AE%E5%BA%93/2023/01/15/file/" rel="alternate" type="text/html" title="数据库文件" /><published>2023-01-15T20:00:00+08:00</published><updated>2023-01-15T20:00:00+08:00</updated><id>http://www.helloted.com/%E6%95%B0%E6%8D%AE%E5%BA%93/2023/01/15/file</id><content type="html" xml:base="http://www.helloted.com/%E6%95%B0%E6%8D%AE%E5%BA%93/2023/01/15/file/">&lt;p&gt;在数据库中， 不论读一行，还是读多行，都是将这些行所在的页进行加载。&lt;/p&gt;

&lt;p&gt;也就是说存储空间的基本单位是页。&lt;/p&gt;

&lt;p&gt;一个页就是一棵树B+树的节点，数据库I/O操作的最小单位是页，与数据库相关的内容都会存储在页的结构里。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/74.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;1innodb的物理文件&quot;&gt;&lt;strong&gt;1、InnoDB的物理文件&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;InnoDB是MySQL使用最为广泛的存储引擎。&lt;/p&gt;

&lt;p&gt;我们每创建一个 database（数据库） 都会在 /var/lib/mysql/ 目录里面创建一个以库名为名称的目录，然后保存表结构和表数据的文件都会存放在这个目录里。&lt;/p&gt;

&lt;p&gt;当我们创建一个table时， InnoDB会创建三个文件。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;.opt文件，存储当前库字符集；&lt;/li&gt;
  &lt;li&gt;.frm文件，表结构定义文件；&lt;/li&gt;
  &lt;li&gt;.ibd文件，数据实际存储文件， 并且所有的索引也将存放在这个文件中；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/75.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果我们新建一个t_order的表，会有以下几个文件&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;db.opt，用来存储当前数据库的默认字符集和字符校验规则。&lt;/li&gt;
  &lt;li&gt;t_order.frm ，t_order 的表结构会保存在这个文件。每次建立一张表都会生成一个.frm 文件，该文件是用来保存每个表的元数据信息的，主要包含表结构定义。&lt;/li&gt;
  &lt;li&gt;t_order.ibd，t_order的数据实际存储文件。每一张表的数据都存放在一个独立的 .ibd 文件，包含实际数据和索引。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2数据文件的结构&quot;&gt;&lt;strong&gt;2、数据文件的结构&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;数据文件由段（segment）、区（extent）、页（page）、行（row）组成，InnoDB存储引擎的逻辑存储结构大致如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/76.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面我们从下往上一个个看看。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;行（row）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;数据库表中的记录都是按行（row）进行存放的，每行记录根据不同的行格式，有不同的存储结构。&lt;/p&gt;

&lt;p&gt;后面我们详细介绍 InnoDB 存储引擎的行格式，也是本文重点介绍的内容。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;页（page）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I/O 操作）只能处理一行数据，效率会非常低。&lt;/p&gt;

&lt;p&gt;因此，InnoDB 的数据是按「页」为单位来读写的，也就是说，当需要读一条记录的时候，并不是将这个行记录从磁盘读出来，而是以页为单位，将其整体读入内存。&lt;/p&gt;

&lt;p&gt;默认每个页的大小为 16KB，也就是最多能保证 16KB 的连续存储空间。&lt;/p&gt;

&lt;p&gt;页是 InnoDB 存储引擎磁盘管理的最小单元，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。&lt;/p&gt;

&lt;p&gt;页的类型有很多，常见的有数据页、undo 日志页、溢出页等等。数据表中的行记录是用「数据页」来管理的总之知道表中的记录存储在「数据页」里面就行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;区（extent）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们知道 InnoDB 存储引擎是用 B+ 树来组织数据的。&lt;/p&gt;

&lt;p&gt;B+ 树中每一层都是通过双向链表连接起来的，如果是以页为单位来分配存储空间，那么链表中相邻的两个页之间的物理位置并不是连续的，可能离得非常远，那么磁盘查询时就会有大量的随机I/O，随机 I/O 是非常慢的。&lt;/p&gt;

&lt;p&gt;解决这个问题也很简单，就是让链表中相邻的页的物理位置也相邻，这样就可以使用顺序 I/O 了，那么在范围查询（扫描叶子节点）的时候性能就会很高。&lt;/p&gt;

&lt;p&gt;那具体怎么解决呢？&lt;/p&gt;

&lt;p&gt;在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I/O 了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;段（segment）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;表空间是由各个段（segment）组成的，段是由多个区（extent）组成的。段一般分为数据段、索引段和回滚段等。&lt;/p&gt;

&lt;p&gt;索引段：存放 B + 树的非叶子节点的区的集合；&lt;/p&gt;

&lt;p&gt;数据段：存放 B + 树的叶子节点的区的集合；&lt;/p&gt;

&lt;p&gt;回滚段：存放的是回滚数据的区的集合&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;每一行数据都是放在数据页，按数据页为单位把磁盘上的数据加载到内存的缓存页。真正处理数据的过程是发生在内存中的，所以需要把磁盘中的数据加载到内存中，如果是处理写入或修改请求的话，还需要把内存中的内容刷新到磁盘上，也是以页为单位，将缓存页的数据刷入磁盘上的数据页。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为何不直接更新磁盘数据？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;来个请求就直接对磁盘文件进行随机读写，然后更新磁盘文件里的数据，执行请求性能必然极差。因为磁盘随机读写性能极差，所以MySQL才设计了这套机制，通过在内存里更新数据，然后写redo log及事务提交，后台线程不定时地刷新内存数据到磁盘文件。这样每个更新请求，基本都是更新内存，然后顺序写日志文件，这两种操作性能都是很高的。&lt;/p&gt;

&lt;h3 id=&quot;3行记录格式-compact格式&quot;&gt;&lt;strong&gt;3、行记录格式-Compact格式&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;MySQL 数据存储格式主要有两种，一种是行格式，另一种是列格式。其中，行格式存储方式是 MySQL 中默认的存储方式，也是最常用的存储方式。列格式存储方式主要用于存储大数据类型的字段，例如 BLOB 和 TEXT 类型的字段。&lt;/p&gt;

&lt;p&gt;InnoDB 提供了 4 种行格式，分别是 Redundant、Compact、Dynamic和 Compressed 行格式。从 MySQL 5.1 版本之后，行格式默认设置成 Compact。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/77.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;1变长字段长度列表&quot;&gt;1：变长字段长度列表&lt;/h5&gt;

&lt;p&gt;mysql中支持一些变长数据类型（比如VARCHAR(M)、TEXT等），它们存储数据占用的存储空间不是固定的，而是会随着存储内容的变化而变化。在Compact行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表，各变长字段数据占用的字节数按照列的顺序逆序存放&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;变长字段长度列表中只存储值为 非NULL 的列内容占用的长度，值为 NULL 的列的长度是不储存的 。&lt;/li&gt;
  &lt;li&gt;并不是所有记录都有这个 变长字段长度列表 部分，比方说表中所有的列都不是变长的数据类型的话，这一部分就不需要有&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;2null值列表&quot;&gt;2：NULL值列表&lt;/h5&gt;

&lt;p&gt;NULL值列表：Compact格式会把所有可以为NULL的列统一管理起来，存在一个NULL值列表，如果表中没有允许为NULL的列，则NULL值列表也不复存在了。&lt;/p&gt;

&lt;p&gt;为什么要有NULL值列表？&lt;/p&gt;

&lt;p&gt;表中的某些列可能存储NULL值，如果把这些NULL值都放到记录的真实数据中存储会很浪费空间，所以Compact行格式把这些值为NULL的列统一管理起来，存储到NULL值列表中，它的处理过程是这样的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;首先统计表中允许存储NULL的列有哪些。&lt;/li&gt;
  &lt;li&gt;根据列的实际值，用0或者1填充NULL值列表，1代表该列的值为空，0代表该列的值不为空。&lt;/li&gt;
  &lt;li&gt;如果表中没有允许存储 NULL 的列，则 NULL值列表 也不存在了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;3记录头信息&quot;&gt;3：记录头信息&lt;/h5&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;名称&lt;/th&gt;
      &lt;th&gt;大小(单位:bit)&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;预留位1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;未使用&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;预留位2&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;未使用&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;delete_mask&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;标记改记录是否被删除&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;min_rec_mask&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;B+树非叶子节点中最小记录都会添加该标记&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;n_owned&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;当前记录拥有的记录数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;heap_no&lt;/td&gt;
      &lt;td&gt;13&lt;/td&gt;
      &lt;td&gt;当前记录在记录堆的位置信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;record_type&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;记录类型 0：普通记录 1：B+树非叶子节点记录2：最小记录3：最大记录&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;next_record&lt;/td&gt;
      &lt;td&gt;16&lt;/td&gt;
      &lt;td&gt;下一条记录的相对位置&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;为什么「变长字段长度列表」的信息要按照逆序存放？&lt;/p&gt;

&lt;p&gt;这个设计是有想法的，主要是因为「记录头信息」中指向下一个记录的指针，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。&lt;/p&gt;

&lt;p&gt;「变长字段长度列表」中的信息之所以要逆序存放，是因为这样可以使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU Cache Line 中，这样就可以提高 CPU Cache 的命中率。&lt;/p&gt;

&lt;p&gt;同样的道理， NULL 值列表的信息也需要逆序存放。&lt;/p&gt;

&lt;p&gt;varchar(n) 中 n 最大取值为多少？&lt;/p&gt;

&lt;p&gt;一行记录最大能存储 65535 字节的数据，但是这个是包含「变长字段字节数列表所占用的字节数」和「NULL值列表所占用的字节数」。所以， 我们在算 varchar(n) 中 n 最大值时，需要减去这两个列表所占用的字节数。&lt;/p&gt;

&lt;p&gt;如果一张表只有一个 varchar(n) 字段，且允许为 NULL，字符集为 ascii。varchar(n) 中 n 最大取值为 65532。&lt;/p&gt;

&lt;p&gt;计算公式：65535 - 变长字段字节数列表所占用的字节数 - NULL值列表所占用的字节数 = 65535 - 2 - 1 = 65532。&lt;/p&gt;

&lt;p&gt;如果有多个字段的话，要保证所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 &amp;lt;= 65535。&lt;/p&gt;

&lt;p&gt;行溢出后，MySQL 是怎么处理的？&lt;/p&gt;

&lt;p&gt;如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。&lt;/p&gt;

&lt;p&gt;Compact 行格式针对行溢出的处理是这样的：当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。&lt;/p&gt;</content><author><name>Ted</name></author><category term="数据库" /><summary type="html">在数据库中， 不论读一行，还是读多行，都是将这些行所在的页进行加载。</summary></entry><entry><title type="html">Golang-Map</title><link href="http://www.helloted.com/golang/2023/01/05/map/" rel="alternate" type="text/html" title="Golang-Map" /><published>2023-01-05T20:00:00+08:00</published><updated>2023-01-05T20:00:00+08:00</updated><id>http://www.helloted.com/golang/2023/01/05/map</id><content type="html" xml:base="http://www.helloted.com/golang/2023/01/05/map/">&lt;h3 id=&quot;1-map的本质&quot;&gt;&lt;strong&gt;1、 map的本质&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;golang中的map是一个指针。当执行语句 make(map[k]v, hint) 的时候，其实是调用了 makemap 函数，返回了一个指针&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// makemap implements Go map creation for make(map[k]v, hint).
func makemap(t *maptype, hint int, h *hmap) *hmap    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;hmap是map的底层：是 hashmap 的“缩写”，但是hmap还不是主要存储key value的结构，hmap做的是一些map结构的基本设定。&lt;/p&gt;

&lt;h3 id=&quot;2结构&quot;&gt;&lt;strong&gt;2、结构&lt;/strong&gt;&lt;/h3&gt;

&lt;h4 id=&quot;21-实现原理&quot;&gt;&lt;strong&gt;2.1 实现原理&lt;/strong&gt;&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Go中的map是一个指针，占用8个字节，指向hmap结构体; 源码src/runtime/map.go中可以看到map的底层结构&lt;/li&gt;
  &lt;li&gt;每个map的底层结构是hmap，hmap包含若干个结构为bmap的bucket数组。每个bucket底层都采用链表结构&lt;/li&gt;
  &lt;li&gt;每个 bucket 中存储的是 Hash 值低 bit 位数值相同的元素，默认的元素个数为 BUCKETSIZE（值为 8，Go 1.17 版本中在 $GOROOT/src/cmd/compile/internal/reflectdata/reflect.go 中定义，与runtime/map.go 中常量 bucketCnt 保持一致）&lt;/li&gt;
  &lt;li&gt;当某个 bucket（比如 buckets[0]) 的 8 个空槽 slot）都填满了，且 map 尚未达到扩容的条件的情况下，运行时会建立 overflow bucket，并将这个 overflow bucket 挂在上面 bucket（如 buckets[0]）末尾的 overflow 指针上，这样两个 buckets 形成了一个链表结构，直到下一次 map 扩容之前，这个结构都会一直存在&lt;/li&gt;
  &lt;li&gt;map 结构，key和value单独排列在一起可以减少结构体对齐填充，减少内存浪费&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/64.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;22-hmap&quot;&gt;&lt;strong&gt;2.2 hmap&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;map本质是hash表（hmap），指向一堆桶（buckets）用来承接数据，每个桶（bmap）能存8组k/v。&lt;/p&gt;

&lt;p&gt;当有数据读写时，会用key的hash找到对应的桶，hash值低8位用来定位桶，高8位用来定位桶内位置，bmap里记录了tophash数组（hash的高8位），方便桶内定位。&lt;/p&gt;

&lt;p&gt;hash表就会有哈希冲突的问题（不同key的hash值一样，即hash后都指向同一个桶），为此map使用桶后链一个溢出桶（overflow）链表来解决当桶8个单元都满了，但还有数据需要存入此桶的问题。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// hmap的基础数据结构
type hmap struct {
	count     int	 // 元素的个数 == len()返回的值，必须放在第一个位置因为 len函数需要使用，所以map的len()时间复杂度是O(1)
	flags     uint8  // map的操作状态，如当前是否有别的线程正在写map、当前是否为相同大小的增长（扩容/缩容？）
	B         uint8  // hash桶buckets的数量为2^B个
	noverflow uint16 // 溢出的桶的数量的近似值
	hash0     uint32 // hash种子

	buckets    unsafe.Pointer // 指向2^B个桶组成的数组的指针，数据存在这里
	oldbuckets unsafe.Pointer // 指向扩容前的旧buckets数组，只在map增长时有效
	nevacuate  uintptr        // 计数器，标示扩容后搬迁的进度

	extra *mapextra // 保存溢出桶的链表和未使用的溢出桶数组的首地址
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/65.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/66.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;23-bmap&quot;&gt;&lt;strong&gt;2.3 bmap&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;bmap 就是我们常说的“桶”，桶里面会最多装 8 个 key，这些 key 之所以会落入同一个桶，是因为它们经过哈希计算后，哈希结果是“一类”的。在桶内，又会根据 key 计算出来的 hash 值的高 8 位来决定 key 到底落入桶内的哪个位置（tophash数组记录了key的高8位，方便key用来查找bmap，以及bmap中定位keyvaule）。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type bmap struct {
    tophash [bucketCnt]uint8
    // len为8的数组
    // 用来快速定位key是否在这个bmap中
    // 桶的槽位数组，一个桶最多8个槽位，如果key所在的槽位在tophash中，则代表该key在这个桶中
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但这只是表面(src/runtime/hashmap.go)的结构，编译期间会给它加料，动态地创建一个新的结构：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type bmap struct {
    topbits  [8]uint8
    keys     [8]keytype
    values   [8]valuetype
    pad      uintptr
    overflow uintptr
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意到 key 和 value 是各自放在一起的，并不是 key/value/key/value/… 这样的形式。源码里说明这样的好处是在某些情况下可以省略掉 padding字段，节省内存空间。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/67.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;24-tophash&quot;&gt;&lt;strong&gt;2.4 tophash&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;tophash是一个长度为8的数组，记录了key的高8位，方便桶内定位。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;向 map 插入一条数据，或者是从 map 按 key 查询数据的时候，运行时都会使用哈希函数对 key 做哈希运算，并获得一个哈希值（hashcode）&lt;/li&gt;
  &lt;li&gt;运行时会把 hashcode“一分为二”来看待，其中低位区的值用于选定 bucket，高位区的值用于在某个 bucket 中确定 key 的位置&lt;/li&gt;
  &lt;li&gt;每个 bucket 的 tophash 区域其实是用来快速定位 key 位置的，避免了逐个 key 进行比较这种代价较大的操作&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/68.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每一个tophash唯一对应一个K/V对。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/69.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;tophash是一个长度为8的数组，它不仅仅用来存放key的哈希高8位，在不同场景下它还可以标记迁移状态，bucket是否为空等。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当tophash对应的K/V被使用时，存的是key的哈希值的高8位；&lt;/li&gt;
  &lt;li&gt;当tophash对应的K/V未被使用时，存的是K/V对应位置的状态。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-go-map的扩容缩容&quot;&gt;3. go map的扩容缩容&lt;/h3&gt;

&lt;h4 id=&quot;31扩容过程&quot;&gt;&lt;strong&gt;3.1扩容过程&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;主要是由于哈希碰撞问题&lt;/p&gt;

&lt;p&gt;​    &lt;img src=&quot;/img/Simple_2/70.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;什么情况下会map扩容呢：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;溢出桶太多时会导致严重的性能下降&lt;/li&gt;
  &lt;li&gt;runtime.mapassign()可能会触发扩容的情况
    &lt;ul&gt;
      &lt;li&gt;装载因子超过6.5个（平均每个槽6.5个key）&lt;/li&gt;
      &lt;li&gt;使用太多溢出桶（溢出桶超过了普通桶）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;map的两种扩容类型:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;等量扩容（整理）：数据不多但是溢出桶太多了，使数据更紧凑&lt;/li&gt;
  &lt;li&gt;翻倍扩容：数据太多了增加普通桶的数量&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;map的扩容过程：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;步骤一&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建一组新桶&lt;/li&gt;
  &lt;li&gt;oldbuckets指向原有的桶数组&lt;/li&gt;
  &lt;li&gt;buckets指向新的桶数组&lt;/li&gt;
  &lt;li&gt;把map标记为扩容状态&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;​    &lt;img src=&quot;/img/Simple_2/71.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;步骤二&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;将所有的数据从旧桶驱逐到新桶&lt;/li&gt;
  &lt;li&gt;采用渐进式驱逐&lt;strong&gt;（好多技术都有这种思想，比如redis的rehash）&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;每次操作一个旧桶的时，将旧数据驱逐到新桶&lt;/li&gt;
  &lt;li&gt;读取时不进行驱逐，只判断读取新桶还是旧桶&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;​    &lt;img src=&quot;/img/Simple_2/72.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;步骤三&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;所有的旧桶驱逐完成后&lt;/li&gt;
  &lt;li&gt;oldbuckets回收&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;​     &lt;img src=&quot;/img/Simple_2/73.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;总结：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;装载系数或者溢出桶的增加，会触发map扩容&lt;/li&gt;
  &lt;li&gt;“扩容”可能并不是增加桶的数量，而是整理数据，使数据更加紧凑&lt;/li&gt;
  &lt;li&gt;map扩容采用渐进式，桶被操作时才会重新分配&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;32-扩容缩容的基本原理&quot;&gt;&lt;strong&gt;3.2 扩容缩容的基本原理&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;go map的扩容缩容都是grow相关的函数，这里扩容是真的，缩容是伪缩容，后面我会解释。我们先看下触发条件：&lt;/p&gt;

&lt;p&gt;触发 map 扩容的时机：在向 map 插入新 key 的时候，会进行条件检测，符合下面这 2 个条件，就会触发扩容：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;装载因子超过阈值，源码里定义的阈值是 6.5。&lt;/li&gt;
  &lt;li&gt;overflow 的 bucket 数量过多：当 B 小于 15，也就是 bucket 总数 2^B 小于 2^15 时，如果 overflow 的 bucket 数量超过 2^B；当 B &amp;gt;= 15，也就是 bucket 总数 2^B 大于等于 2^15，如果 overflow 的 bucket 数量超过 2^15。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;map只在插入元素即mapassign()函数中对是否扩容缩容进行触发，条件即是上面这段代码：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;条件1：当前不处在growing状态&lt;/li&gt;
  &lt;li&gt;条件2-1：触发扩容：map的数据量count大于hash桶数量(2B)*6.5。注意这里的(2B)只是hash数组大小，不包括溢出的桶&lt;/li&gt;
  &lt;li&gt;条件2-2：触发缩容：溢出的桶数量noverflow&amp;gt;=32768(1«15)或者&amp;gt;=hash数组大小。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;仔细观察触发的代码，扩容和缩容是同一个函数，这是怎么做到的呢？在hashGrow()开始，会先判断是否满足扩容条件，如果满足就表明这次是扩容，不满足就一定是缩容条件触发了。扩容和缩容剩下的逻辑，主要区别就在于容量变化，就是hmap.B参数，扩容时B+1则hash表容量扩大1倍，缩容时hash表容量不变。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;h.oldbuckets：指向旧的hash数组，即当前的h.buckets&lt;/li&gt;
  &lt;li&gt;h.buckets：指向新创建的hash数组&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;到这里触发的主要工作已经完成，接下来就是怎么把元素搬迁到新hash表里了。如果现在就一次全量搬迁过去，显然接下来会有比较长的一段时间map被占用（不支持并发）。所以搬迁的工作是异步增量搬迁的。&lt;/p&gt;

&lt;p&gt;在插入和删除的函数内都有下面一段代码用于在每次插入和删除操作时，执行一次搬迁工作：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; if h.growing() { // 当前处于搬迁状态
		growWork(t, h, bucket) // 调用搬迁函数
	}
	
func growWork(t *maptype, h *hmap, bucket uintptr) {
	// 将当前需要处理的桶搬迁
	evacuate(t, h, bucket&amp;amp;h.oldbucketmask())

	if h.growing() { // 再多搬迁一个桶
		evacuate(t, h, h.nevacuate)
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;每执行一次插入或删除，都会调用growWork搬迁0~2个hash桶（有可能这次需要搬迁的2个桶在此之前都被搬过了）&lt;/li&gt;
  &lt;li&gt;搬迁是以hash桶为单位的，包含对应的hash桶和这个桶的溢出链表&lt;/li&gt;
  &lt;li&gt;被delete掉的元素(emptyone标志)会被舍弃（这是缩容的关键）&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;33-为什么叫伪缩容如何实现真缩容&quot;&gt;&lt;strong&gt;3.3 为什么叫“伪缩容”？如何实现“真缩容”？&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;现在可以解释为什么我把map的缩容叫做伪缩容了：因为缩容仅仅针对溢出桶太多的情况，触发缩容时hash数组的大小不变，即hash数组所占用的空间只增不减。也就是说，如果我们把一个已经增长到很大的map的元素挨个全部删除掉，hash表所占用的内存空间也不会被释放。&lt;/p&gt;

&lt;p&gt;所以如果要实现“真缩容”，需自己实现缩容搬迁，即创建一个较小的map，将需要缩容的map的元素挨个搬迁过来：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// go map缩容代码示例
myMap := make(map[int]int, 1000000)

// 假设这里我们对bigMap做了很多次插入，之后又做了很多次删除，此时bigMap的元素数量远小于hash表大小
// 接下来我们开始缩容
smallMap := make(map[int]int, len(myMap))
for k, v := range myMap {
    smallMap[k] = v
}
myMap = smallMap // 缩容完成，原来的map被我们丢弃，交给gc去清理
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Ted</name></author><category term="Golang" /><summary type="html">1、 map的本质</summary></entry><entry><title type="html">数据库架构之Buffer Pool</title><link href="http://www.helloted.com/%E6%95%B0%E6%8D%AE%E5%BA%93/2022/12/10/buffer/" rel="alternate" type="text/html" title="数据库架构之Buffer Pool" /><published>2022-12-10T20:00:00+08:00</published><updated>2022-12-10T20:00:00+08:00</updated><id>http://www.helloted.com/%E6%95%B0%E6%8D%AE%E5%BA%93/2022/12/10/buffer</id><content type="html" xml:base="http://www.helloted.com/%E6%95%B0%E6%8D%AE%E5%BA%93/2022/12/10/buffer/">&lt;h3 id=&quot;1概念&quot;&gt;&lt;strong&gt;1、概念&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;InnoDB的Buffer Pool（缓冲池）是MySQL数据库中非常重要的一个组件，它主要用于缓存数据和索引，以提高数据库的性能。&lt;/p&gt;

&lt;p&gt;以下是Buffer Pool的主要作用：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;数据缓存：当你查询一个数据行时，InnoDB首先会在Buffer Pool中查找这个数据行。如果找到，那么就直接从内存中读取，这比从磁盘读取要快得多。如果在Buffer Pool中没有找到，那么InnoDB会从磁盘读取这个数据行，并将其放入Buffer Pool中，以便下次查询时能够直接从内存中读取。&lt;/li&gt;
  &lt;li&gt;索引缓存：除了数据行，InnoDB还会在Buffer Pool中缓存索引。这样，当你执行一个需要使用索引的查询时，InnoDB可以直接从内存中读取索引，而不需要从磁盘读取。&lt;/li&gt;
  &lt;li&gt;写操作的缓存：当你执行一个写操作（如INSERT、UPDATE或DELETE）时，InnoDB会先将修改写入到Buffer Pool中，然后在适当的时机（如在事务提交时或在做Checkpoint时）再将这些修改写入到磁盘。这种方式可以减少磁盘I/O操作，从而提高性能。&lt;/li&gt;
  &lt;li&gt;读写操作的并发控制：Buffer Pool中的每一个数据页都有对应的锁和读写控制机制，这样可以支持高并发的读写操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总的来说，InnoDB的Buffer Pool是一个非常重要的性能优化组件，它通过缓存数据和索引，以及优化磁盘I/O操作，来提高数据库的性能。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/61.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;总结&lt;/p&gt;

&lt;p&gt;Buffer Pool就是数据库的一个内存组件，里面缓存了磁盘上的真实数据，然后我们的系统对数据库执行的增删改操作，其实主要就是对这个内存数据结构中的缓存数据执行的。通过这种方式，保证每个更新请求，尽量就是只更新内存，然后往磁盘顺序写日志文件。&lt;/p&gt;

&lt;p&gt;更新内存的性能是极高的，然后顺序写磁盘上的日志文件的性能也是比较高的，因为顺序写磁盘文件，他的性能要远高于随机读写磁盘文件。&lt;/p&gt;

&lt;h3 id=&quot;2buffer-pool的工作流程&quot;&gt;&lt;strong&gt;2、buffer pool的工作流程&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;这条 SQL 语句的执行步骤大致是这样子的&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;innodb 存储引擎会在缓冲池中查找 id=1 的这条数据是否存在&lt;/li&gt;
  &lt;li&gt;发现不存在，那么就会去磁盘中加载，并将其存放在缓冲池中&lt;/li&gt;
  &lt;li&gt;该条记录会被加上一个独占锁&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/62.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;21--buffer-pool-vs-查询缓存&quot;&gt;&lt;strong&gt;2.1  buffer pool VS 查询缓存&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;在mysql8.0的版本中，已经将查询缓存模块删除了。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果将Mysql分为Server层和存储引擎层两大部分，那么Qcache位于Server层，Buffer Pool位于存储引擎层。&lt;/p&gt;

&lt;p&gt;　　如果你的Mysql 查询缓存功能是打开的，那么当一个sql进入Mysql Server之后，Mysql Server首先会从查询缓存中查看是否曾经执行过这个SQL，如果曾经执行过的话，曾经执行的查询结果之前会以key-value的形式&lt;/p&gt;

&lt;p&gt;保存在查询缓存中。key是sql语句，value是查询结果。我们将这个过程称为查询缓存！&lt;/p&gt;

&lt;p&gt;　　如果查询缓存中没有你要找的数据的话，MySQL才会执行后续的逻辑，通过存储引擎将数据检索出来。并且查询缓存会被shared cache for sessions，是的，它会被所有的session共享。&lt;/p&gt;

&lt;p&gt;　　MySQL查询缓存是查询结果缓存。它将以SEL开头的查询与哈希表进行比较，如果匹配，则返回上一次查询的结果。进行匹配时，查询必须逐字节匹配，例如 SELECT * FROM t1; 不等于select * from t1;，此外，一些不确定的查询结果无法被缓存，任何对表的修改都会导致这些表的所有缓存无效(只要有一个sql update了该表，那么表的查询缓存就会失效)。因此，适用于查询缓存的最理想的方案是只读，特别是需要检查数百万行后仅返回数行的复杂查询。如果你的查询符合这样一个特点，开启查询缓存会提升你的查询性能。&lt;/p&gt;

&lt;p&gt;　　MySQL查询缓存的目的是为了提升查询性能，但它本身也是有性能开销的。需要在合适的业务场景下（读写压力模型）使用，不合适的业务场景不但不能提升查询性能，查询缓存反而会变成MySQL的瓶颈。&lt;/p&gt;

&lt;p&gt;查询缓存的开销主要有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;读查询在开始前必须先检查是否命中缓存；&lt;/li&gt;
  &lt;li&gt;如果这个读查询可以被缓存，那么当完成执行后，MySQL若发现查询缓存中没有这个查询，会将其结果存入查询缓存，这会带来额外的系统消耗；&lt;/li&gt;
  &lt;li&gt;当向某个表写入数据的时候，MySQL必须将对应表的所有缓存都设置失效。如果查询缓存非常大或者碎片很多，这个操作就可能带来很大的系统消耗。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;查询缓存的缺点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;首先，查询缓存的效果取决于缓存的命中率，只有命中缓存的查询效果才能有改善，因此无法预测其性能。只要有一个sql update了该表，那么表的查询缓存就会失效，所以当你的业务对表CRUD的比例不相上下，那么查询缓存may be会影响应用的吞吐效率。&lt;/li&gt;
  &lt;li&gt;其次，查询缓存的另一个大问题是它受到单个互斥锁的保护。在具有多个内核的服务器上，大量查询会导致大量的互斥锁争用。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;在mysql8.0的版本中，已经将查询缓存模块删除了。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;22--undo-日志文件记录数据被修改前的样子&quot;&gt;&lt;strong&gt;2.2  undo 日志文件：记录数据被修改前的样子&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;在准备更新一条语句的时候，该条语句会先被加载到 Buffer pool 中了，同时，在将该条语句加载到 Buffer Pool 中的时候同时会往 undo 日志文件中插入一条日志，也就是将 id=1 的这条记录的原来的值记录下来。&lt;/p&gt;

&lt;p&gt;这样做的目的是什么？&lt;/p&gt;

&lt;p&gt;Innodb 存储引擎的最大特点就是支持事务，如果本次更新失败，也就是事务提交失败，那么该事务中的所有的操作都必须回滚到执行前的样子，也就是说当事务失败的时候，也不会对原始数据有影响，&lt;/p&gt;

&lt;h4 id=&quot;23-redo-日志文件记录数据被修改后的样子&quot;&gt;&lt;strong&gt;2.3 redo 日志文件：记录数据被修改后的样子&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;redo 日志文件是 InnoDB 特有的，他是存储引擎级别的，不是 MySQL 级别的&lt;/p&gt;

&lt;p&gt;redo 记录的是数据修改之后的值，不管事务是否提交都会记录下来。MySQL 为了提高效率，所以将这些操作都先放在内存中redo log buffer去完成，然后会在某个时机将其持久化到磁盘中。如果 MySQL 真的宕机了，那么没关系的，因为 MySQL 会认为本次事务是失败的，所以数据依旧是更新前的样子，并不会有任何的影响。&lt;/p&gt;

&lt;p&gt;语句也更新好了那么需要将更新的值提交啊，也就是需要提交本次的事务了，因为只要事务成功提交了，才会将最后的变更保存到数据库，在提交事务前仍然会具有相关的其他操作：将 redo Log Buffer 中的数据持久化到磁盘中，就是将 redo log buffer 中的数据写入到 redo log 磁盘文件中，一般情况下，redo log Buffer 数据写入磁盘的策略是立即刷入磁盘&lt;/p&gt;

&lt;h4 id=&quot;24-mysql更新数据的过程&quot;&gt;&lt;strong&gt;2.4 MYSQL更新数据的过程&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;截至目前，我们应该都熟悉了 MySQL 的执行器调用存储引擎是怎么将一条 SQL 加载到缓冲池和记录哪些日志的，流程如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;准备更新一条 SQL 语句&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;MySQL（innodb）会先去缓冲池（BufferPool）中去查找这条数据，没找到就会去磁盘中查找，如果查找到就会将这条数据加载到缓冲池（BufferPool）中&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在加载到 Buffer Pool 的同时，会将这条数据的原始记录保存到 undo 日志文件中&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;innodb 会在 Buffer Pool 中执行更新操作&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;更新后的数据会记录在 redo log buffer 中&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;MySQL 提交事务的时候，会将 redo log buffer 中的数据写入到 redo 日志文件中 刷磁盘可以通过 innodb_flush_log_at_trx_commit 参数来设置&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;值为 0 表示不刷入磁盘&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;值为 1 表示立即刷入磁盘&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;值为 2 表示先刷到 os cache&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;myslq 重启的时候会将 redo 日志恢复到缓冲池中&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/63.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3总结&quot;&gt;&lt;strong&gt;3、总结：&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;我们再回顾下&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Buffer Pool 是 MySQL 的一个非常重要的组件，因为针对数据库的增删改操作都是在 Buffer Pool 中完成的&lt;/li&gt;
  &lt;li&gt;Undo log 记录的是数据操作前的样子&lt;/li&gt;
  &lt;li&gt;redo log 记录的是数据被操作后的样子（redo log 是 Innodb 存储引擎特有）&lt;/li&gt;
  &lt;li&gt;bin log 记录的是整个操作记录（这个对于主从复制具有非常重要的意义）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;具体更新一条记录 UPDATE t_user SET name = ‘xiaolin’ WHERE id = 1; 的流程如下:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id = 1 这一行记录：&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;如果 id=1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新；&lt;/li&gt;
  &lt;li&gt;如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样：&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;如果一样的话就不进行后续更新流程；&lt;/li&gt;
  &lt;li&gt;如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;开启事务， InnoDB 层更新记录前，首先要记录相应的 undo log，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，不过在内存修改该 Undo 页面后，需要记录对应的 redo log。&lt;/li&gt;
  &lt;li&gt;InnoDB 层开始更新记录，会先更新内存（同时标记为脏页），然后将记录写到 redo log 里面，这个时候更新就算完成了。为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。这就是 &lt;strong&gt;WAL 技术&lt;/strong&gt;，MySQL 的写操作并不是立刻写到磁盘上，而是先写 redo 日志，然后在合适的时间再将修改的行数据写到磁盘上。&lt;/li&gt;
  &lt;li&gt;至此，一条记录更新完了。&lt;/li&gt;
  &lt;li&gt;在一条更新语句执行完成后，然后开始记录该语句对应的 binlog，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。&lt;/li&gt;
  &lt;li&gt;事务提交（为了方便说明，这里不说组提交的过程，只说两阶段提交）：&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;prepare 阶段：将 redo log 对应的事务状态设置为 prepare，然后将 redo log 刷新到硬盘；&lt;/li&gt;
  &lt;li&gt;commit 阶段：将 binlog 刷新到磁盘，接着调用引擎的提交事务接口，将 redo log 状态设置为 commit（将事务设置为 commit 状态后，刷入到磁盘 redo log 文件）；&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;至此，一条更新语句执行完成。&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Ted</name></author><category term="数据库" /><summary type="html">1、概念</summary></entry><entry><title type="html">Garbage Collection</title><link href="http://www.helloted.com/golang/2022/12/01/gc/" rel="alternate" type="text/html" title="Garbage Collection" /><published>2022-12-01T20:00:00+08:00</published><updated>2022-12-01T20:00:00+08:00</updated><id>http://www.helloted.com/golang/2022/12/01/gc</id><content type="html" xml:base="http://www.helloted.com/golang/2022/12/01/gc/">&lt;h3 id=&quot;一定义&quot;&gt;&lt;strong&gt;一、定义&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;GC，全称 Garbage Collection，即垃圾回收，是一种自动内存管理的机制。&lt;/p&gt;

&lt;p&gt;当程序向操作系统申请的内存不再需要时，垃圾回收主动将其回收并供其他代码进行内存申请时候复用，或者将其归还给操作系统，这种针对内存级别资源的自动回收过程，即为垃圾回收。&lt;/p&gt;

&lt;p&gt;而负责垃圾回收的程序组件，即为垃圾回收器。&lt;/p&gt;

&lt;p&gt;垃圾回收其实一个完美的 “Simplicity is Complicated” 的例子：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一方面，程序员受益于 GC，无需操心、也不再需要对内存进行手动的申请和释放操作，GC 在程序运行时自动释放残留的内存。也能够消除一些需要手动管理内存才会出现的运行时错误：
    &lt;ul&gt;
      &lt;li&gt;在仍然有指向内存区块的指针的情况下释放这块内存时，会产生悬挂指针，从而后续可能错误的访问已经用于他用的内存区域。&lt;/li&gt;
      &lt;li&gt;多重释放同一块申请的内存区域可能导致不可知的内存损坏&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;另一方面，GC 对程序员几乎不可见，仅在程序需要进行特殊优化时，通过提供可调控的 API，对 GC 的运行时机、运行开销进行把控的时候才得以现身。这也就造就了没有 GC 的一些优势：&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;没有额外的性能开销&lt;/li&gt;
  &lt;li&gt;精准的手动内存管理，极致的利用机器的性能&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;二gc的语言&quot;&gt;&lt;strong&gt;二、GC的语言&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;从原理上而言，所有的语言都能够自行实现 GC。&lt;/p&gt;

&lt;p&gt;从语言诞生之初就提供 GC 的语言，例如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Python&lt;/li&gt;
  &lt;li&gt;JavaScript&lt;/li&gt;
  &lt;li&gt;Java&lt;/li&gt;
  &lt;li&gt;Objective-C&lt;/li&gt;
  &lt;li&gt;Swift&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而不以 GC 为目标，被直接设计为手动管理内存、但可以自行实现 GC 的语言有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;C&lt;/li&gt;
  &lt;li&gt;C++&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;也有一些语言可以在编译期，依靠编译器插入清理代码的方式，实现精准的清理，例如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Rust&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;三gc方式&quot;&gt;&lt;strong&gt;三、GC方式&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;所有的 GC 算法其存在形式可以归结为追踪（Tracing）和引用计数（Reference Counting）这两种形式的混合运用。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;追踪式 GC从根对象出发，根据对象之间的引用信息，一步步推进直到扫描完毕整个堆并确定需要保留的对象，从而回收所有可回收的对象。Go、 Java、V8 对 JavaScript 的实现等均为追踪式 GC。&lt;/li&gt;
  &lt;li&gt;引用计数式 GC每个对象自身包含一个被引用的计数器，当计数器归零时自动得到回收。因为此方法缺陷较多，在追求高性能时通常不被应用。Python、Objective-C 等均为引用计数式 GC。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;目前比较常见的 GC 实现方式包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;追踪式，分为多种不同类型，例如：
    &lt;ul&gt;
      &lt;li&gt;标记清扫：从根对象出发，将确定存活的对象进行标记，并清扫可以回收的对象。&lt;/li&gt;
      &lt;li&gt;标记整理：为了解决内存碎片问题而提出，在标记过程中，将对象尽可能整理到一块连续的内存上。&lt;/li&gt;
      &lt;li&gt;增量式：将标记与清扫的过程分批执行，每次执行很小的部分，从而增量的推进垃圾回收，达到近似实时、几乎无停顿的目的。&lt;/li&gt;
      &lt;li&gt;增量整理：在增量式的基础上，增加对对象的整理过程。&lt;/li&gt;
      &lt;li&gt;分代式：将对象根据存活时间的长短进行分类，存活时间小于某个值的为年轻代，存活时间大于某个值的为老年代，永远不会参与回收的对象为永久代。并根据分代假设（如果一个对象存活时间不长则倾向于被回收，如果一个对象已经存活很长时间则倾向于存活更长时间）对对象进行回收。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;引用计数：根据对象自身的引用计数来回收，当引用计数归零时立即回收。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Ted</name></author><category term="Golang" /><summary type="html">一、定义</summary></entry><entry><title type="html">操作系统内存管理</title><link href="http://www.helloted.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2022/11/25/mem/" rel="alternate" type="text/html" title="操作系统内存管理" /><published>2022-11-25T20:00:00+08:00</published><updated>2022-11-25T20:00:00+08:00</updated><id>http://www.helloted.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2022/11/25/mem</id><content type="html" xml:base="http://www.helloted.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2022/11/25/mem/">&lt;h3 id=&quot;一内存管理&quot;&gt;一、内存管理&lt;/h3&gt;

&lt;p&gt;操作系统的内存管理非常重要，主要负责下面这些事情：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;内存的分配与回收：对进程所需的内存进行分配和释放，malloc 函数：申请内存，free 函数：释放内存。&lt;/li&gt;
  &lt;li&gt;地址转换：将程序中的虚拟地址转换成内存中的物理地址。&lt;/li&gt;
  &lt;li&gt;内存扩充：当系统没有足够的内存时，利用虚拟内存技术或自动覆盖技术，从逻辑上扩充内存。&lt;/li&gt;
  &lt;li&gt;内存映射：将一个文件直接映射到进程的进程空间中，这样可以通过内存指针用读写内存的办法直接存取文件内容，速度更快。&lt;/li&gt;
  &lt;li&gt;内存优化：通过调整内存分配策略和回收算法来优化内存使用效率。&lt;/li&gt;
  &lt;li&gt;内存安全：保证进程之间使用内存互不干扰，避免一些恶意程序通过修改内存来破坏系统的安全性。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;11-malloc是如何分配内存的&quot;&gt;&lt;strong&gt;1.1 malloc是如何分配内存的？&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;malloc 是 C 语言标准库中用于动态内存分配的函数。它从堆（heap）上分配指定大小的内存块，并返回一个指向该内存块的指针。如果分配失败，它返回 NULL。&lt;/p&gt;

&lt;p&gt;基本工作原理&lt;/p&gt;

&lt;p&gt;在使用 malloc 进行内存分配时，实际的处理过程涉及两个层面：首先是从进程的内存池中尝试分配内存，如果进程的内存池中没有足够的空间满足当前的请求，那么 malloc 会从操作系统那里请求更多的内存。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;从进程内存池中分配
    &lt;ul&gt;
      &lt;li&gt;内存池管理：进程的内存池通常由 malloc 管理，它包含了一系列已经从操作系统获取并为进程预留的内存块。这些内存块可能是连续的或者是非连续的，取决于之前的分配和释放操作。&lt;/li&gt;
      &lt;li&gt;内存分配尝试：当调用 malloc 请求内存时，malloc 首先检查其管理的内存池中是否有足够的空闲内存来满足请求。这涉及到查找合适大小的空闲块，可能需要根据内存分配算法（如首次适应、最佳适应等）来选择。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;从操作系统请求内存
    &lt;ul&gt;
      &lt;li&gt;内存池不足：如果进程的内存池中没有足够的空闲内存块来满足当前的请求，malloc 需要从操作系统请求更多的内存。&lt;/li&gt;
      &lt;li&gt;系统调用：malloc 通过系统调用（如 sbrk 或 mmap）向操作系统请求额外的内存。这些调用会将更多的内存区域分配给进程，从而扩展进程的堆空间。内存整合和返回&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;内存整合：获取到新的内存后，malloc 可能会执行一些内存整合操作，如合并相邻的空闲块，以优化内存的使用和减少碎片。&lt;/li&gt;
  &lt;li&gt;返回内存指针：完成内存分配后，malloc 将返回一个指向新分配内存块的指针。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;需要注意的是，malloc函数只负责分配内存，并不会初始化内存块的内容。如果需要初始化内存块，可以使用memset等函数进行操作。&lt;/p&gt;

&lt;h4 id=&quot;12-内存碎片&quot;&gt;1.2 &lt;strong&gt;内存碎片&lt;/strong&gt;&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;内部内存碎片(Internal Memory Fragmentation，简称为内存碎片)：已经分配给进程使用但未被使用的内存。导致内部内存碎片的主要原因是，当采用固定比例比如 2 的幂次方进行内存分配时，进程所分配的内存可能会比其实际所需要的大。举个例子，一个进程只需要 65 字节的内存，但为其分配了 128（2^7） 大小的内存，那 63 字节的内存就成为了内部内存碎片。&lt;/li&gt;
  &lt;li&gt;外部内存碎片(External Memory Fragmentation，简称为外部碎片)：由于未分配的连续内存区域太小，以至于不能满足任意进程所需要的内存分配请求，这些小片段且不连续的内存空间被称为外部碎片。也就是说，外部内存碎片指的是那些并未分配给进程但又不能使用的内存。我们后面介绍的分段机制就会导致外部内存碎片。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;二虚拟内存&quot;&gt;二、虚拟内存&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;虚拟内存(Virtual Memory)&lt;/strong&gt; 是计算机系统内存管理非常重要的一个技术，本质上来说它只是逻辑存在的，是一个假想出来的内存空间，主要作用是作为进程访问主存（物理内存）的桥梁并简化内存管理。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/60.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;虚拟地址空间构成虚拟内存。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片。还有部分暂时存储在外部磁盘存储器上（Swap），在需要时进行数据交换。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;虚拟内存提供了以下能力&lt;/strong&gt;：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;隔离进程：物理内存通过虚拟地址空间访问，虚拟地址空间与进程一一对应。每个进程都认为自己拥有了整个物理内存，进程之间彼此隔离，一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。&lt;/li&gt;
  &lt;li&gt;提升物理内存利用率：有了虚拟地址空间后，操作系统只需要将进程当前正在使用的部分数据或指令加载入物理内存。&lt;/li&gt;
  &lt;li&gt;简化内存管理：进程都有一个一致且私有的虚拟地址空间，程序员不用和真正的物理内存打交道，而是借助虚拟地址空间访问物理内存，从而简化了内存管理。&lt;/li&gt;
  &lt;li&gt;多个进程共享物理内存：进程在运行过程中，会加载许多操作系统的动态库。这些库对于每个进程而言都是公用的，它们在内存中实际只会加载一份，这部分称为共享内存。&lt;/li&gt;
  &lt;li&gt;提高内存使用安全性：控制进程对物理内存的访问，隔离不同进程的访问权限，提高系统的安全性。&lt;/li&gt;
  &lt;li&gt;提供更大的可使用内存空间：可以让程序拥有超过系统物理内存大小的可用内存空间。这是因为当物理内存不够用时，可以利用磁盘充当，将物理内存页（通常大小为 4 KB）保存到磁盘文件（会影响读写速度），数据或代码页会根据需要在物理内存与磁盘之间移动。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;总的来说，虚拟内存技术通过将物理内存和磁盘空间结合起来，为每个进程提供了一个连续的、抽象的地址空间。它扩展了地址空间、提供了内存管理和保护机制，支持共享和隔离，提高了系统的性能和资源利用率，使得计算机系统更加灵活、稳定和安全。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;虚拟内存的工作原理如下&lt;/strong&gt;：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;地址空间划分：每个进程都有自己的虚拟地址空间，通常是一个连续的地址范围。这个地址空间被划分为多个固定大小的页面（通常是4KB），每个页面都有一个唯一的虚拟地址。&lt;/li&gt;
  &lt;li&gt;页面映射：虚拟内存管理器将虚拟页面映射到物理内存或磁盘上的页面框（通常也是4KB）。这个映射关系存储在页表中，页表记录了虚拟页面和物理页面之间的对应关系。&lt;/li&gt;
  &lt;li&gt;页面置换：当进程访问一个虚拟页面时，虚拟内存管理器首先检查该页面是否已经在物理内存中。如果在物理内存中，就直接访问；如果不在物理内存中，就发生了缺页中断。&lt;/li&gt;
  &lt;li&gt;缺页中断处理：当发生缺页中断时，操作系统会根据页表中的映射关系，将对应的页面从磁盘读取到物理内存中的一个空闲页面框中，并更新页表。然后，进程的执行可以继续，就好像该页面一直在物理内存中一样。&lt;/li&gt;
  &lt;li&gt;页面置换算法：当物理内存不足时，操作系统需要选择一个页面进行置换，将其写回磁盘并释放其物理内存。常用的页面置换算法有最近最久未使用（LRU）、先进先出（FIFO）和时钟（Clock）算法等。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;虚拟内存缺点&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;性能开销：虚拟内存的使用涉及到页表查找和磁盘I/O操作，这些都可能导致性能下降。特别是当系统频繁进行换页操作时，会显著影响系统性能，这种现象称为“抖动”。&lt;/li&gt;
  &lt;li&gt;硬盘速度限制：虽然现代固态硬盘（SSD）的速度已经大幅提升，但相比于物理内存，硬盘的访问速度仍然较慢。频繁的访问硬盘来加载或存储页面会减慢程序的执行速度。&lt;/li&gt;
  &lt;li&gt;复杂的内存管理：虚拟内存系统需要复杂的硬件支持（如内存管理单元MMU）和操作系统级的支持，这增加了系统设计和维护的复杂性。&lt;/li&gt;
  &lt;li&gt;资源消耗：维护页表和相关数据结构需要额外的内存和CPU资源。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;三虚拟内存实现的三种机制&quot;&gt;三、虚拟内存实现的三种机制&lt;/h3&gt;

&lt;p&gt;虚拟内存（Virtual Memory）是一种计算机系统技术，它使得程序可以使用比实际物理内存更大的地址空间。虚拟内存通过将虚拟地址映射到物理地址，实现了内存的高效管理和保护。虚拟内存的实现主要有三种机制：分页（Paging）、分段（Segmentation）和段页结合（Segmentation with Paging）。&lt;/p&gt;

&lt;h4 id=&quot;1-分页机制paging&quot;&gt;1. 分页机制（Paging）&lt;/h4&gt;

&lt;p&gt;分页机制是虚拟内存实现中最常见的一种方式。它将虚拟地址空间和物理地址空间都划分为固定大小的块，分别称为页（Page）和页框（Frame）。虚拟地址由页号和页内偏移量组成，通过页表（Page Table）将页号映射到物理内存中的页框。&lt;/p&gt;

&lt;h5 id=&quot;特点&quot;&gt;特点&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;固定大小&lt;/strong&gt;：页和页框大小固定，简化了内存管理。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;减少外部碎片&lt;/strong&gt;：由于页大小固定，减少了外部碎片。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;内存保护&lt;/strong&gt;：每个页可以有不同的访问权限。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2-分段机制segmentation&quot;&gt;2. 分段机制（Segmentation）&lt;/h4&gt;

&lt;p&gt;分段机制将虚拟地址空间划分为若干段，每个段有一个段基址和段长度。虚拟地址由段选择子和段内偏移量组成。段选择子用于选择段，段内偏移量用于指定段内的具体地址。&lt;/p&gt;

&lt;h5 id=&quot;特点-1&quot;&gt;特点&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;灵活性&lt;/strong&gt;：可以根据需要动态调整段的大小。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;保护性&lt;/strong&gt;：每个段可以有不同的访问权限，提供了内存保护。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;共享性&lt;/strong&gt;：多个进程可以共享同一个段。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;3-段页结合机制segmentation-with-paging&quot;&gt;3. 段页结合机制（Segmentation with Paging）&lt;/h4&gt;

&lt;p&gt;段页结合机制结合了分段和分页的优点。内存首先被划分为段，每个段再划分为若干页。虚拟地址由段选择子、页号和页内偏移量组成。&lt;/p&gt;

&lt;h5 id=&quot;特点-2&quot;&gt;特点&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;灵活性和固定大小结合&lt;/strong&gt;：段提供灵活性，页提供固定大小的管理。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;减少外部碎片&lt;/strong&gt;：分页减少了外部碎片。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;内存保护和共享&lt;/strong&gt;：段和页都可以有不同的访问权限，提供了更细粒度的内存保护和共享。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;分段机制（Segmentation）：分段机制将虚拟地址空间划分为多个段（segment），每个段具有不同的大小和属性。每个段都有一个基地址和长度，通过将段内的偏移量与基地址相加，可以得到物理地址。分段机制可以提供灵活的地址空间管理，但可能会导致外部碎片问题。&lt;/li&gt;
  &lt;li&gt;分页机制（Paging）：分页机制将虚拟地址空间和物理内存空间划分为固定大小的页（page），通常为4KB或者更大。虚拟地址被划分为页号和页内偏移量，通过页表（Page Table）来映射虚拟页号到物理页框号。分页机制可以提供更好的内存利用率和地址空间的连续性，但可能会导致内部碎片问题。&lt;/li&gt;
  &lt;li&gt;段页机制（Segmentation with Paging）：段页机制是分段机制和分页机制的结合，它将虚拟地址空间划分为多个段，每个段再划分为多个页。通过段表（Segment Table）和页表的组合，可以将虚拟地址映射到物理地址。段页机制综合了分段和分页的优点，提供了更灵活的地址空间管理和更好的内存利用率。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Ted</name></author><category term="操作系统" /><summary type="html">一、内存管理</summary></entry></feed>