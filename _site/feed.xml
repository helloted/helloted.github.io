<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://www.helloted.com/feed.xml" rel="self" type="application/atom+xml" /><link href="http://www.helloted.com/" rel="alternate" type="text/html" /><updated>2024-08-27T15:15:39+08:00</updated><id>http://www.helloted.com/feed.xml</id><title type="html">Helloted Blog</title><subtitle>曹浩之Helloted的技术博客，用于记录一些技术成长过程中的技术分享，包括客户端iOS/Android，后台Pyhon/Java，跨平台开发Flutter</subtitle><entry><title type="html">Redis之内存结构</title><link href="http://www.helloted.com/redis/2023/03/03/redis/" rel="alternate" type="text/html" title="Redis之内存结构" /><published>2023-03-03T20:00:00+08:00</published><updated>2023-03-03T20:00:00+08:00</updated><id>http://www.helloted.com/redis/2023/03/03/redis</id><content type="html" xml:base="http://www.helloted.com/redis/2023/03/03/redis/">&lt;p&gt;&lt;img src=&quot;/img/Simple_2/82.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;1redisserver&quot;&gt;&lt;strong&gt;1、redisServer&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;redis 的数据是保存在 redisServer 中的 redisDb 结构中。&lt;/p&gt;

&lt;p&gt;Redis 服务器将绝大部分的信息都保存在 server.h/redisServer。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;redisServer&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;redisDb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 数据库列表&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dbnum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// 数据库数量&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;db 中每个redisDb结构代表一个数据库，每个db是相互独立的。&lt;/li&gt;
  &lt;li&gt;dbnum 属性的值由服务器配置的 database 选项决定，默认情况下，该选项的值为16，所以Redis服务器默认会创建16个数据库。&lt;/li&gt;
  &lt;li&gt;每次访问数据时先用SELECT index命令切换数据库然后再操作。&lt;/li&gt;
  &lt;li&gt;实际上，我们只会在redisDb[0]上进行操作。&lt;/li&gt;
  &lt;li&gt;之所以会默认定义这么多db，是最初设计时考虑不同数据存在不同db上，但最后觉得很鸡肋，由于要保持向下兼容，所以就保留了这个功能。虽然实际生产中Redis实例很少会用到多个DB，但每个DB大概1m左右也不是十分耗费资源，所以无伤大雅&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2redisdb-dict&quot;&gt;&lt;strong&gt;2、redisDb-dict&lt;/strong&gt;&lt;/h4&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/* Redis数据库结构体 */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;redisDb&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 数据库键空间，存放着所有的key-value对&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;dict&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 键的过期时间&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;dict&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;expires&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;redisDb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看到，redisDb 的 dict 字典属性保存了数据库中的所有key-value，我们将这个字典称为键空间(key space)，增删改查也就是对 dict 的操作而已。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果，我们在redis中执行以下命令:&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;redis &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; SET str_key str_value
OK
redis &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; RPUSH list_key a b c
&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;integer&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;redis新添加的key-value在dict里是这样的一个结构&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/83.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;3redisdb-expires&quot;&gt;3、redisDb-expires&lt;/h4&gt;

&lt;p&gt;redisDb 中的 expires 属性保存了所有 key 的过期时间，我们姑且就称它为过期字典吧。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;过期字典中的键，是一个指针，指向了真实数据的 key，不会浪费空间多保存一次&lt;/li&gt;
  &lt;li&gt;过期字典中的值，存的是具体的过期时间点，精确到毫秒的时间戳&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个 key 过期时间到了之后，是如何进行删除的呢？Redis 使用了一下两种策略：惰性删除、定期删除&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;惰性删除&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;惰性删除策略指的是：key 在过期之后，没有立即删除，而是在读写 key 的时候，才对过期的 key 进行删除。&lt;/p&gt;

&lt;p&gt;代码实现在 db.c/expireIfNeeded 方法中。所有 key 的读写之前，都会先调用 expireIfNeeded 对 key 进行检查，如果已过期，则删除。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;定期删除&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;定期删除策略指的是：Redis 每隔一段时间，随机从数据库中取出一定量的 key 进行检查，如果已过期，则进行删除。&lt;/p&gt;

&lt;p&gt;代码实现在 expire.c/activeExpireCycle 方法中。&lt;/p&gt;

&lt;p&gt;删除的步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;从过期字典中随机 20 个 key&lt;/li&gt;
  &lt;li&gt;删除这 20 个 key 中已经过期的 key&lt;/li&gt;
  &lt;li&gt;如果过期的 key 比率超过 1/4，那就重复步骤 1&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为什么只是随机挑 一些 key 呢？因为如果把所有 key 都遍历一遍，那这个性能肯定是不能接受的！所以还需要配合惰性删除。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;过期数据的清除从来不容易，为每一条key设置一个timer，到点立刻删除的消耗太大，每秒遍历所有数据消耗也大，Redis使用了一种相对务实的做法： 当client主动访问key会先对key进行超时判断，过时的key会立刻删除。 如果clien永远都不再get那条key呢？ 它会在Master的后台，每秒10次的执行如下操作： 随机选取100个key校验是否过期，如果有25个以上的key过期了，立刻额外随机选取下100个key(不计算在10次之内)。可见，如果过期的key不多，它最多每秒回收200条左右，如果有超过25%的key过期了，它就会做得更多，但只要key不被主动get，它占用的内存什么时候最终被清理掉只有天知道。&lt;/p&gt;

&lt;h4 id=&quot;4dictht&quot;&gt;&lt;strong&gt;4、dictht&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;dictht是redisDb-dict里面存放key-value的全局哈希表，有两个，一个是实际存放key-value的，另外一个是用于rehash。&lt;/p&gt;

&lt;p&gt;ditctht 结构，表示哈希表的结构，结构里存放了哈希表数组，数组中的每个元素都是指向一个哈希表节点结构（dictEntry）的指针；&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dictht&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// HashTable数组，数组的每个元素都是个指向dictEntry结构的指针&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;dictEntry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// HashTable的大小&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// HashTable大小掩码,总是等于size - 1, 通常用来计算索引&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sizemask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 已经使用的节点数,实际上就是HashTable中已经存在的dictEntry数量&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;used&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dictht&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/84.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;5dictentry&quot;&gt;&lt;strong&gt;5、dictEntry&lt;/strong&gt;&lt;/h4&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dictEntry&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 键&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 值&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;union&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 用来指向与当前dictEntry在同一个索引的下一个dictEntry&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dictEntry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dictEntry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;dictEntry是Dictht中结点的表现形式, 每个dictEntry都保存着一个键值对&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;key属性指向键值对的键对象,&lt;/li&gt;
  &lt;li&gt;v属性则保存着键值对的值, Redis采用了联合体来定义v, 使键值对的value既可以存储一个指针, 也可以存储有符号/无符号整形数据,甚至可以存储浮点形数据, Redis使用联合体的形式来存储键值对的值可以让内存使用更加精细灵活,&lt;/li&gt;
  &lt;li&gt;另外, 既然是HashTable, 不可避免会发生两个键不同但是计算出来存放索引相同的情况, 为了解决Hash冲突的问题, dictEntry还有一个next属性, 用来指向与当前dictEntry在同一个索引的下一个dictEntry.多个 dictEntry 可以通过 next 指针串连成链表， 从这里可以看出， dictht 使用链式寻址法来解决hash冲突： 当多个不同的键拥有相同的哈希值时，哈希表用一个链表将这些键连接起来。&lt;/li&gt;
  &lt;li&gt;void * key 和 void * value 指针指向的是 Redis 对象，Redis 中的每个对象都由 redisObject 结构表示&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;6redis对象redisobject&quot;&gt;&lt;strong&gt;6、Redis对象（RedisObject）&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;dictEntry里面的void * key 和 void * value 指针指向的是 Redis 对象，Redis 中的每个对象都由 redisObject 结构表示。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;redisObject&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 数据类型，取值范围为String、List、Set、SortedSet、Hash等五种类型&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 对齐位&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;notused&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 物理编码方式，同一种数据类型可能有不同的编码方式&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;encoding&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// LRU 时间（相对于 server.lruclock）&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lru&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;22&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 引用计数，C语言来管理自己的内存，防止内存溢出。&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;refcount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 指向真正数据，如果是整型值等，则直接存储，如果是很长的字符串，则存放指向数据的地址。&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;robj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;type: 记录了对象所保存的值的类型，它的值可能是以下常量的其中一个（定义位于 redis.h）：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#define OBJ_STRING 0 // 字符串
#define OBJ_LIST 1 // 列表
#define OBJ_SET 2 // 集合
#define OBJ_ZSET 3 // 有序集
#define OBJ_HASH 4 // 哈希表
#define OBJ_MODULE 5    &lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/* Module object. */&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
#define OBJ_STREAM 6    &lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/* Stream object. */&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;encoding 记录了对象所保存的值的编码，它的值可能是以下常量的其中一个（定义位于 redis.h）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define REDIS_ENCODING_RAW 0            // 编码为字符串
#define REDIS_ENCODING_INT 1            // 编码为整数
#define REDIS_ENCODING_HT 2             // 编码为哈希表
#define REDIS_ENCODING_ZIPMAP 3         // 编码为 zipmap
#define REDIS_ENCODING_LINKEDLIST 4     // 编码为双端链表
#define REDIS_ENCODING_ZIPLIST 5        // 编码为压缩列表
#define REDIS_ENCODING_INTSET 6         // 编码为整数集合
#define REDIS_ENCODING_SKIPLIST 7       // 编码为跳跃表
#define OBJ_ENCODING_EMBSTR 8  /* Embedded sds string encoding */
#define OBJ_ENCODING_QUICKLIST 9 /* Encoded as linked list of ziplists */
#define OBJ_ENCODING_STREAM 10 /* Encoded as a radix tree of listpacks */
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ptr 是一个指针，指向实际保存值的数据结构，这个数据结构由 type 属性和 encoding 属性决定。&lt;/p&gt;

&lt;p&gt;举个例子，如果一个 redisObject 的 type 属性为 REDIS_LIST ， encoding 属性为 REDIS_ENCODING_LINKEDLIST ，那么这个对象就是一个 Redis 列表，它的值保存在一个双端链表内，而 ptr 指针就指向这个双端链表；&lt;/p&gt;

&lt;p&gt;另一方面，如果一个 redisObject 的 type 属性为 REDIS_HASH ， encoding 属性为 REDIS_ENCODING_ZIPMAP ，那么这个对象就是一个 Redis 哈希表，它的值保存在一个 zipmap 里，而 ptr 指针就指向这个 zipmap ；诸如此类。&lt;/p&gt;

&lt;p&gt;下图展示了 redisObject 、Redis 所有数据类型、以及 Redis 所有编码方式（底层实现）三者之间的关系：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/85.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;</content><author><name>Ted</name></author><category term="Redis" /><summary type="html"></summary></entry><entry><title type="html">消息队列之Pulsar</title><link href="http://www.helloted.com/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/2023/02/25/pulsar/" rel="alternate" type="text/html" title="消息队列之Pulsar" /><published>2023-02-25T20:00:00+08:00</published><updated>2023-02-25T20:00:00+08:00</updated><id>http://www.helloted.com/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/2023/02/25/pulsar</id><content type="html" xml:base="http://www.helloted.com/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/2023/02/25/pulsar/">&lt;h4 id=&quot;1架构&quot;&gt;&lt;strong&gt;1、架构&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;Apache Pulsar 在架构设计上采用了计算与存储分离的模式，消息发布和订阅相关的计算逻辑在 Broker 中完成，数据存储在 Apache BookKeeper 集群的 Bookie 节点上：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/79.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Broker(经纪人)：Broker 是 Pulsar 的核心服务组件，负责维护连接到它的生产者（Producers）和消费者（Consumers），负责处理客户端请求、管理元数据、协调消息的存储和分发。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;处理生产者和消费者的连接请求。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;管理主题、分区和订阅的元数据。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;将消息写入持久化存储（如 Apache BookKeeper）。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;从持久化存储读取消息并分发给消费者。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;进行负载均衡和故障恢复。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;BookKeeper（存储层）：是 Pulsar 的持久化存储系统，用于存储消息日志。BookKeeper 由多个 Bookie 节点组成，提供高可用性和数据持久性。BookKeeper 的主要职责包括：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;接收和存储来自 Broker 的消息。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;提供高效的日志存储和读取功能。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;通过复制机制确保数据的高可用性和一致性。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ZooKeeper：用于进行集群管理和协调。它负责元数据的管理，包括配置信息、Broker 的负载均衡、BookKeeper Ledger 的元数据等。ZooKeeper 通过维护一致的状态信息，帮助系统实现高可用性和故障恢复。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Topic：消息是通过 Topic 进行组织的。每个 Topic 可以被配置为多个分区，分区可以跨多个 Broker 进行分布，这样可以提高 Topic 的可扩展性和并行处理能力。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Namespace：Namespace 是一种逻辑分组方式，用于对 Topic 进行分组管理。一个 Namespace 可以包含多个 Topic，可以在 Namespace 级别上设置策略，如消息保留策略、认证授权等。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Subscription：订阅是消费者从 Topic 接收消息的方式。Pulsar 支持多种订阅模式，包括 Exclusive、Shared、Failover 和 Key_Shared，这些模式支持不同的消息消费需求和场景。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Geo-Replication：Pulsar 支持跨多个地理区域的数据复制，即 Geo-Replication。这允许在不同区域的 Pulsar 集群之间复制 Topic，确保数据的全球可用性和灾难恢复。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;2-数据流&quot;&gt;&lt;strong&gt;2. 数据流&lt;/strong&gt;&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;生产者到 Broker：生产者（Producers）通过 Pulsar 客户端库连接到 Broker，并将消息发送到指定的主题。Broker 接收到消息后，将其写入 BookKeeper。&lt;/li&gt;
  &lt;li&gt;Broker 到 BookKeeper：Broker 将接收到的消息写入 BookKeeper 的日志。BookKeeper 通过复制机制将消息存储在多个 Bookie 节点上，以确保数据的高可用性和一致性。&lt;/li&gt;
  &lt;li&gt;Broker到消费者：消费者（Consumers）通过 Pulsar 客户端库连接到 Broker，并订阅指定的主题。Broker 从 BookKeeper 读取消息，并将其分发给订阅了该主题的消费者。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/80.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;3高可用性和容错&quot;&gt;&lt;strong&gt;3、高可用性和容错&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;Pulsar 通过以下机制实现高可用性和容错：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;无状态 Broker：Broker 不存储任何持久化数据，所有数据都存储在 BookKeeper 中。这使得 Broker 可以随时重启或替换，而不会丢失数据。&lt;/li&gt;
  &lt;li&gt;ZooKeeper 协调：ZooKeeper 负责管理 Broker 和 Bookie 的注册、主题的分区信息等。当一个 Broker 或 Bookie 发生故障时，ZooKeeper 会检测到并将其从活跃节点列表中移除。&lt;/li&gt;
  &lt;li&gt;自动故障恢复：当一个 Broker 或 Bookie 发生故障时，其他 Broker 或 Bookie 会接管其工作，确保服务的连续性。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;4topic和分区&quot;&gt;&lt;strong&gt;4、Topic和分区&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;在Apache Pulsar中，Topic和分区是两个相关但不同的概念&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Topic（主题）：Topic是消息传递的基本单位，它可以被看作是一个主题或者主题通道，用于发布和订阅消息。每个Topic都有一个唯一的名称，用于标识和区分不同的主题。Topic可以被认为是一个逻辑上的消息容器，用于组织和管理相关的消息。&lt;/li&gt;
  &lt;li&gt;分区：一个Topic可以被分为多个Partition（分区），每个Partition是一个有序的消息队列。分区的目的是实现消息的水平扩展和负载均衡。每个分区都有一个唯一的标识符，可以通过标识符来订阅和消费特定的分区。消费者可以独立地订阅一个或多个分区，从而实现并行处理和提高吞吐量。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;理解Topic和分区的关系：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个Topic可以有一个或多个分区，分区的数量可以根据需求进行动态调整。&lt;/li&gt;
  &lt;li&gt;分区可以用于实现消息的并行处理和负载均衡，多个消费者可以同时消费不同的分区，从而提高系统的吞吐量。&lt;/li&gt;
  &lt;li&gt;分区的数量和分布可以根据消息的特性和负载情况进行调整，以满足不同的需求。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总结来说，Topic是消息传递的基本单位，而分区是Topic的一种划分方式，用于实现消息的水平扩展和负载均衡。通过合理地使用Topic和分区，可以构建高性能、可扩展和可靠的消息传递系统。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;分区特性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;每个分区由一个 Broker 负责管理。Broker 负责处理生产者和消费者的请求，将消息写入 BookKeeper，并从 BookKeeper 读取消息。分区之间是相互独立且无关的。每个分区都是一个独立的有序消息队列，它们之间没有直接的关系或依赖。&lt;/p&gt;

&lt;p&gt;以下是分区之间的一些关系和特点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;独立性：每个分区都是独立的，它们之间没有共享状态或数据。每个分区都有自己的消息序列，消费者可以独立地订阅和消费特定的分区。&lt;/li&gt;
  &lt;li&gt;并行处理：由于分区之间是独立的，多个消费者可以同时消费不同的分区，实现消息的并行处理。这样可以提高系统的吞吐量和处理能力。&lt;/li&gt;
  &lt;li&gt;负载均衡：分区的数量和分布可以根据负载情况进行调整，以实现负载均衡。当系统负载较高时，可以增加分区的数量，从而将负载分散到更多的分区上。&lt;/li&gt;
  &lt;li&gt;顺序保证：每个分区内的消息是有序的，但不同分区之间的消息顺序是无法保证的。如果需要保证全局顺序，可以使用单个分区或者其他机制来实现。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;需要注意的是，分区之间的独立性和并行处理特性使得Pulsar能够实现高吞吐量和可扩展性。&lt;/p&gt;

&lt;h4 id=&quot;5四种订阅模式&quot;&gt;&lt;strong&gt;5、四种订阅模式&lt;/strong&gt;&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Exclusive（独占模式）：一个 Subscription 只能与一个 Consumer 关联，只有这个 Consumer 可以接收到 Topic 的全部消息，如果该 Consumer 出现故障了就会停止消费。Exclusive 订阅模式下，同一个 Subscription 里只有一个 Consumer 能消费 Topic，如果多个 Consumer 订阅则会报错，适用于全局有序消费的场景。&lt;/li&gt;
  &lt;li&gt;Shared（共享模式）：在共享模式下，多个消费者可以共同订阅和消费特定的Topic或分区。消息会被均匀分配给订阅的消费者，每个消费者都可以接收到部分消息。适用于需要多个消费者并行处理消息的场景。&lt;/li&gt;
  &lt;li&gt;Key_Shared（键共享模式）：当存在多个 Consumer 时，将根据消息的 Key 进行分发，Key 相同的消息只会被分发到同一个消费者。这样可以保证具有相同键的消息被同一个消费者处理，从而实现基于键的有序性。适用于需要按照键进行有序处理的场景。&lt;/li&gt;
  &lt;li&gt;灾备模式（Failover）：当存在多个 consumer 时，将会按字典顺序排序，第一个 consumer 被初始化为唯一接受消息的消费者。当第一个 consumer 断开时，所有的消息（未被确认和后续进入的）将会被分发给队列中的下一个 consumer。适用于需要高可用性和故障转移的场景。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这些订阅模式可以根据具体的业务需求选择，以满足不同的消息处理和消费方式。通过灵活使用这些订阅模式，Pulsar可以适应各种不同的应用场景和需求。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/81.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;需要注意的是，上面的订阅模式，指的是一个订阅里，有四种模式，但是一个Topic可以有多个订阅，这样的话，多个订阅，就能达到广播模式。&lt;/p&gt;</content><author><name>Ted</name></author><category term="消息队列" /><summary type="html">1、架构</summary></entry><entry><title type="html">通道Channel</title><link href="http://www.helloted.com/golang/2023/02/11/channel/" rel="alternate" type="text/html" title="通道Channel" /><published>2023-02-11T20:00:00+08:00</published><updated>2023-02-11T20:00:00+08:00</updated><id>http://www.helloted.com/golang/2023/02/11/channel</id><content type="html" xml:base="http://www.helloted.com/golang/2023/02/11/channel/">&lt;h4 id=&quot;1channel介绍&quot;&gt;&lt;strong&gt;1、Channel介绍&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;通过共享内存来通讯和通过通讯来共享内存是并发编程中的两种编程风格。&lt;/p&gt;

&lt;p&gt;当通过共享内存来通讯的时候，我们需要一些传统的并发同步技术（比如互斥锁）来避免数据竞争。&lt;/p&gt;

&lt;p&gt;Go提供了一种独特的并发同步技术来实现通过通讯来共享内存。此技术即为Channel。 我们可以把一个Channel看作是在一个程序内部的一个先进先出（FIFO：first in first out）数据队列。 一些协程可以向此Channel发送数据，另外一些协程可以从此Channel接收数据。Go Channel可以帮助程序员轻松地避免数据竞争。&lt;/p&gt;

&lt;p&gt;尽管Go也支持几种传统的数据同步技术，但是只有Channel为一等公民。 Channel是Go中的一种类型，所以我们可以无需引进任何代码包就可以使用Channel。 几种传统的数据同步技术提供在sync和sync/atomic标准库包中。&lt;/p&gt;

&lt;p&gt;实事求是地说，每种并发同步技术都有它们各自的最佳应用场景，但是Channel的&lt;a href=&quot;https://gfw.go101.org/article/channel-use-cases.html&quot;&gt;应用范围更广&lt;/a&gt;。 使用Channel来做同步常常可以使得代码看上去更整洁和易于理解。&lt;/p&gt;

&lt;h4 id=&quot;2通道类型和值&quot;&gt;&lt;strong&gt;2、通道类型和值&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;通道类型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;和数组、切片以及映射类型一样，每个通道类型也有一个元素类型。 一个通道只能传送它的（通道类型的）元素类型的值。&lt;/p&gt;

&lt;p&gt;通道可以是双向的，也可以是单向的。假设T是一个元素类型&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;chan T  ：双向通道类型。&lt;/li&gt;
  &lt;li&gt;chan&amp;lt;- T  ：单向可发送通道类型，编译器不允许从此类型的值中接收数据。&lt;/li&gt;
  &lt;li&gt;&amp;lt;-chan T  ：单向可接收通道类型。 编译器不允许向此类型的值中发送数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通道箭头&amp;lt;-总是指向左边。类型T总是在最右。&lt;/p&gt;

&lt;p&gt;双向通道chan T可以被隐式转换为单向通道类型chan&amp;lt;- T和&amp;lt;-chan T，但反之不行（即使显式也不行）。 类型chan&amp;lt;- T和&amp;lt;-chan T的值也不能相互转换。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;通道零值&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通道类型的零值也使用nil来表示。&lt;/p&gt;

&lt;p&gt;一个非零通道值必须通过内置的make函数来创建。 比如make(chan int, 10)将创建一个元素类型为int，容量为10的通道值。 第二个参数指定了欲创建的通道的容量。此第二个实参是可选的，它的默认值为0。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;缓存、非缓存&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个容量为0的通道值称为一个非缓冲通道（unbuffered channel）；&lt;/li&gt;
  &lt;li&gt;一个容量不为0的通道值称为一个缓冲通道（buffered channel）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;通道的堵塞：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果 buffered channel 中还有数据，那么，从这个 channel 接收数据的时候就不会阻塞，&lt;/li&gt;
  &lt;li&gt;如果 buffered channel 还未满（“满”指达到其容量），给它发送数据也不会阻塞，否则就会阻塞。&lt;/li&gt;
  &lt;li&gt;unbuffered chan 只有读写都准备好之后才不会阻塞，这也是很多使用 unbuffered chan 时的常见 Bug。&lt;/li&gt;
  &lt;li&gt;nil 是 chan 的零值，是一种特殊的 chan，对值是 nil 的 chan 的发送接收调用者总是会阻塞。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;3通道操作&quot;&gt;&lt;strong&gt;3、通道操作&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;Go中有五种通道相关的操作：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;关闭通道&lt;/li&gt;
  &lt;li&gt;向通道内发送值&lt;/li&gt;
  &lt;li&gt;从通道内接收值&lt;/li&gt;
  &lt;li&gt;查询通道容量&lt;/li&gt;
  &lt;li&gt;查询通道内队列长度&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;假设一个通道（值）为ch，下面列出了这五种操作的语法或者函数调用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.1  关闭通道：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; close(ch) 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;传给close函数调用的实参必须为一个通道，并且此通道值不能为单向接收的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.2 向通道ch发送一个值v：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; ch &amp;lt;- v  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;v必须能够赋值给通道ch的元素类型。 ch不能为单向接收通道。 &amp;lt;-称为数据发送操作符。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.3 从通道ch接收一个值：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;v = &amp;lt;-ch
v, sentBeforeClosed = &amp;lt;-ch
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接收数据时，还可以返回两个值。第一个值是返回的 chan 中的元素，很多人不太熟悉的是第二个值。第二个值是 bool 类型，代表是否成功地从 chan 中读取到一个值，如果第二个参数是 false，chan 已经被 close 而且 chan 中没有缓存的数据，这个时候，第一个值是零值。所以，如果从 chan 读取到一个零值，可能是 sender 真正发送的零值，也可能是 closed 的并且没有缓存元素产生的零值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.4 查询一个通道的容量：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cap(ch) 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中cap是一个已经在&lt;a href=&quot;https://gfw.go101.org/article/container.html#cap-len&quot;&gt;容器类型&lt;/a&gt;一文中介绍过的内置函数。 cap的返回值的类型为内置类型int。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.5 查询一个通道的长度：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;           ```        
            len(ch)      
           ```
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中len是一个已经在&lt;a href=&quot;https://gfw.go101.org/article/container.html#cap-len&quot;&gt;容器类型&lt;/a&gt;一文中介绍过的内置函数。 len的返回值的类型也为内置类型int。 一个通道的长度是指当前有多少个已被发送到此通道但还未被接收出去的元素值。&lt;/p&gt;

&lt;h4 id=&quot;4channel-的五种应用场景&quot;&gt;4、&lt;strong&gt;channel 的五种应用场景&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/78.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1、消息交流&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;channel 的底层是一个循环队列，当队列的长度大于 0 的 时候，它会被当做线程安全队列和 buffer。利用这个特性，一个 goroutine 可以安全的往 channel 中存放数据，另一个 goroutine 可以安全的从 channel 中读取数据，这样就实现了 goroutine 之间的消息交流。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、数据传递&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;数据传递类似游戏“击鼓传花”。鼓响时，花（或者其它物件）从一个人手里传到下一个人，数据就类似这里的花。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、信号通知&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;channel 类型有这样一个特性：如果 channel 为空，那么 recevier 接收数据的时候就会阻塞，直到有新的数据进来或者 channel 被关闭。&lt;/p&gt;

&lt;p&gt;利用这个特性，就可以实现 wait/notify 设计模式。另外还有一个经常碰到的场景，实现程序的 graceful shutdown。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;......&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// 执行业务处理&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

  &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// 处理CTRL+C等中断信号&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;termChan&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Notify&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;termChan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;syscall&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SIGINT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;syscall&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SIGTERM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;termChan&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; 

  &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// 执行退出之前的清理动作&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;doCleanup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
  
  &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;优雅退出&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;4、锁&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;利用 channel 我们也能实现锁的功能。&lt;/p&gt;

&lt;p&gt;sync.Mutex 通过修改持有锁标记位的状态达到占有锁的目的，因此 channel 可以通过转移这个标记位的所有权实现占有锁。&lt;/p&gt;

&lt;p&gt;具体代码如下：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// 使用chan实现互斥锁&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mutex&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// 使用锁需要初始化&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewMutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mutex&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}{}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// 请求锁，直到获取到&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// 解锁&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}{}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;unlock of unlocked mutex&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// 尝试获取锁&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TryLock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;no&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// 加入一个超时的设置&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LockTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Duration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timer&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewTimer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Stop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;no&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// 锁是否已被持有&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IsLocked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewMutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TryLock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;locked v %v&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TryLock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;locked %v&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里实现锁主要利用了向满 channel 发送数组或从空 channel 接收数据会阻塞的特性。另外，利用 select 很容易实现 TryLock 和 Timeout 的功能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5、任务编排&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通过 WaitGroup，我们能很容易的实现 等待一组 goroutine 完成任务这种任务编排需求。同样，我们也可以用 channel 实现。&lt;/p&gt;

&lt;p&gt;但是如果任务编排再复杂一些呢？如果面试官出了下面这个题目：&lt;/p&gt;

&lt;p&gt;有一批任务需要处理，但是机器资源有限，只能承受100的并发度，该如何实现？&lt;/p&gt;

&lt;p&gt;一种解决方案就是使用 channel，代码如下：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{})&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;//执行任务&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}{}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;concurrency100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}{}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;利用 sender 给满员的 channel 发送数据会阻塞的特性，就实现了并发度始终维持在 100 的需求。&lt;/p&gt;</content><author><name>Ted</name></author><category term="Golang" /><summary type="html">1、Channel介绍</summary></entry><entry><title type="html">数据库文件</title><link href="http://www.helloted.com/%E6%95%B0%E6%8D%AE%E5%BA%93/2023/01/15/file/" rel="alternate" type="text/html" title="数据库文件" /><published>2023-01-15T20:00:00+08:00</published><updated>2023-01-15T20:00:00+08:00</updated><id>http://www.helloted.com/%E6%95%B0%E6%8D%AE%E5%BA%93/2023/01/15/file</id><content type="html" xml:base="http://www.helloted.com/%E6%95%B0%E6%8D%AE%E5%BA%93/2023/01/15/file/">&lt;p&gt;在数据库中， 不论读一行，还是读多行，都是将这些行所在的页进行加载。&lt;/p&gt;

&lt;p&gt;也就是说存储空间的基本单位是页。&lt;/p&gt;

&lt;p&gt;一个页就是一棵树B+树的节点，数据库I/O操作的最小单位是页，与数据库相关的内容都会存储在页的结构里。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/74.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;1innodb的物理文件&quot;&gt;&lt;strong&gt;1、InnoDB的物理文件&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;InnoDB是MySQL使用最为广泛的存储引擎。&lt;/p&gt;

&lt;p&gt;我们每创建一个 database（数据库） 都会在 /var/lib/mysql/ 目录里面创建一个以库名为名称的目录，然后保存表结构和表数据的文件都会存放在这个目录里。&lt;/p&gt;

&lt;p&gt;当我们创建一个table时， InnoDB会创建三个文件。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;.opt文件，存储当前库字符集；&lt;/li&gt;
  &lt;li&gt;.frm文件，表结构定义文件；&lt;/li&gt;
  &lt;li&gt;.ibd文件，数据实际存储文件， 并且所有的索引也将存放在这个文件中；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/75.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果我们新建一个t_order的表，会有以下几个文件&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;db.opt，用来存储当前数据库的默认字符集和字符校验规则。&lt;/li&gt;
  &lt;li&gt;t_order.frm ，t_order 的表结构会保存在这个文件。每次建立一张表都会生成一个.frm 文件，该文件是用来保存每个表的元数据信息的，主要包含表结构定义。&lt;/li&gt;
  &lt;li&gt;t_order.ibd，t_order的数据实际存储文件。每一张表的数据都存放在一个独立的 .ibd 文件，包含实际数据和索引。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2数据文件的结构&quot;&gt;&lt;strong&gt;2、数据文件的结构&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;数据文件由段（segment）、区（extent）、页（page）、行（row）组成，InnoDB存储引擎的逻辑存储结构大致如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/76.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面我们从下往上一个个看看。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;行（row）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;数据库表中的记录都是按行（row）进行存放的，每行记录根据不同的行格式，有不同的存储结构。&lt;/p&gt;

&lt;p&gt;后面我们详细介绍 InnoDB 存储引擎的行格式，也是本文重点介绍的内容。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;页（page）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I/O 操作）只能处理一行数据，效率会非常低。&lt;/p&gt;

&lt;p&gt;因此，InnoDB 的数据是按「页」为单位来读写的，也就是说，当需要读一条记录的时候，并不是将这个行记录从磁盘读出来，而是以页为单位，将其整体读入内存。&lt;/p&gt;

&lt;p&gt;默认每个页的大小为 16KB，也就是最多能保证 16KB 的连续存储空间。&lt;/p&gt;

&lt;p&gt;页是 InnoDB 存储引擎磁盘管理的最小单元，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。&lt;/p&gt;

&lt;p&gt;页的类型有很多，常见的有数据页、undo 日志页、溢出页等等。数据表中的行记录是用「数据页」来管理的总之知道表中的记录存储在「数据页」里面就行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;区（extent）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们知道 InnoDB 存储引擎是用 B+ 树来组织数据的。&lt;/p&gt;

&lt;p&gt;B+ 树中每一层都是通过双向链表连接起来的，如果是以页为单位来分配存储空间，那么链表中相邻的两个页之间的物理位置并不是连续的，可能离得非常远，那么磁盘查询时就会有大量的随机I/O，随机 I/O 是非常慢的。&lt;/p&gt;

&lt;p&gt;解决这个问题也很简单，就是让链表中相邻的页的物理位置也相邻，这样就可以使用顺序 I/O 了，那么在范围查询（扫描叶子节点）的时候性能就会很高。&lt;/p&gt;

&lt;p&gt;那具体怎么解决呢？&lt;/p&gt;

&lt;p&gt;在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I/O 了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;段（segment）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;表空间是由各个段（segment）组成的，段是由多个区（extent）组成的。段一般分为数据段、索引段和回滚段等。&lt;/p&gt;

&lt;p&gt;索引段：存放 B + 树的非叶子节点的区的集合；&lt;/p&gt;

&lt;p&gt;数据段：存放 B + 树的叶子节点的区的集合；&lt;/p&gt;

&lt;p&gt;回滚段：存放的是回滚数据的区的集合&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;每一行数据都是放在数据页，按数据页为单位把磁盘上的数据加载到内存的缓存页。真正处理数据的过程是发生在内存中的，所以需要把磁盘中的数据加载到内存中，如果是处理写入或修改请求的话，还需要把内存中的内容刷新到磁盘上，也是以页为单位，将缓存页的数据刷入磁盘上的数据页。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为何不直接更新磁盘数据？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;来个请求就直接对磁盘文件进行随机读写，然后更新磁盘文件里的数据，执行请求性能必然极差。因为磁盘随机读写性能极差，所以MySQL才设计了这套机制，通过在内存里更新数据，然后写redo log及事务提交，后台线程不定时地刷新内存数据到磁盘文件。这样每个更新请求，基本都是更新内存，然后顺序写日志文件，这两种操作性能都是很高的。&lt;/p&gt;

&lt;h3 id=&quot;3行记录格式-compact格式&quot;&gt;&lt;strong&gt;3、行记录格式-Compact格式&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;MySQL 数据存储格式主要有两种，一种是行格式，另一种是列格式。其中，行格式存储方式是 MySQL 中默认的存储方式，也是最常用的存储方式。列格式存储方式主要用于存储大数据类型的字段，例如 BLOB 和 TEXT 类型的字段。&lt;/p&gt;

&lt;p&gt;InnoDB 提供了 4 种行格式，分别是 Redundant、Compact、Dynamic和 Compressed 行格式。从 MySQL 5.1 版本之后，行格式默认设置成 Compact。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/77.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;1变长字段长度列表&quot;&gt;1：变长字段长度列表&lt;/h5&gt;

&lt;p&gt;mysql中支持一些变长数据类型（比如VARCHAR(M)、TEXT等），它们存储数据占用的存储空间不是固定的，而是会随着存储内容的变化而变化。在Compact行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表，各变长字段数据占用的字节数按照列的顺序逆序存放&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;变长字段长度列表中只存储值为 非NULL 的列内容占用的长度，值为 NULL 的列的长度是不储存的 。&lt;/li&gt;
  &lt;li&gt;并不是所有记录都有这个 变长字段长度列表 部分，比方说表中所有的列都不是变长的数据类型的话，这一部分就不需要有&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;2null值列表&quot;&gt;2：NULL值列表&lt;/h5&gt;

&lt;p&gt;NULL值列表：Compact格式会把所有可以为NULL的列统一管理起来，存在一个NULL值列表，如果表中没有允许为NULL的列，则NULL值列表也不复存在了。&lt;/p&gt;

&lt;p&gt;为什么要有NULL值列表？&lt;/p&gt;

&lt;p&gt;表中的某些列可能存储NULL值，如果把这些NULL值都放到记录的真实数据中存储会很浪费空间，所以Compact行格式把这些值为NULL的列统一管理起来，存储到NULL值列表中，它的处理过程是这样的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;首先统计表中允许存储NULL的列有哪些。&lt;/li&gt;
  &lt;li&gt;根据列的实际值，用0或者1填充NULL值列表，1代表该列的值为空，0代表该列的值不为空。&lt;/li&gt;
  &lt;li&gt;如果表中没有允许存储 NULL 的列，则 NULL值列表 也不存在了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;3记录头信息&quot;&gt;3：记录头信息&lt;/h5&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;名称&lt;/th&gt;
      &lt;th&gt;大小(单位:bit)&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;预留位1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;未使用&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;预留位2&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;未使用&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;delete_mask&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;标记改记录是否被删除&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;min_rec_mask&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;B+树非叶子节点中最小记录都会添加该标记&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;n_owned&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;当前记录拥有的记录数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;heap_no&lt;/td&gt;
      &lt;td&gt;13&lt;/td&gt;
      &lt;td&gt;当前记录在记录堆的位置信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;record_type&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;记录类型 0：普通记录 1：B+树非叶子节点记录2：最小记录3：最大记录&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;next_record&lt;/td&gt;
      &lt;td&gt;16&lt;/td&gt;
      &lt;td&gt;下一条记录的相对位置&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;为什么「变长字段长度列表」的信息要按照逆序存放？&lt;/p&gt;

&lt;p&gt;这个设计是有想法的，主要是因为「记录头信息」中指向下一个记录的指针，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。&lt;/p&gt;

&lt;p&gt;「变长字段长度列表」中的信息之所以要逆序存放，是因为这样可以使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU Cache Line 中，这样就可以提高 CPU Cache 的命中率。&lt;/p&gt;

&lt;p&gt;同样的道理， NULL 值列表的信息也需要逆序存放。&lt;/p&gt;

&lt;p&gt;varchar(n) 中 n 最大取值为多少？&lt;/p&gt;

&lt;p&gt;一行记录最大能存储 65535 字节的数据，但是这个是包含「变长字段字节数列表所占用的字节数」和「NULL值列表所占用的字节数」。所以， 我们在算 varchar(n) 中 n 最大值时，需要减去这两个列表所占用的字节数。&lt;/p&gt;

&lt;p&gt;如果一张表只有一个 varchar(n) 字段，且允许为 NULL，字符集为 ascii。varchar(n) 中 n 最大取值为 65532。&lt;/p&gt;

&lt;p&gt;计算公式：65535 - 变长字段字节数列表所占用的字节数 - NULL值列表所占用的字节数 = 65535 - 2 - 1 = 65532。&lt;/p&gt;

&lt;p&gt;如果有多个字段的话，要保证所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 &amp;lt;= 65535。&lt;/p&gt;

&lt;p&gt;行溢出后，MySQL 是怎么处理的？&lt;/p&gt;

&lt;p&gt;如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。&lt;/p&gt;

&lt;p&gt;Compact 行格式针对行溢出的处理是这样的：当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。&lt;/p&gt;</content><author><name>Ted</name></author><category term="数据库" /><summary type="html">在数据库中， 不论读一行，还是读多行，都是将这些行所在的页进行加载。</summary></entry><entry><title type="html">Golang-Map</title><link href="http://www.helloted.com/golang/2023/01/05/map/" rel="alternate" type="text/html" title="Golang-Map" /><published>2023-01-05T20:00:00+08:00</published><updated>2023-01-05T20:00:00+08:00</updated><id>http://www.helloted.com/golang/2023/01/05/map</id><content type="html" xml:base="http://www.helloted.com/golang/2023/01/05/map/">&lt;h3 id=&quot;1-map的本质&quot;&gt;&lt;strong&gt;1、 map的本质&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;golang中的map是一个指针。当执行语句 make(map[k]v, hint) 的时候，其实是调用了 makemap 函数，返回了一个指针&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// makemap implements Go map creation for make(map[k]v, hint).
func makemap(t *maptype, hint int, h *hmap) *hmap    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;hmap是map的底层：是 hashmap 的“缩写”，但是hmap还不是主要存储key value的结构，hmap做的是一些map结构的基本设定。&lt;/p&gt;

&lt;h3 id=&quot;2结构&quot;&gt;&lt;strong&gt;2、结构&lt;/strong&gt;&lt;/h3&gt;

&lt;h4 id=&quot;21-实现原理&quot;&gt;&lt;strong&gt;2.1 实现原理&lt;/strong&gt;&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Go中的map是一个指针，占用8个字节，指向hmap结构体; 源码src/runtime/map.go中可以看到map的底层结构&lt;/li&gt;
  &lt;li&gt;每个map的底层结构是hmap，hmap包含若干个结构为bmap的bucket数组。每个bucket底层都采用链表结构&lt;/li&gt;
  &lt;li&gt;每个 bucket 中存储的是 Hash 值低 bit 位数值相同的元素，默认的元素个数为 BUCKETSIZE（值为 8，Go 1.17 版本中在 $GOROOT/src/cmd/compile/internal/reflectdata/reflect.go 中定义，与runtime/map.go 中常量 bucketCnt 保持一致）&lt;/li&gt;
  &lt;li&gt;当某个 bucket（比如 buckets[0]) 的 8 个空槽 slot）都填满了，且 map 尚未达到扩容的条件的情况下，运行时会建立 overflow bucket，并将这个 overflow bucket 挂在上面 bucket（如 buckets[0]）末尾的 overflow 指针上，这样两个 buckets 形成了一个链表结构，直到下一次 map 扩容之前，这个结构都会一直存在&lt;/li&gt;
  &lt;li&gt;map 结构，key和value单独排列在一起可以减少结构体对齐填充，减少内存浪费&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/64.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;22-hmap&quot;&gt;&lt;strong&gt;2.2 hmap&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;map本质是hash表（hmap），指向一堆桶（buckets）用来承接数据，每个桶（bmap）能存8组k/v。&lt;/p&gt;

&lt;p&gt;当有数据读写时，会用key的hash找到对应的桶，hash值低8位用来定位桶，高8位用来定位桶内位置，bmap里记录了tophash数组（hash的高8位），方便桶内定位。&lt;/p&gt;

&lt;p&gt;hash表就会有哈希冲突的问题（不同key的hash值一样，即hash后都指向同一个桶），为此map使用桶后链一个溢出桶（overflow）链表来解决当桶8个单元都满了，但还有数据需要存入此桶的问题。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// hmap的基础数据结构
type hmap struct {
	count     int	 // 元素的个数 == len()返回的值，必须放在第一个位置因为 len函数需要使用，所以map的len()时间复杂度是O(1)
	flags     uint8  // map的操作状态，如当前是否有别的线程正在写map、当前是否为相同大小的增长（扩容/缩容？）
	B         uint8  // hash桶buckets的数量为2^B个
	noverflow uint16 // 溢出的桶的数量的近似值
	hash0     uint32 // hash种子

	buckets    unsafe.Pointer // 指向2^B个桶组成的数组的指针，数据存在这里
	oldbuckets unsafe.Pointer // 指向扩容前的旧buckets数组，只在map增长时有效
	nevacuate  uintptr        // 计数器，标示扩容后搬迁的进度

	extra *mapextra // 保存溢出桶的链表和未使用的溢出桶数组的首地址
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/65.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/66.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;23-bmap&quot;&gt;&lt;strong&gt;2.3 bmap&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;bmap 就是我们常说的“桶”，桶里面会最多装 8 个 key，这些 key 之所以会落入同一个桶，是因为它们经过哈希计算后，哈希结果是“一类”的。在桶内，又会根据 key 计算出来的 hash 值的高 8 位来决定 key 到底落入桶内的哪个位置（tophash数组记录了key的高8位，方便key用来查找bmap，以及bmap中定位keyvaule）。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type bmap struct {
    tophash [bucketCnt]uint8
    // len为8的数组
    // 用来快速定位key是否在这个bmap中
    // 桶的槽位数组，一个桶最多8个槽位，如果key所在的槽位在tophash中，则代表该key在这个桶中
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但这只是表面(src/runtime/hashmap.go)的结构，编译期间会给它加料，动态地创建一个新的结构：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type bmap struct {
    topbits  [8]uint8
    keys     [8]keytype
    values   [8]valuetype
    pad      uintptr
    overflow uintptr
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意到 key 和 value 是各自放在一起的，并不是 key/value/key/value/… 这样的形式。源码里说明这样的好处是在某些情况下可以省略掉 padding字段，节省内存空间。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/67.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;24-tophash&quot;&gt;&lt;strong&gt;2.4 tophash&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;tophash是一个长度为8的数组，记录了key的高8位，方便桶内定位。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;向 map 插入一条数据，或者是从 map 按 key 查询数据的时候，运行时都会使用哈希函数对 key 做哈希运算，并获得一个哈希值（hashcode）&lt;/li&gt;
  &lt;li&gt;运行时会把 hashcode“一分为二”来看待，其中低位区的值用于选定 bucket，高位区的值用于在某个 bucket 中确定 key 的位置&lt;/li&gt;
  &lt;li&gt;每个 bucket 的 tophash 区域其实是用来快速定位 key 位置的，避免了逐个 key 进行比较这种代价较大的操作&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/68.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每一个tophash唯一对应一个K/V对。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/69.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;tophash是一个长度为8的数组，它不仅仅用来存放key的哈希高8位，在不同场景下它还可以标记迁移状态，bucket是否为空等。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当tophash对应的K/V被使用时，存的是key的哈希值的高8位；&lt;/li&gt;
  &lt;li&gt;当tophash对应的K/V未被使用时，存的是K/V对应位置的状态。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-go-map的扩容缩容&quot;&gt;3. go map的扩容缩容&lt;/h3&gt;

&lt;h4 id=&quot;31扩容过程&quot;&gt;&lt;strong&gt;3.1扩容过程&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;主要是由于哈希碰撞问题&lt;/p&gt;

&lt;p&gt;​    &lt;img src=&quot;/img/Simple_2/70.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;什么情况下会map扩容呢：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;溢出桶太多时会导致严重的性能下降&lt;/li&gt;
  &lt;li&gt;runtime.mapassign()可能会触发扩容的情况
    &lt;ul&gt;
      &lt;li&gt;装载因子超过6.5个（平均每个槽6.5个key）&lt;/li&gt;
      &lt;li&gt;使用太多溢出桶（溢出桶超过了普通桶）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;map的两种扩容类型:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;等量扩容（整理）：数据不多但是溢出桶太多了，使数据更紧凑&lt;/li&gt;
  &lt;li&gt;翻倍扩容：数据太多了增加普通桶的数量&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;map的扩容过程：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;步骤一&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建一组新桶&lt;/li&gt;
  &lt;li&gt;oldbuckets指向原有的桶数组&lt;/li&gt;
  &lt;li&gt;buckets指向新的桶数组&lt;/li&gt;
  &lt;li&gt;把map标记为扩容状态&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;​    &lt;img src=&quot;/img/Simple_2/71.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;步骤二&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;将所有的数据从旧桶驱逐到新桶&lt;/li&gt;
  &lt;li&gt;采用渐进式驱逐&lt;strong&gt;（好多技术都有这种思想，比如redis的rehash）&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;每次操作一个旧桶的时，将旧数据驱逐到新桶&lt;/li&gt;
  &lt;li&gt;读取时不进行驱逐，只判断读取新桶还是旧桶&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;​    &lt;img src=&quot;/img/Simple_2/72.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;步骤三&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;所有的旧桶驱逐完成后&lt;/li&gt;
  &lt;li&gt;oldbuckets回收&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;​     &lt;img src=&quot;/img/Simple_2/73.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;总结：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;装载系数或者溢出桶的增加，会触发map扩容&lt;/li&gt;
  &lt;li&gt;“扩容”可能并不是增加桶的数量，而是整理数据，使数据更加紧凑&lt;/li&gt;
  &lt;li&gt;map扩容采用渐进式，桶被操作时才会重新分配&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;32-扩容缩容的基本原理&quot;&gt;&lt;strong&gt;3.2 扩容缩容的基本原理&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;go map的扩容缩容都是grow相关的函数，这里扩容是真的，缩容是伪缩容，后面我会解释。我们先看下触发条件：&lt;/p&gt;

&lt;p&gt;触发 map 扩容的时机：在向 map 插入新 key 的时候，会进行条件检测，符合下面这 2 个条件，就会触发扩容：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;装载因子超过阈值，源码里定义的阈值是 6.5。&lt;/li&gt;
  &lt;li&gt;overflow 的 bucket 数量过多：当 B 小于 15，也就是 bucket 总数 2^B 小于 2^15 时，如果 overflow 的 bucket 数量超过 2^B；当 B &amp;gt;= 15，也就是 bucket 总数 2^B 大于等于 2^15，如果 overflow 的 bucket 数量超过 2^15。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;map只在插入元素即mapassign()函数中对是否扩容缩容进行触发，条件即是上面这段代码：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;条件1：当前不处在growing状态&lt;/li&gt;
  &lt;li&gt;条件2-1：触发扩容：map的数据量count大于hash桶数量(2B)*6.5。注意这里的(2B)只是hash数组大小，不包括溢出的桶&lt;/li&gt;
  &lt;li&gt;条件2-2：触发缩容：溢出的桶数量noverflow&amp;gt;=32768(1«15)或者&amp;gt;=hash数组大小。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;仔细观察触发的代码，扩容和缩容是同一个函数，这是怎么做到的呢？在hashGrow()开始，会先判断是否满足扩容条件，如果满足就表明这次是扩容，不满足就一定是缩容条件触发了。扩容和缩容剩下的逻辑，主要区别就在于容量变化，就是hmap.B参数，扩容时B+1则hash表容量扩大1倍，缩容时hash表容量不变。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;h.oldbuckets：指向旧的hash数组，即当前的h.buckets&lt;/li&gt;
  &lt;li&gt;h.buckets：指向新创建的hash数组&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;到这里触发的主要工作已经完成，接下来就是怎么把元素搬迁到新hash表里了。如果现在就一次全量搬迁过去，显然接下来会有比较长的一段时间map被占用（不支持并发）。所以搬迁的工作是异步增量搬迁的。&lt;/p&gt;

&lt;p&gt;在插入和删除的函数内都有下面一段代码用于在每次插入和删除操作时，执行一次搬迁工作：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; if h.growing() { // 当前处于搬迁状态
		growWork(t, h, bucket) // 调用搬迁函数
	}
	
func growWork(t *maptype, h *hmap, bucket uintptr) {
	// 将当前需要处理的桶搬迁
	evacuate(t, h, bucket&amp;amp;h.oldbucketmask())

	if h.growing() { // 再多搬迁一个桶
		evacuate(t, h, h.nevacuate)
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;每执行一次插入或删除，都会调用growWork搬迁0~2个hash桶（有可能这次需要搬迁的2个桶在此之前都被搬过了）&lt;/li&gt;
  &lt;li&gt;搬迁是以hash桶为单位的，包含对应的hash桶和这个桶的溢出链表&lt;/li&gt;
  &lt;li&gt;被delete掉的元素(emptyone标志)会被舍弃（这是缩容的关键）&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;33-为什么叫伪缩容如何实现真缩容&quot;&gt;&lt;strong&gt;3.3 为什么叫“伪缩容”？如何实现“真缩容”？&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;现在可以解释为什么我把map的缩容叫做伪缩容了：因为缩容仅仅针对溢出桶太多的情况，触发缩容时hash数组的大小不变，即hash数组所占用的空间只增不减。也就是说，如果我们把一个已经增长到很大的map的元素挨个全部删除掉，hash表所占用的内存空间也不会被释放。&lt;/p&gt;

&lt;p&gt;所以如果要实现“真缩容”，需自己实现缩容搬迁，即创建一个较小的map，将需要缩容的map的元素挨个搬迁过来：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// go map缩容代码示例
myMap := make(map[int]int, 1000000)

// 假设这里我们对bigMap做了很多次插入，之后又做了很多次删除，此时bigMap的元素数量远小于hash表大小
// 接下来我们开始缩容
smallMap := make(map[int]int, len(myMap))
for k, v := range myMap {
    smallMap[k] = v
}
myMap = smallMap // 缩容完成，原来的map被我们丢弃，交给gc去清理
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Ted</name></author><category term="Golang" /><summary type="html">1、 map的本质</summary></entry><entry><title type="html">数据库架构之Buffer Pool</title><link href="http://www.helloted.com/%E6%95%B0%E6%8D%AE%E5%BA%93/2022/12/10/buffer/" rel="alternate" type="text/html" title="数据库架构之Buffer Pool" /><published>2022-12-10T20:00:00+08:00</published><updated>2022-12-10T20:00:00+08:00</updated><id>http://www.helloted.com/%E6%95%B0%E6%8D%AE%E5%BA%93/2022/12/10/buffer</id><content type="html" xml:base="http://www.helloted.com/%E6%95%B0%E6%8D%AE%E5%BA%93/2022/12/10/buffer/">&lt;h3 id=&quot;1概念&quot;&gt;&lt;strong&gt;1、概念&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;InnoDB的Buffer Pool（缓冲池）是MySQL数据库中非常重要的一个组件，它主要用于缓存数据和索引，以提高数据库的性能。&lt;/p&gt;

&lt;p&gt;以下是Buffer Pool的主要作用：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;数据缓存：当你查询一个数据行时，InnoDB首先会在Buffer Pool中查找这个数据行。如果找到，那么就直接从内存中读取，这比从磁盘读取要快得多。如果在Buffer Pool中没有找到，那么InnoDB会从磁盘读取这个数据行，并将其放入Buffer Pool中，以便下次查询时能够直接从内存中读取。&lt;/li&gt;
  &lt;li&gt;索引缓存：除了数据行，InnoDB还会在Buffer Pool中缓存索引。这样，当你执行一个需要使用索引的查询时，InnoDB可以直接从内存中读取索引，而不需要从磁盘读取。&lt;/li&gt;
  &lt;li&gt;写操作的缓存：当你执行一个写操作（如INSERT、UPDATE或DELETE）时，InnoDB会先将修改写入到Buffer Pool中，然后在适当的时机（如在事务提交时或在做Checkpoint时）再将这些修改写入到磁盘。这种方式可以减少磁盘I/O操作，从而提高性能。&lt;/li&gt;
  &lt;li&gt;读写操作的并发控制：Buffer Pool中的每一个数据页都有对应的锁和读写控制机制，这样可以支持高并发的读写操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总的来说，InnoDB的Buffer Pool是一个非常重要的性能优化组件，它通过缓存数据和索引，以及优化磁盘I/O操作，来提高数据库的性能。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/61.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;总结&lt;/p&gt;

&lt;p&gt;Buffer Pool就是数据库的一个内存组件，里面缓存了磁盘上的真实数据，然后我们的系统对数据库执行的增删改操作，其实主要就是对这个内存数据结构中的缓存数据执行的。通过这种方式，保证每个更新请求，尽量就是只更新内存，然后往磁盘顺序写日志文件。&lt;/p&gt;

&lt;p&gt;更新内存的性能是极高的，然后顺序写磁盘上的日志文件的性能也是比较高的，因为顺序写磁盘文件，他的性能要远高于随机读写磁盘文件。&lt;/p&gt;

&lt;h3 id=&quot;2buffer-pool的工作流程&quot;&gt;&lt;strong&gt;2、buffer pool的工作流程&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;这条 SQL 语句的执行步骤大致是这样子的&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;innodb 存储引擎会在缓冲池中查找 id=1 的这条数据是否存在&lt;/li&gt;
  &lt;li&gt;发现不存在，那么就会去磁盘中加载，并将其存放在缓冲池中&lt;/li&gt;
  &lt;li&gt;该条记录会被加上一个独占锁&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/62.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;21--buffer-pool-vs-查询缓存&quot;&gt;&lt;strong&gt;2.1  buffer pool VS 查询缓存&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;在mysql8.0的版本中，已经将查询缓存模块删除了。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果将Mysql分为Server层和存储引擎层两大部分，那么Qcache位于Server层，Buffer Pool位于存储引擎层。&lt;/p&gt;

&lt;p&gt;　　如果你的Mysql 查询缓存功能是打开的，那么当一个sql进入Mysql Server之后，Mysql Server首先会从查询缓存中查看是否曾经执行过这个SQL，如果曾经执行过的话，曾经执行的查询结果之前会以key-value的形式&lt;/p&gt;

&lt;p&gt;保存在查询缓存中。key是sql语句，value是查询结果。我们将这个过程称为查询缓存！&lt;/p&gt;

&lt;p&gt;　　如果查询缓存中没有你要找的数据的话，MySQL才会执行后续的逻辑，通过存储引擎将数据检索出来。并且查询缓存会被shared cache for sessions，是的，它会被所有的session共享。&lt;/p&gt;

&lt;p&gt;　　MySQL查询缓存是查询结果缓存。它将以SEL开头的查询与哈希表进行比较，如果匹配，则返回上一次查询的结果。进行匹配时，查询必须逐字节匹配，例如 SELECT * FROM t1; 不等于select * from t1;，此外，一些不确定的查询结果无法被缓存，任何对表的修改都会导致这些表的所有缓存无效(只要有一个sql update了该表，那么表的查询缓存就会失效)。因此，适用于查询缓存的最理想的方案是只读，特别是需要检查数百万行后仅返回数行的复杂查询。如果你的查询符合这样一个特点，开启查询缓存会提升你的查询性能。&lt;/p&gt;

&lt;p&gt;　　MySQL查询缓存的目的是为了提升查询性能，但它本身也是有性能开销的。需要在合适的业务场景下（读写压力模型）使用，不合适的业务场景不但不能提升查询性能，查询缓存反而会变成MySQL的瓶颈。&lt;/p&gt;

&lt;p&gt;查询缓存的开销主要有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;读查询在开始前必须先检查是否命中缓存；&lt;/li&gt;
  &lt;li&gt;如果这个读查询可以被缓存，那么当完成执行后，MySQL若发现查询缓存中没有这个查询，会将其结果存入查询缓存，这会带来额外的系统消耗；&lt;/li&gt;
  &lt;li&gt;当向某个表写入数据的时候，MySQL必须将对应表的所有缓存都设置失效。如果查询缓存非常大或者碎片很多，这个操作就可能带来很大的系统消耗。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;查询缓存的缺点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;首先，查询缓存的效果取决于缓存的命中率，只有命中缓存的查询效果才能有改善，因此无法预测其性能。只要有一个sql update了该表，那么表的查询缓存就会失效，所以当你的业务对表CRUD的比例不相上下，那么查询缓存may be会影响应用的吞吐效率。&lt;/li&gt;
  &lt;li&gt;其次，查询缓存的另一个大问题是它受到单个互斥锁的保护。在具有多个内核的服务器上，大量查询会导致大量的互斥锁争用。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;在mysql8.0的版本中，已经将查询缓存模块删除了。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;22--undo-日志文件记录数据被修改前的样子&quot;&gt;&lt;strong&gt;2.2  undo 日志文件：记录数据被修改前的样子&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;在准备更新一条语句的时候，该条语句会先被加载到 Buffer pool 中了，同时，在将该条语句加载到 Buffer Pool 中的时候同时会往 undo 日志文件中插入一条日志，也就是将 id=1 的这条记录的原来的值记录下来。&lt;/p&gt;

&lt;p&gt;这样做的目的是什么？&lt;/p&gt;

&lt;p&gt;Innodb 存储引擎的最大特点就是支持事务，如果本次更新失败，也就是事务提交失败，那么该事务中的所有的操作都必须回滚到执行前的样子，也就是说当事务失败的时候，也不会对原始数据有影响，&lt;/p&gt;

&lt;h4 id=&quot;23-redo-日志文件记录数据被修改后的样子&quot;&gt;&lt;strong&gt;2.3 redo 日志文件：记录数据被修改后的样子&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;redo 日志文件是 InnoDB 特有的，他是存储引擎级别的，不是 MySQL 级别的&lt;/p&gt;

&lt;p&gt;redo 记录的是数据修改之后的值，不管事务是否提交都会记录下来。MySQL 为了提高效率，所以将这些操作都先放在内存中redo log buffer去完成，然后会在某个时机将其持久化到磁盘中。如果 MySQL 真的宕机了，那么没关系的，因为 MySQL 会认为本次事务是失败的，所以数据依旧是更新前的样子，并不会有任何的影响。&lt;/p&gt;

&lt;p&gt;语句也更新好了那么需要将更新的值提交啊，也就是需要提交本次的事务了，因为只要事务成功提交了，才会将最后的变更保存到数据库，在提交事务前仍然会具有相关的其他操作：将 redo Log Buffer 中的数据持久化到磁盘中，就是将 redo log buffer 中的数据写入到 redo log 磁盘文件中，一般情况下，redo log Buffer 数据写入磁盘的策略是立即刷入磁盘&lt;/p&gt;

&lt;h4 id=&quot;24-mysql更新数据的过程&quot;&gt;&lt;strong&gt;2.4 MYSQL更新数据的过程&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;截至目前，我们应该都熟悉了 MySQL 的执行器调用存储引擎是怎么将一条 SQL 加载到缓冲池和记录哪些日志的，流程如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;准备更新一条 SQL 语句&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;MySQL（innodb）会先去缓冲池（BufferPool）中去查找这条数据，没找到就会去磁盘中查找，如果查找到就会将这条数据加载到缓冲池（BufferPool）中&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在加载到 Buffer Pool 的同时，会将这条数据的原始记录保存到 undo 日志文件中&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;innodb 会在 Buffer Pool 中执行更新操作&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;更新后的数据会记录在 redo log buffer 中&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;MySQL 提交事务的时候，会将 redo log buffer 中的数据写入到 redo 日志文件中 刷磁盘可以通过 innodb_flush_log_at_trx_commit 参数来设置&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;值为 0 表示不刷入磁盘&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;值为 1 表示立即刷入磁盘&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;值为 2 表示先刷到 os cache&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;myslq 重启的时候会将 redo 日志恢复到缓冲池中&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/63.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3总结&quot;&gt;&lt;strong&gt;3、总结：&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;我们再回顾下&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Buffer Pool 是 MySQL 的一个非常重要的组件，因为针对数据库的增删改操作都是在 Buffer Pool 中完成的&lt;/li&gt;
  &lt;li&gt;Undo log 记录的是数据操作前的样子&lt;/li&gt;
  &lt;li&gt;redo log 记录的是数据被操作后的样子（redo log 是 Innodb 存储引擎特有）&lt;/li&gt;
  &lt;li&gt;bin log 记录的是整个操作记录（这个对于主从复制具有非常重要的意义）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;具体更新一条记录 UPDATE t_user SET name = ‘xiaolin’ WHERE id = 1; 的流程如下:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id = 1 这一行记录：&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;如果 id=1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新；&lt;/li&gt;
  &lt;li&gt;如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样：&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;如果一样的话就不进行后续更新流程；&lt;/li&gt;
  &lt;li&gt;如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;开启事务， InnoDB 层更新记录前，首先要记录相应的 undo log，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，不过在内存修改该 Undo 页面后，需要记录对应的 redo log。&lt;/li&gt;
  &lt;li&gt;InnoDB 层开始更新记录，会先更新内存（同时标记为脏页），然后将记录写到 redo log 里面，这个时候更新就算完成了。为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。这就是 &lt;strong&gt;WAL 技术&lt;/strong&gt;，MySQL 的写操作并不是立刻写到磁盘上，而是先写 redo 日志，然后在合适的时间再将修改的行数据写到磁盘上。&lt;/li&gt;
  &lt;li&gt;至此，一条记录更新完了。&lt;/li&gt;
  &lt;li&gt;在一条更新语句执行完成后，然后开始记录该语句对应的 binlog，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。&lt;/li&gt;
  &lt;li&gt;事务提交（为了方便说明，这里不说组提交的过程，只说两阶段提交）：&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;prepare 阶段：将 redo log 对应的事务状态设置为 prepare，然后将 redo log 刷新到硬盘；&lt;/li&gt;
  &lt;li&gt;commit 阶段：将 binlog 刷新到磁盘，接着调用引擎的提交事务接口，将 redo log 状态设置为 commit（将事务设置为 commit 状态后，刷入到磁盘 redo log 文件）；&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;至此，一条更新语句执行完成。&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Ted</name></author><category term="数据库" /><summary type="html">1、概念</summary></entry><entry><title type="html">Garbage Collection</title><link href="http://www.helloted.com/golang/2022/12/01/gc/" rel="alternate" type="text/html" title="Garbage Collection" /><published>2022-12-01T20:00:00+08:00</published><updated>2022-12-01T20:00:00+08:00</updated><id>http://www.helloted.com/golang/2022/12/01/gc</id><content type="html" xml:base="http://www.helloted.com/golang/2022/12/01/gc/">&lt;h3 id=&quot;一定义&quot;&gt;&lt;strong&gt;一、定义&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;GC，全称 Garbage Collection，即垃圾回收，是一种自动内存管理的机制。&lt;/p&gt;

&lt;p&gt;当程序向操作系统申请的内存不再需要时，垃圾回收主动将其回收并供其他代码进行内存申请时候复用，或者将其归还给操作系统，这种针对内存级别资源的自动回收过程，即为垃圾回收。&lt;/p&gt;

&lt;p&gt;而负责垃圾回收的程序组件，即为垃圾回收器。&lt;/p&gt;

&lt;p&gt;垃圾回收其实一个完美的 “Simplicity is Complicated” 的例子：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一方面，程序员受益于 GC，无需操心、也不再需要对内存进行手动的申请和释放操作，GC 在程序运行时自动释放残留的内存。也能够消除一些需要手动管理内存才会出现的运行时错误：
    &lt;ul&gt;
      &lt;li&gt;在仍然有指向内存区块的指针的情况下释放这块内存时，会产生悬挂指针，从而后续可能错误的访问已经用于他用的内存区域。&lt;/li&gt;
      &lt;li&gt;多重释放同一块申请的内存区域可能导致不可知的内存损坏&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;另一方面，GC 对程序员几乎不可见，仅在程序需要进行特殊优化时，通过提供可调控的 API，对 GC 的运行时机、运行开销进行把控的时候才得以现身。这也就造就了没有 GC 的一些优势：&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;没有额外的性能开销&lt;/li&gt;
  &lt;li&gt;精准的手动内存管理，极致的利用机器的性能&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;二gc的语言&quot;&gt;&lt;strong&gt;二、GC的语言&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;从原理上而言，所有的语言都能够自行实现 GC。&lt;/p&gt;

&lt;p&gt;从语言诞生之初就提供 GC 的语言，例如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Python&lt;/li&gt;
  &lt;li&gt;JavaScript&lt;/li&gt;
  &lt;li&gt;Java&lt;/li&gt;
  &lt;li&gt;Objective-C&lt;/li&gt;
  &lt;li&gt;Swift&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而不以 GC 为目标，被直接设计为手动管理内存、但可以自行实现 GC 的语言有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;C&lt;/li&gt;
  &lt;li&gt;C++&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;也有一些语言可以在编译期，依靠编译器插入清理代码的方式，实现精准的清理，例如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Rust&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;三gc方式&quot;&gt;&lt;strong&gt;三、GC方式&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;所有的 GC 算法其存在形式可以归结为追踪（Tracing）和引用计数（Reference Counting）这两种形式的混合运用。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;追踪式 GC从根对象出发，根据对象之间的引用信息，一步步推进直到扫描完毕整个堆并确定需要保留的对象，从而回收所有可回收的对象。Go、 Java、V8 对 JavaScript 的实现等均为追踪式 GC。&lt;/li&gt;
  &lt;li&gt;引用计数式 GC每个对象自身包含一个被引用的计数器，当计数器归零时自动得到回收。因为此方法缺陷较多，在追求高性能时通常不被应用。Python、Objective-C 等均为引用计数式 GC。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;目前比较常见的 GC 实现方式包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;追踪式，分为多种不同类型，例如：
    &lt;ul&gt;
      &lt;li&gt;标记清扫：从根对象出发，将确定存活的对象进行标记，并清扫可以回收的对象。&lt;/li&gt;
      &lt;li&gt;标记整理：为了解决内存碎片问题而提出，在标记过程中，将对象尽可能整理到一块连续的内存上。&lt;/li&gt;
      &lt;li&gt;增量式：将标记与清扫的过程分批执行，每次执行很小的部分，从而增量的推进垃圾回收，达到近似实时、几乎无停顿的目的。&lt;/li&gt;
      &lt;li&gt;增量整理：在增量式的基础上，增加对对象的整理过程。&lt;/li&gt;
      &lt;li&gt;分代式：将对象根据存活时间的长短进行分类，存活时间小于某个值的为年轻代，存活时间大于某个值的为老年代，永远不会参与回收的对象为永久代。并根据分代假设（如果一个对象存活时间不长则倾向于被回收，如果一个对象已经存活很长时间则倾向于存活更长时间）对对象进行回收。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;引用计数：根据对象自身的引用计数来回收，当引用计数归零时立即回收。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Ted</name></author><category term="Golang" /><summary type="html">一、定义</summary></entry><entry><title type="html">操作系统内存管理</title><link href="http://www.helloted.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2022/11/25/mem/" rel="alternate" type="text/html" title="操作系统内存管理" /><published>2022-11-25T20:00:00+08:00</published><updated>2022-11-25T20:00:00+08:00</updated><id>http://www.helloted.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2022/11/25/mem</id><content type="html" xml:base="http://www.helloted.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2022/11/25/mem/">&lt;h3 id=&quot;一内存管理&quot;&gt;一、内存管理&lt;/h3&gt;

&lt;p&gt;操作系统的内存管理非常重要，主要负责下面这些事情：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;内存的分配与回收：对进程所需的内存进行分配和释放，malloc 函数：申请内存，free 函数：释放内存。&lt;/li&gt;
  &lt;li&gt;地址转换：将程序中的虚拟地址转换成内存中的物理地址。&lt;/li&gt;
  &lt;li&gt;内存扩充：当系统没有足够的内存时，利用虚拟内存技术或自动覆盖技术，从逻辑上扩充内存。&lt;/li&gt;
  &lt;li&gt;内存映射：将一个文件直接映射到进程的进程空间中，这样可以通过内存指针用读写内存的办法直接存取文件内容，速度更快。&lt;/li&gt;
  &lt;li&gt;内存优化：通过调整内存分配策略和回收算法来优化内存使用效率。&lt;/li&gt;
  &lt;li&gt;内存安全：保证进程之间使用内存互不干扰，避免一些恶意程序通过修改内存来破坏系统的安全性。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;11-malloc是如何分配内存的&quot;&gt;&lt;strong&gt;1.1 malloc是如何分配内存的？&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;malloc 是 C 语言标准库中用于动态内存分配的函数。它从堆（heap）上分配指定大小的内存块，并返回一个指向该内存块的指针。如果分配失败，它返回 NULL。&lt;/p&gt;

&lt;p&gt;基本工作原理&lt;/p&gt;

&lt;p&gt;在使用 malloc 进行内存分配时，实际的处理过程涉及两个层面：首先是从进程的内存池中尝试分配内存，如果进程的内存池中没有足够的空间满足当前的请求，那么 malloc 会从操作系统那里请求更多的内存。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;从进程内存池中分配
    &lt;ul&gt;
      &lt;li&gt;内存池管理：进程的内存池通常由 malloc 管理，它包含了一系列已经从操作系统获取并为进程预留的内存块。这些内存块可能是连续的或者是非连续的，取决于之前的分配和释放操作。&lt;/li&gt;
      &lt;li&gt;内存分配尝试：当调用 malloc 请求内存时，malloc 首先检查其管理的内存池中是否有足够的空闲内存来满足请求。这涉及到查找合适大小的空闲块，可能需要根据内存分配算法（如首次适应、最佳适应等）来选择。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;从操作系统请求内存
    &lt;ul&gt;
      &lt;li&gt;内存池不足：如果进程的内存池中没有足够的空闲内存块来满足当前的请求，malloc 需要从操作系统请求更多的内存。&lt;/li&gt;
      &lt;li&gt;系统调用：malloc 通过系统调用（如 sbrk 或 mmap）向操作系统请求额外的内存。这些调用会将更多的内存区域分配给进程，从而扩展进程的堆空间。内存整合和返回&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;内存整合：获取到新的内存后，malloc 可能会执行一些内存整合操作，如合并相邻的空闲块，以优化内存的使用和减少碎片。&lt;/li&gt;
  &lt;li&gt;返回内存指针：完成内存分配后，malloc 将返回一个指向新分配内存块的指针。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;需要注意的是，malloc函数只负责分配内存，并不会初始化内存块的内容。如果需要初始化内存块，可以使用memset等函数进行操作。&lt;/p&gt;

&lt;h4 id=&quot;12-内存碎片&quot;&gt;1.2 &lt;strong&gt;内存碎片&lt;/strong&gt;&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;内部内存碎片(Internal Memory Fragmentation，简称为内存碎片)：已经分配给进程使用但未被使用的内存。导致内部内存碎片的主要原因是，当采用固定比例比如 2 的幂次方进行内存分配时，进程所分配的内存可能会比其实际所需要的大。举个例子，一个进程只需要 65 字节的内存，但为其分配了 128（2^7） 大小的内存，那 63 字节的内存就成为了内部内存碎片。&lt;/li&gt;
  &lt;li&gt;外部内存碎片(External Memory Fragmentation，简称为外部碎片)：由于未分配的连续内存区域太小，以至于不能满足任意进程所需要的内存分配请求，这些小片段且不连续的内存空间被称为外部碎片。也就是说，外部内存碎片指的是那些并未分配给进程但又不能使用的内存。我们后面介绍的分段机制就会导致外部内存碎片。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;二虚拟内存&quot;&gt;二、虚拟内存&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;虚拟内存(Virtual Memory)&lt;/strong&gt; 是计算机系统内存管理非常重要的一个技术，本质上来说它只是逻辑存在的，是一个假想出来的内存空间，主要作用是作为进程访问主存（物理内存）的桥梁并简化内存管理。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/60.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;虚拟地址空间构成虚拟内存。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片。还有部分暂时存储在外部磁盘存储器上（Swap），在需要时进行数据交换。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;虚拟内存提供了以下能力&lt;/strong&gt;：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;隔离进程：物理内存通过虚拟地址空间访问，虚拟地址空间与进程一一对应。每个进程都认为自己拥有了整个物理内存，进程之间彼此隔离，一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。&lt;/li&gt;
  &lt;li&gt;提升物理内存利用率：有了虚拟地址空间后，操作系统只需要将进程当前正在使用的部分数据或指令加载入物理内存。&lt;/li&gt;
  &lt;li&gt;简化内存管理：进程都有一个一致且私有的虚拟地址空间，程序员不用和真正的物理内存打交道，而是借助虚拟地址空间访问物理内存，从而简化了内存管理。&lt;/li&gt;
  &lt;li&gt;多个进程共享物理内存：进程在运行过程中，会加载许多操作系统的动态库。这些库对于每个进程而言都是公用的，它们在内存中实际只会加载一份，这部分称为共享内存。&lt;/li&gt;
  &lt;li&gt;提高内存使用安全性：控制进程对物理内存的访问，隔离不同进程的访问权限，提高系统的安全性。&lt;/li&gt;
  &lt;li&gt;提供更大的可使用内存空间：可以让程序拥有超过系统物理内存大小的可用内存空间。这是因为当物理内存不够用时，可以利用磁盘充当，将物理内存页（通常大小为 4 KB）保存到磁盘文件（会影响读写速度），数据或代码页会根据需要在物理内存与磁盘之间移动。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;总的来说，虚拟内存技术通过将物理内存和磁盘空间结合起来，为每个进程提供了一个连续的、抽象的地址空间。它扩展了地址空间、提供了内存管理和保护机制，支持共享和隔离，提高了系统的性能和资源利用率，使得计算机系统更加灵活、稳定和安全。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;虚拟内存的工作原理如下&lt;/strong&gt;：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;地址空间划分：每个进程都有自己的虚拟地址空间，通常是一个连续的地址范围。这个地址空间被划分为多个固定大小的页面（通常是4KB），每个页面都有一个唯一的虚拟地址。&lt;/li&gt;
  &lt;li&gt;页面映射：虚拟内存管理器将虚拟页面映射到物理内存或磁盘上的页面框（通常也是4KB）。这个映射关系存储在页表中，页表记录了虚拟页面和物理页面之间的对应关系。&lt;/li&gt;
  &lt;li&gt;页面置换：当进程访问一个虚拟页面时，虚拟内存管理器首先检查该页面是否已经在物理内存中。如果在物理内存中，就直接访问；如果不在物理内存中，就发生了缺页中断。&lt;/li&gt;
  &lt;li&gt;缺页中断处理：当发生缺页中断时，操作系统会根据页表中的映射关系，将对应的页面从磁盘读取到物理内存中的一个空闲页面框中，并更新页表。然后，进程的执行可以继续，就好像该页面一直在物理内存中一样。&lt;/li&gt;
  &lt;li&gt;页面置换算法：当物理内存不足时，操作系统需要选择一个页面进行置换，将其写回磁盘并释放其物理内存。常用的页面置换算法有最近最久未使用（LRU）、先进先出（FIFO）和时钟（Clock）算法等。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;虚拟内存缺点&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;性能开销：虚拟内存的使用涉及到页表查找和磁盘I/O操作，这些都可能导致性能下降。特别是当系统频繁进行换页操作时，会显著影响系统性能，这种现象称为“抖动”。&lt;/li&gt;
  &lt;li&gt;硬盘速度限制：虽然现代固态硬盘（SSD）的速度已经大幅提升，但相比于物理内存，硬盘的访问速度仍然较慢。频繁的访问硬盘来加载或存储页面会减慢程序的执行速度。&lt;/li&gt;
  &lt;li&gt;复杂的内存管理：虚拟内存系统需要复杂的硬件支持（如内存管理单元MMU）和操作系统级的支持，这增加了系统设计和维护的复杂性。&lt;/li&gt;
  &lt;li&gt;资源消耗：维护页表和相关数据结构需要额外的内存和CPU资源。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;三虚拟内存实现的三种机制&quot;&gt;三、虚拟内存实现的三种机制&lt;/h3&gt;

&lt;p&gt;虚拟内存（Virtual Memory）是一种计算机系统技术，它使得程序可以使用比实际物理内存更大的地址空间。虚拟内存通过将虚拟地址映射到物理地址，实现了内存的高效管理和保护。虚拟内存的实现主要有三种机制：分页（Paging）、分段（Segmentation）和段页结合（Segmentation with Paging）。&lt;/p&gt;

&lt;h4 id=&quot;1-分页机制paging&quot;&gt;1. 分页机制（Paging）&lt;/h4&gt;

&lt;p&gt;分页机制是虚拟内存实现中最常见的一种方式。它将虚拟地址空间和物理地址空间都划分为固定大小的块，分别称为页（Page）和页框（Frame）。虚拟地址由页号和页内偏移量组成，通过页表（Page Table）将页号映射到物理内存中的页框。&lt;/p&gt;

&lt;h5 id=&quot;特点&quot;&gt;特点&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;固定大小&lt;/strong&gt;：页和页框大小固定，简化了内存管理。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;减少外部碎片&lt;/strong&gt;：由于页大小固定，减少了外部碎片。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;内存保护&lt;/strong&gt;：每个页可以有不同的访问权限。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2-分段机制segmentation&quot;&gt;2. 分段机制（Segmentation）&lt;/h4&gt;

&lt;p&gt;分段机制将虚拟地址空间划分为若干段，每个段有一个段基址和段长度。虚拟地址由段选择子和段内偏移量组成。段选择子用于选择段，段内偏移量用于指定段内的具体地址。&lt;/p&gt;

&lt;h5 id=&quot;特点-1&quot;&gt;特点&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;灵活性&lt;/strong&gt;：可以根据需要动态调整段的大小。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;保护性&lt;/strong&gt;：每个段可以有不同的访问权限，提供了内存保护。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;共享性&lt;/strong&gt;：多个进程可以共享同一个段。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;3-段页结合机制segmentation-with-paging&quot;&gt;3. 段页结合机制（Segmentation with Paging）&lt;/h4&gt;

&lt;p&gt;段页结合机制结合了分段和分页的优点。内存首先被划分为段，每个段再划分为若干页。虚拟地址由段选择子、页号和页内偏移量组成。&lt;/p&gt;

&lt;h5 id=&quot;特点-2&quot;&gt;特点&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;灵活性和固定大小结合&lt;/strong&gt;：段提供灵活性，页提供固定大小的管理。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;减少外部碎片&lt;/strong&gt;：分页减少了外部碎片。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;内存保护和共享&lt;/strong&gt;：段和页都可以有不同的访问权限，提供了更细粒度的内存保护和共享。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;分段机制（Segmentation）：分段机制将虚拟地址空间划分为多个段（segment），每个段具有不同的大小和属性。每个段都有一个基地址和长度，通过将段内的偏移量与基地址相加，可以得到物理地址。分段机制可以提供灵活的地址空间管理，但可能会导致外部碎片问题。&lt;/li&gt;
  &lt;li&gt;分页机制（Paging）：分页机制将虚拟地址空间和物理内存空间划分为固定大小的页（page），通常为4KB或者更大。虚拟地址被划分为页号和页内偏移量，通过页表（Page Table）来映射虚拟页号到物理页框号。分页机制可以提供更好的内存利用率和地址空间的连续性，但可能会导致内部碎片问题。&lt;/li&gt;
  &lt;li&gt;段页机制（Segmentation with Paging）：段页机制是分段机制和分页机制的结合，它将虚拟地址空间划分为多个段，每个段再划分为多个页。通过段表（Segment Table）和页表的组合，可以将虚拟地址映射到物理地址。段页机制综合了分段和分页的优点，提供了更灵活的地址空间管理和更好的内存利用率。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Ted</name></author><category term="操作系统" /><summary type="html">一、内存管理</summary></entry><entry><title type="html">Elasticsearch</title><link href="http://www.helloted.com/%E6%95%B0%E6%8D%AE%E5%BA%93/2022/11/20/es/" rel="alternate" type="text/html" title="Elasticsearch" /><published>2022-11-20T20:00:00+08:00</published><updated>2022-11-20T20:00:00+08:00</updated><id>http://www.helloted.com/%E6%95%B0%E6%8D%AE%E5%BA%93/2022/11/20/es</id><content type="html" xml:base="http://www.helloted.com/%E6%95%B0%E6%8D%AE%E5%BA%93/2022/11/20/es/">&lt;h3 id=&quot;1简介&quot;&gt;&lt;strong&gt;1、简介&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;Elasticsearch是一个开源的分布式搜索和分析引擎，构建在Apache Lucene库之上。它提供了一个高性能、可扩展和全文搜索的解决方案，适用于各种应用场景。&lt;/p&gt;

&lt;p&gt;以下是一些关键特性和功能：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;分布式架构：Elasticsearch是一个分布式数据库，可以在多个节点上分布和复制数据，提供高可用性和容错性。它使用自动分片和复制机制来实现数据的分布和冗余存储。&lt;/li&gt;
  &lt;li&gt;实时搜索和分析：Elasticsearch以其快速的搜索性能和实时数据处理能力而闻名。它能够在大规模数据集上进行快速的全文搜索、过滤和聚合操作，并支持复杂的查询和实时数据分析。&lt;/li&gt;
  &lt;li&gt;强大的查询语言：Elasticsearch使用基于Lucene查询语法的查询语言，支持丰富的搜索和过滤功能。它提供了诸如全文搜索、模糊搜索、范围搜索、布尔搜索、聚合等功能，使用户能够灵活地构建复杂的查询。&lt;/li&gt;
  &lt;li&gt;多种数据类型支持：Elasticsearch支持多种数据类型的索引和查询，包括文本、数字、日期、地理空间等。它提供了丰富的分析和处理工具，用于处理不同类型的数据。&lt;/li&gt;
  &lt;li&gt;可扩展性和高性能：Elasticsearch具有良好的可扩展性，可以水平扩展以处理大量数据和高并发查询。它能够快速地索引和搜索大规模数据集，并提供低延迟的响应时间。&lt;/li&gt;
  &lt;li&gt;数据安全和权限控制：Elasticsearch提供了安全性和权限控制机制，可以对数据进行访问控制和身份验证。它支持基于角色的访问控制和SSL/TLS加密，以保护数据的安全性。&lt;/li&gt;
  &lt;li&gt;生态系统和集成：Elasticsearch拥有丰富的生态系统，包括Kibana（数据可视化工具）、Logstash（日志收集和处理工具）、Beats（轻量级数据采集器）等。这些工具可以与Elasticsearch无缝集成，提供全面的数据处理和可视化能力。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Elasticsearch的灵活性和功能丰富性使其成为处理大规模数据、实时搜索和分析的理想选择。它被广泛应用于日志分析、企业搜索、电商平台、实时监控、地理空间分析等各种领域和应用场景。&lt;/p&gt;

&lt;h3 id=&quot;2应用场景&quot;&gt;&lt;strong&gt;2、应用场景&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;Elasticsearch是一个功能强大的分布式搜索和分析引擎，适用于许多不同的应用场景。以下是一些常见的Elasticsearch应用场景：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;实时日志分析：Elasticsearch能够高效地处理大量的实时日志数据，并提供强大的搜索和聚合功能，使得日志分析和监控变得更加容易和高效。&lt;/li&gt;
  &lt;li&gt;全文搜索引擎：Elasticsearch以其快速的搜索性能和高级的文本分析功能而闻名，适用于构建全文搜索引擎、内容管理系统、电子商务平台等需要强大搜索能力的应用。&lt;/li&gt;
  &lt;li&gt;企业搜索和知识管理：Elasticsearch可以帮助组织构建内部搜索引擎，用于快速检索和浏览企业内部的文档、知识库、文档存档等。&lt;/li&gt;
  &lt;li&gt;实时数据分析和可视化：Elasticsearch与Kibana（一个数据可视化工具）结合使用，可以实现实时数据的分析和可视化，帮助用户更好地理解和利用数据。&lt;/li&gt;
  &lt;li&gt;产品目录和电商搜索：Elasticsearch提供了强大的搜索和过滤功能，适用于构建产品目录、电商平台等需要快速搜索和过滤商品的应用。&lt;/li&gt;
  &lt;li&gt;地理空间数据分析：Elasticsearch支持地理空间数据的索引和查询，适用于构建位置服务、地理信息系统（GIS）等应用。&lt;/li&gt;
  &lt;li&gt;实时监控和告警：Elasticsearch可以用于实时监控和告警系统，通过收集和分析实时数据，及时发现和处理异常情况。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这只是一些常见的应用场景，实际上，Elasticsearch的灵活性和可扩展性使其适用于许多其他领域和用途。它的强大搜索和分析功能以及分布式架构使其成为处理大规模数据和实时数据的理想选择。&lt;/p&gt;

&lt;h3 id=&quot;3对比&quot;&gt;&lt;strong&gt;3、对比&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;当涉及到Elasticsearch和MySQL这两个数据库时，以下是它们之间的一些详细对比：&lt;/p&gt;

&lt;p&gt;数据存储和查询语言：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;MySQL是一种关系型数据库管理系统（RDBMS），使用表格结构来存储数据，并使用结构化查询语言（SQL）作为主要的查询语言。&lt;/li&gt;
  &lt;li&gt;Elasticsearch是一个分布式文档存储数据库，使用无模式的JSON文档来存储数据，并使用自己的查询语言（基于Lucene查询语法）进行搜索和分析。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;数据模型和灵活性：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;MySQL使用固定的表格结构，需要在创建表时定义列和数据类型。它适用于结构化数据和事务处理。&lt;/li&gt;
  &lt;li&gt;Elasticsearch使用动态映射，可以根据数据自动创建索引和字段。它适用于非结构化和半结构化数据，具有更大的灵活性。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;搜索和分析能力：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;MySQL提供基本的全文搜索和模糊搜索功能，但它的搜索能力相对较弱。它更适合于简单的关系型查询。&lt;/li&gt;
  &lt;li&gt;Elasticsearch以其强大的全文搜索、过滤和聚合功能而闻名，适用于构建全文搜索引擎、实时数据分析和复杂的搜索场景。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;分布式架构和可扩展性：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;MySQL可以进行主从复制和分片，但其分布式能力相对较弱。它更适合于单机或小规模的应用。&lt;/li&gt;
  &lt;li&gt;Elasticsearch是一个分布式数据库，具有自动分片和复制机制，可以在多个节点上分布和复制数据，提供高可用性和容错性。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;数据处理和性能：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;MySQL适用于事务处理和关系型数据的存储，强调数据一致性和事务支持。&lt;/li&gt;
  &lt;li&gt;Elasticsearch适用于大规模数据的搜索、分析和实时数据处理，具有高度可扩展性和分布式计算能力。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;数据安全和权限控制：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;MySQL提供了丰富的安全性和权限控制机制，包括用户认证、访问控制和数据加密等功能。&lt;/li&gt;
  &lt;li&gt;Elasticsearch也提供了安全性和权限控制机制，可以对数据进行访问控制和身份验证。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;综上所述，MySQL适用于传统的关系型数据存储和事务处理，而Elasticsearch适用于大规模数据的搜索、分析和实时数据处理。选择哪种数据库取决于具体的需求和应用场景。在某些情况下，两者也可以结合使用，以发挥各自的优势。&lt;/p&gt;</content><author><name>Ted</name></author><category term="数据库" /><summary type="html">1、简介</summary></entry><entry><title type="html">MongoDB</title><link href="http://www.helloted.com/%E6%95%B0%E6%8D%AE%E5%BA%93/2022/11/12/mongo/" rel="alternate" type="text/html" title="MongoDB" /><published>2022-11-12T20:00:00+08:00</published><updated>2022-11-12T20:00:00+08:00</updated><id>http://www.helloted.com/%E6%95%B0%E6%8D%AE%E5%BA%93/2022/11/12/mongo</id><content type="html" xml:base="http://www.helloted.com/%E6%95%B0%E6%8D%AE%E5%BA%93/2022/11/12/mongo/">&lt;h4 id=&quot;1mongodb简介&quot;&gt;&lt;strong&gt;1、MongoDB简介&lt;/strong&gt;&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;MongoDB是一个文档数据库(以 JSON 为数据模型)，此处文档指的是JSON Docunment，并非一般理解的PDF，WORD文档。&lt;/li&gt;
  &lt;li&gt;MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像 关系数据库的。&lt;/li&gt;
  &lt;li&gt;MongoDB支持的数据结构非常松散，数据格式是BSON，一种类似JSON的二进制形式的存储格 式，简称Binary JSON ，和JSON一样支持内嵌的文档对象和数组对象，因此可以存储比较复杂的数据类型。&lt;/li&gt;
  &lt;li&gt;MongoDB在数据库总排名第5，仅次于Oracle、MySQL等RDBMS，在NoSQL数据库排名首位。从诞生 以来，其项目应用广度、社区活跃指数持续上升。原则上 Oracle 和 MySQL 能做的事情，MongoDB 都能做(包括 ACID 事务)。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;MongoDB 的三大核心特性是：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;No Schema&lt;/strong&gt;：MongoDB没有固定的Schema，少了很多约束条件，可以让数据的存储数据结构更灵活，存储速度更加快。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;高可用&lt;/strong&gt;：MongoDB能将数据分布在多台机器上实现冗余，同时检测主节点是否存活，当失活时能自动提升从节点为主节点，达到自动故障转移的目的。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;分布式&lt;/strong&gt;（可平行扩展）：MongoDB使用分片技术对数据进行扩展，能自动分片、自动转移分片里面的数据块，让每一个服务器里面存储的数据都是一样大小。&lt;/li&gt;
  &lt;li&gt;MongoDB 还支持数据压缩、二级索引、全文搜索、地理分布等一系列的强大功能。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;MongoDB使用场景类型总结&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;读写分离应用&lt;/li&gt;
  &lt;li&gt;灵活多变的业务场景，MongoDB采用No-Schema的方式，免去表结构变更的痛苦，非常适用于初创型的业务需求。可以将模式固定的结构化数据存储在mysql中，模式灵活的业务存储在MongoDB中，高热数据存储在Redis或Memcache中，实现对业务数据高效存取，降低存储数据的投入成本。&lt;/li&gt;
  &lt;li&gt;移动应用，MongoDB支持二维空间索引，可以很好地支撑基于位置查询的移动类App的业务需求。同时MongoDB动态模式存储方式也非常适合存储多重系统的异构数据，满足移动App应用的需求。&lt;/li&gt;
  &lt;li&gt;物联网应用，MongoDB具有高性能和异步数据写入功能，特定场景下可达到内存数据库的处理能力。同时，库MongoDB中的分片集群实例，可按需配置Mongos和Shard组件的配置和个数，性能及存储空间可实现无限扩展，非常适合物联网高并发写入的场景。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;MongoDB提供二级索引功能满足动态查询的需求，利用MongoDB的map-reduce聚合框架进行多维度的数据分析。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;mysql与mongodb&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在处理大量数据方面，MongoDB 比 MySQL 更胜一筹；在云计算服务和需求频繁变化的项目上，MongoDB 也更具优势。&lt;/p&gt;

&lt;p&gt;MySQL数据结构和模式是固定的，因此保证了数据一致性和可靠性。MySQL还有一个好处，就是由于它支持基于 ACID 准则的事务操作，数据安全性更高。所以对于看重这些因素的项目来说，MySQL 是最合适的。&lt;/p&gt;

&lt;h3 id=&quot;2应用场景&quot;&gt;&lt;strong&gt;2、应用场景：&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;应用服务器的日志记录，日常我们会把一些应用日志存储到文本格式的文件中，这样不便于查看同时也不便于统计等。通过MongoDB存储，既可以很好的存储、统计同时也方便不同的业务场景下日志数据格式不一致等情况。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;第三方信息的抓取与存储，我们在一些业务场景中难免会去使用到第三方的数据，当接入多个第三方平台时，这时候我们需要考虑到每个平台数据格式不一致，自身的存储系统结构设计等情况。这时候我们使用MongoDB来存储就很好的避免了这个问题。&lt;/li&gt;
  &lt;li&gt;运维监控系统，在一些大型的项目中，监控是必不可少的。监控系统要监控的内容，可能是随时多变的，这时候使用MongoDB就体现了很大的便利。不需要去修改数据库的结构，直接根据业务需要灵活调整即可。大大降低了开发成本。&lt;/li&gt;
  &lt;li&gt;O2O业务场景，将送快递骑手、快递商家的信息（包含位置信息）存储在 MongoDB，然后通过 MongoDB 的地理位置查询，这样很方便的实现了查找附近的商家、骑手等功能。&lt;/li&gt;
  &lt;li&gt;游戏业务场景，使用 MongoDB 存储游戏用户信息，用户的装备、积分等直接以内嵌文档的形式存储，方便查询、更新。&lt;/li&gt;
  &lt;li&gt;社交业务场景，使用 MongoDB 存储存储用户信息，以及用户发表的朋友圈信息，通过地理位置索引实现附近的人、地点等功能。&lt;/li&gt;
  &lt;li&gt;物联网业务场景，使用 MongoDB 存储所有接入的智能设备信息，以及设备汇报的日志信息，并对这些信息进行多维度的分析。&lt;/li&gt;
  &lt;li&gt;视频直播业务场景，视频直播，使用 MongoDB 存储用户信息、礼物信息等。&lt;/li&gt;
  &lt;li&gt;大数据应用，使用云数据库MongoDB作为大数据的云存储系统，随时进行数据提取分析，掌握行业动态。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;MongoDB提供二级索引功能满足动态查询的需求，利用MongoDB的map-reduce聚合框架进行多维度的数据分析。&lt;/p&gt;

&lt;p&gt;到底该不该使用MongoDB，下面的几道选择题可以辅助决策（来自MongoDB 公司的技术分享）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/55.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果上述有1个 Yes，可以考虑 MongoDB，2个及以上的 Yes，选择MongoDB绝不会后悔。&lt;/p&gt;

&lt;p&gt;当然，MongoDB也有自身的局限性，以下是MongoDB不适用的场景：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/56.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3mongodb的简单案例&quot;&gt;&lt;strong&gt;3、MongoDB的简单案例&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;从底层存储来讲，每个 Document 都是一个类 JSON 结构的 BSON（Binary JSON)。&lt;/p&gt;

&lt;p&gt;BSON是MongoDB首创的一种二进制存储格式，数据组织和访问方式完全和 JSON 一样。支持动态的添加字段、支持内嵌对象和数组对象。同时它也对 JSON 做了一些扩充，如支持 Date 和 BinData 数据类型。&lt;/p&gt;

&lt;p&gt;比如&lt;strong&gt;插入&lt;/strong&gt;文档的操作：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;db.book.insert(
{
  title: &quot;My first blog post&quot;,
  published: new Date(),
  tags: [ &quot;NoSQL&quot;, &quot;MongoDB&quot; ],
  type: &quot;Work&quot;,
  author : &quot;James&quot;,
  viewCount: 25,
  commentCount: 2
}
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行文档&lt;strong&gt;查找&lt;/strong&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; db.book.find({author : &quot;James&quot;})           
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;更新&lt;/strong&gt;文档的命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;db.book.update(
   {&quot;_id&quot; : ObjectId(&quot;5c61301c15338f68639e6802&quot;)},
   {&quot;$inc&quot;: {&quot;viewCount&quot;: 3} }
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;删除&lt;/strong&gt;文档的命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;db.book.remove({&quot;_id&quot;:ObjectId(&quot;5c612b2f15338f68639e67d5&quot;)})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在传统的SQL语法中，可以限定返回的字段，MongoDB可以使用Projection来表示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;db.book.find({&quot;author&quot;: &quot;James&quot;},{&quot;_id&quot;: 1, &quot;title&quot;: 1, &quot;author&quot;: 1})         
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;实现简单的分页查询：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; db.book.find({}).sort({&quot;viewCount&quot; : -1}).skip(10).limit(5)       
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这种基于BSON/JSON 的语法格式并不复杂，它的表达能力或许要比SQL更加强大。与 MongoDB 做法类似的还有 ElasticSearch，后者是搜索数据库的佼佼者。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、MongoDB和关系型数据库&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;MongoDB 在概念模型上参考了 SQL数据库，但并非完全相同。关于这点，也有人说，&lt;strong&gt;MongoDB 是 NoSQL中最像SQL的数据库&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在传统的关系型数据库中，存储方式是以表的形式存放，而在MongoDB中，以文档的形式存在。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/57.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;MongoDB与关系型数据库的模型对应关系如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/58.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;MongoDB概念与关系型数据库(RDBMS)非常类似:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Simple_2/59.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;数据库(database):最外层的概念，可以理解为逻辑上的名称空间，一个数据库包含多个不同名称的集合。&lt;/li&gt;
  &lt;li&gt;集合(collection):相当于SQL中的表，一个集合可以存放多个不同的文档。&lt;/li&gt;
  &lt;li&gt;文档(document):一个文档相当于数据表中的一行，由多个不同的字段组成。&lt;/li&gt;
  &lt;li&gt;字段(field):文档中的一个属性，等同于列(column)。&lt;/li&gt;
  &lt;li&gt;索引(index):独立的检索式数据结构，与SQL概念一致。&lt;/li&gt;
  &lt;li&gt;id:每个文档中都拥有一个唯一的id字段，相当于SQL中的主键(primary key)。&lt;/li&gt;
  &lt;li&gt;视图(view):可以看作一种虚拟的(非真实存在的)集合，与SQL中的视图类似。从MongoDB 3.4版本开始提供了视图功能，其通过聚合管道技术实现。&lt;/li&gt;
  &lt;li&gt;聚合操作($lookup):MongoDB用于实现“类似”表连接(tablejoin)的聚合操作符。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;尽管这些概念大多与SQL标准定义类似，但MongoDB与传统RDBMS仍然存在不少差异，包括:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;半结构化，在一个集合中，文档所拥有的字段并不需要是相同的，而且也不需要对所用的字段进行 声明。因此，MongoDB具有很明显的半结构化特点。除了松散的表结构，文档还可以支持多级的 嵌套、数组等灵活的数据类型，非常契合面向对象的编程模型。&lt;/li&gt;
  &lt;li&gt;弱关系，MongoDB没有外键的约束，也没有非常强大的表连接能力。类似的功能需要使用聚合管 道技术来弥补。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Ted</name></author><category term="数据库" /><summary type="html">1、MongoDB简介</summary></entry></feed>