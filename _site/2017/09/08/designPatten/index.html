<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Write your site description here. It will be used as your sites meta description as well!">

    <title>iOS设计模式 - Helloted Blog</title>

    <link rel="canonical" href="http://www.helloted.com/2017/09/08/designPatten/">

    <link rel="shortcut icon" href="/img/favicon.ico">
   
    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/clean-blog.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

</head>


<body>

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Helloted Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="/">Home</a>
                </li>
                
				
                <li>
                    <a href="/about/">About</a>
                </li>
				
                
				
                <li>
                    <a href="/contact/">Contact</a>
                </li>
				
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>


    <!-- Post Header -->
<header class="intro-header" style="background-image: url('/img/default.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>iOS设计模式</h1>
                    
                    <h2 class="subheading">iOS开发中常用的一些设计模式</h2>
                    
                    <span class="meta">Posted by Ted on September 8, 2017</span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

				<p>部分代码位置<a href="https://github.com/helloted/designpattern">Github-设计模式</a></p>

<h4 id="1单例模式singleton">1、单例模式(Singleton)</h4>

<p>概念理解：整个应用或系统只能有该类的一个实例</p>

<p>iOS中几个常用的单例：</p>

<ul>
  <li>UIApplication类提供了 ＋sharedAPplication方法创建和获取UIApplication单例</li>
  <li>NSBundle类提供了 +mainBunle方法获取NSBundle单例</li>
  <li>NSFileManager类提供了 ＋defaultManager方法创建和获得NSFileManager单例。（PS：有些时候我们得放弃使用单例模式，使用－init方法去实现一个新的实例，比如使用委托时）</li>
  <li>NSNotificationCenter提供了 ＋defaultCenter方法创建和获取NSNotificationCenter单例（PS：该类还遵循了另一个重要的设计模式：观察者模式）</li>
  <li>NSUserDefaults类提供了 ＋defaultUserDefaults方法去创建和获取NSUserDefaults单例</li>
</ul>

<p>我们也可以自己去生成一个单例</p>

<div class="highlighter-rouge"><pre class="highlight"><code>+ (SingleObject *)sharedSingleton{
    static SingleObject *_singleObj = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        _singleObj = [[self alloc] init];
    });
    return _singleObj;
}
</code></pre>
</div>

<h4 id="2mvc模式">2、MVC模式</h4>

<p>MVC是Cocoa框架采用推荐的一种设计模式，也是iOS开发中最常用的一种模式，是由各种类型的设计模式组成的复合结构</p>

<p><code class="highlighter-rouge">M-Model:</code> “模型”封装应用程序的数据，模型对象维护应用程序的数据，并定义操作数据的特定逻辑。模型对象可以复用，因为它表示的知识适用于特定问题的领域。理想状况下，模型对象同用于进行显示和编辑的用户界面之间不应有任何直接的关联。</p>

<p><code class="highlighter-rouge">V-View</code>: “视图”显示和编辑数据，视图对象可以响应用户操作。</p>

<p><code class="highlighter-rouge">C-Controller</code>: “控制器”处理前两者之间的逻辑关系。控制器对象作为中间人或者协调人，使视图得以知晓模型的变更而给予响应。控制器对象还可以作为管理其他对象的生命周期，进行设置和协调任务。</p>

<h4 id="3原型模式prototype">3、原型模式(Prototype)</h4>

<p>概念：使用原型实例指定对象的种类，并通过复制这个原型创建新的对象，原型模型也称为复制模式，此模式是生成对象的真实副本，以用作同一环境下其他相关事物的基础(原型)</p>

<p>应用：NSObject的派生类提供了实现深复制的协议，其他类需要实现NSCopying协议及其方法<code class="highlighter-rouge">-(id)copyWithZone:(NSZone *)zone</code>来实现<code class="highlighter-rouge">-(id)copy</code>方法，否则会引发异常。思路是复制必需的成员变量与资源，传给此类的新实例。</p>

<h4 id="4简单工厂模式simple-factory">4、简单工厂模式(Simple Factory)</h4>

<p>概念：提供一个创建实例的接口，根据传入值不一样来获取不一样的类</p>

<p>应用：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">@interface</span> <span class="nc">AnimalFactory</span><span class="p">:</span><span class="nc">NSObject</span>
<span class="k">-</span><span class="p">(</span><span class="n">Animal</span> <span class="o">*</span><span class="p">)</span><span class="nf">createAnimalyWithType</span><span class="p">:(</span><span class="n">Type</span><span class="p">)</span><span class="nv">type</span><span class="p">;</span>
<span class="k">@end</span><span class="p">;</span>
</code></pre>
</div>

<h4 id="5工厂方法模式factory-method">5、工厂方法模式(Factory Method)</h4>

<p>概念：封装类中不变的部分，提取其中个性化善变的部分为独立类，通过依赖注入以达到解耦、复用和方便后期维护拓展的目的.定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中</p>

<p>应用：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">@interface</span> <span class="nc">AnimalFactory</span><span class="p">:</span><span class="nc">NSObject</span>
<span class="k">-</span><span class="p">(</span><span class="n">Animal</span><span class="o">*</span><span class="p">)</span><span class="n">createAnimal</span><span class="p">;</span>
<span class="k">@end</span><span class="p">;</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">@interface</span> <span class="nc">DogFactory</span><span class="p">:</span><span class="nc">AnimalFactory</span><span class="p">;</span>
<span class="k">@implementation</span> <span class="nc">DogFactory</span>
<span class="k">-</span><span class="p">(</span><span class="n">Animal</span> <span class="o">*</span><span class="p">)</span><span class="n">createAnimal</span><span class="p">{</span>
<span class="cp">#Dog继承自Animal
</span><span class="n">retrurn</span> <span class="p">[[</span><span class="n">Dog</span> <span class="nf">alloc</span><span class="p">]</span><span class="nf">init</span><span class="p">];</span>
<span class="p">}</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">@interface</span> <span class="nc">CatFactory</span><span class="p">:</span><span class="nc">AnimalFactory</span><span class="p">;</span>
<span class="k">@implementation</span> <span class="nc">Cat</span> <span class="n">Factory</span>
<span class="o">-</span><span class="p">(</span><span class="n">Animal</span> <span class="o">*</span><span class="p">)</span><span class="n">createAnimal</span>
<span class="n">retrurn</span> <span class="p">[[</span><span class="n">Cat</span> <span class="nf">alloc</span><span class="p">]</span><span class="nf">init</span><span class="p">];</span>
<span class="p">}</span>
</code></pre>
</div>

<h4 id="6抽象工厂模式abstract-factory">6、抽象工厂模式(Abstract Factory)</h4>

<p>概念：提供一个创建一系列相关或者相互依赖对象的接口，而无需指定它们具体的类</p>

<p>应用：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">@interface</span> <span class="nc">AnimalFactory</span><span class="p">:</span><span class="nc">NSObject</span>
<span class="k">-</span><span class="p">(</span><span class="n">Dog</span> <span class="o">*</span><span class="p">)</span><span class="n">createDog</span><span class="p">;</span>
<span class="k">-</span><span class="p">(</span><span class="n">Cat</span> <span class="o">*</span><span class="p">)</span><span class="n">createCat</span><span class="p">;</span>
<span class="k">@end</span><span class="p">;</span>
</code></pre>
</div>

<p>Cocoa中的NSNumber也是如此，numberWithBool:和numberWithInt:分别返回的是NSCFBoolean、NSCFNumber类型</p>

<h4 id="7生成器模式builder">7、生成器模式(Builder)</h4>

<p>概念：将一个复杂对象的构建与它的表现分离，通过分层来构建对象。领导者-&gt;生成者-&gt;产品。领导者提供原料，生产者去实现加工成产品，不同的生产者提供不同等级的产品</p>

<p>应用：<a href="https://github.com/helloted/designpattern">Github-设计模式</a></p>

<p>与抽象工厂模式的区别：</p>

<ul>
  <li>生成器构建复杂对象，抽象工厂构建简单或者复杂对象；</li>
  <li>生成器以多个步骤构建对象，抽象工厂以单一步骤构建对象；</li>
  <li>生成器以多种方式构建对象昂，抽象工厂以单一步骤构建对象；</li>
  <li>生成器在构建过程的最后一步返回产品，抽象工厂立刻返回产品；</li>
  <li>生成器专注一个特定产品的不同等级，抽象工厂强调一套产品。</li>
</ul>

<h4 id="8适配器模式adapter">8、适配器模式(Adapter)</h4>

<p>概念：有时也称为“包装器”(Wrapper)，用于连接两种不同种类的对象，使其毫无问题地协同工作，将一个类的接口转换成客户希望的另外一个接口</p>

<p>应用：<code class="highlighter-rouge">-(void)laodData:(AModel*)model ;</code>,我们的视图需要一个AModel，但此时有一个BModel，就需要一个适配器来适配BModel,<code class="highlighter-rouge">-(AModel *)adapterfrom(BModel *)model</code></p>

<p>优点：</p>

<p>解耦合，让视图类不合数据类产生耦合，使视图类更加独立。  新增加数据类的时候不需要修改视图类。</p>

<p>缺点：</p>

<p>会新增加很多类，使系统更凌乱，代码可读性更弱了。</p>

<h4 id="9桥接模式bridge">9、桥接模式(Bridge)</h4>

<p>概念：桥接模式的目的是把抽象层次结构从其实现中分离出来，使其能够独立变更。抽象层定义了供客户端使用的上层的抽象接口。实现层定义了供抽象层使用的底层接口。实现类的引用被封装于抽象层的实例中，桥接就形成。（与外观模式有一定的相似之处）。</p>

<p>应用：<a href="https://github.com/helloted/designpattern/tree/master/Designpattern/DesignPattern/Bridge">桥接模式-Bridge</a></p>

<p>优点：</p>

<p>桥接模式使用聚合关系，解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。
提高了系统的可扩展性，可以独立地对抽象部分和实现部分进行扩展。
可减少子类的个数，这个在前面讲手机示例的时候进行分析了。</p>

<p>缺点：桥接模式的引入会增加系统的理解与设计难度，由于聚合关系建立在抽象层，要求开发者针对抽象进行设计与编程。
桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。</p>

<h4 id="10外观模式facade">10、外观模式(Facade)</h4>

<p>概念：为系统中的一组接口提供一个统一的接口</p>

<p>应用：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">@interface</span> <span class="nc">Facade</span> <span class="p">:</span> <span class="nc">NSObject</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">createApp</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">NSObject</span>

<span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="n">init</span>
<span class="p">{</span>
    <span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="nf">init</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ios_dev</span> <span class="o">=</span> <span class="p">[[</span><span class="n">IosDev</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">init</span><span class="p">];</span>
        <span class="n">andriod_dev</span> <span class="o">=</span> <span class="p">[[</span><span class="n">AndroidDev</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">init</span><span class="p">];</span>
        <span class="n">server_dev</span> <span class="o">=</span> <span class="p">[[</span><span class="n">ServerDev</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">init</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">createApp</span><span class="p">{</span>
  <span class="p">[</span><span class="n">ios_dev</span> <span class="nf">ios</span><span class="p">]</span>
  <span class="p">[</span><span class="n">andriod_dev</span> <span class="nf">android</span><span class="p">]</span>
  <span class="p">[</span><span class="n">server_dev</span> <span class="nf">server</span><span class="p">]</span>
<span class="p">}</span>
</code></pre>
</div>

<h4 id="11中介者模式mediator">11、中介者模式(Mediator)</h4>

<p>概念：用一个对象来封装一系列对象的交互方式，中介者使各对象不需要显式地相互引用，从而使其耦合松散。</p>

<p>应用：</p>

<p><img src="/img/Simple_1/07.png" alt="img" /></p>

<p><img src="/img/Simple_1/08.png" alt="img" /></p>

<p><a href="https://github.com/helloted/designpattern/tree/master/Designpattern/DesignPattern/Mediator">中介者模式-Mediator</a></p>

<h4 id="12观察者模式observer">12、观察者模式(Observer)</h4>

<p>概念：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新</p>

<p>应用：Notification、KVO。</p>

<h4 id="13组合模式composite">13、组合模式(Composite)</h4>

<p>概念：把具有相同基类类型的对象组合到树形结构中，以表示“部分－整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。组合模式使得树形结构中的每个节点都具有相同的抽象接口，整个结构可作为一个统一的抽象结构使用，而不暴露其内部表示。每个节点的任何操作，可以通过抽象基类中定义的相同接口来进行。</p>

<p>应用：UIView对象被组合成一个树形结构，UIView对象可以包含其他的UIView对象。这种组合方式便于统一用于事件处理，例如处理渲染事件时，事件会在父视图中被处理，然后在传递给子视图，因为他们都是相同的类型，事件可以传递到树形结构的每一视图。</p>

<p>优点：</p>

<ul>
  <li>可以使用简单的基本对象组合成较为复杂的组合对象，复杂组合对象又可以组合成更为复杂的对象，如此递归循环。但是使用简单对象和使用复杂组合对象是无差别的</li>
  <li>简化客户单代码，同时使得创建同类型的复杂对象更简单。因为客户端不需要区分单个对象还是组合对象，所以不必写if-else之类的各种判断</li>
</ul>

<h4 id="14迭代器模式composite">14、迭代器模式(Composite)</h4>

<p>概念：提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示</p>

<p>应用：NSEnumerator,<code class="highlighter-rouge">enumerateObjectsUsingBlock:(void(^)(id obj, NSUInteger idx, BOOL *stop))block</code>  等等</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">@interface</span> <span class="nc">Iterator</span><span class="p">:</span><span class="nc">NSObject</span>
<span class="k">-</span><span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="n">First</span><span class="p">;</span>
<span class="k">-</span><span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="n">Next</span><span class="p">;</span>
<span class="k">-</span><span class="p">(</span><span class="n">BOOL</span><span class="p">)</span><span class="n">IsDone</span><span class="p">;</span>
<span class="k">-</span><span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="n">CurrentItem</span><span class="p">;</span>
<span class="k">@end</span>
</code></pre>
</div>

<h4 id="15访问者模式vistor">15、访问者模式(Vistor)</h4>

<p>概念：表示一个作用于表示一个作用于某对象结构中的各个元素的操作，它让我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作</p>

<p>应用：这用于某个对象结构中的元素数目比较固定（基本不会变动），而对于这些元素的操作可能要变化（增加新操作），vistor提供了在某个状态下，对对象结构中各元素的不同操作的访问接口，对象中使用accept接口接受一个具体的访问者。符合open-close原则。</p>

<p>访问者模式适用于数据结构相对稳定的系统，它把数据结构和作用于结构上的操作之间的耦合解开，使得操作集合可以相对自由地演化。</p>

<p>访问者模式的优点就是增加新的操作很容易，因为增加新的操作就意味着增加一个新的访问者。访问者模式将有关的行为集中到一个访问者对象中。缺点是是增加新的数据结构变得复杂</p>

<h4 id="16装饰者模式decorator">16、装饰者模式(Decorator)</h4>

<p>概念：是面向对象编程领域中，一种动态地往一个类中添加新的行为的设计模式。就功能而言，修饰模式相比生成子类更为灵活，这样可以给某个对象而不是整个类添加一些功能</p>

<p>应用：Category,Delegate</p>



                <hr>

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2017/05/30/hotfix/" data-toggle="tooltip" data-placement="top" title="热修复=Runtime+Javascriptcore">&larr; 上一篇</a>
                    </li>
                    
                    
                </ul>

            </div>
        </div>
    </div>
</article>

<hr>


    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    <li>
                        <a href="/feed.xml">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    
                    <li>
                        <a href="https://github.com/helloted">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a href="mailto:helloted@live.com">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-envelope fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
                <p class="copyright text-muted">Copyright &copy; Helloted 2017</p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/clean-blog.min.js "></script>


    


</body>

</html>
