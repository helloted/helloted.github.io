<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Write your site description here. It will be used as your sites meta description as well!">

    <title>神奇的Runtime - Helloted Blog</title>

    <link rel="canonical" href="http://www.helloted.com/2016/03/05/runtime/">

    <link rel="shortcut icon" href="/img/favicon.ico">
   
    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/clean-blog.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

</head>


<body>

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Helloted Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="/">Home</a>
                </li>
                
				
                <li>
                    <a href="/about/">About</a>
                </li>
				
                
				
                <li>
                    <a href="/contact/">Contact</a>
                </li>
				
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>


    <!-- Post Header -->
<header class="intro-header" style="background-image: url('/img/Runtime/bg.png')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>神奇的Runtime</h1>
                    
                    <h2 class="subheading">Objective-C中Runtime的那点东西</h2>
                    
                    <span class="meta">Posted by Ted on March 5, 2016</span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

				<h3 id="一本质">一、本质</h3>

<p>[receiver message]不是一个简单地方法调用，而是在编译阶段被编译器转化为</p>

<pre><code class="language-objective-c">objc_msgSend(Class receiver,SEL selector, arg1, arg2, ...)
</code></pre>

<p>，只是在编译阶段确定了要向receiver发送message这条消息，而receiver如何响应这条消息，要看运行时来决定，消息的receiver能够找到对应的selector，那么就相当于直接执行了receiver这个对象的特定方法；否则，消息要么被转发，或是临时向receiver动态添加这个selector对应的实现内容，要么就干脆崩溃掉。</p>

<p>NSObject还有些方法能在运行时获得类的信息，并检查一些特性，比如class返回对象的类；isKindOfClass:和isMemberOfClass:则检查对象是否在指定的类继承体系中；respondsToSelector:检查对象能否响应指定的消息；conformsToProtocol:检查对象是否实现了指定协议类的方法；methodForSelector:则返回指定方法实现的地址。</p>

<h3 id="二class结构objc_msgsendclass-receiversel-selector-arg1-arg2-之receiver">二、Class结构[objc_msgSend(Class receiver,SEL selector, arg1, arg2, …)之Receiver]</h3>

<pre><code class="language-objective-c">@interface NSObject &lt;NSObject&gt; {
    Class isa;
}
</code></pre>

<p>有一个Class类型的isa属性，typedef struct objc_class *Class，所以Class是一个objc_class结构类型的指针；</p>

<pre><code class="language-objective-c">struct objc_class {  
    struct objc_class *isa;  	     //指向该对象所属类型的类型对象（Class Object），而类的isa指针指向它的metaclass.
    struct objc_class *super_class;  //指向父类,如果该类已经是最顶层的根类(如 NSObject 或 NSProxy),那么 super_class 就为 NULL.
    const charchar *name;            //类名称
    long version; 		     //类的版本信息
    long info; 			     //运行期使用的标志位，比如0x1（CLS_CLASS）表示该类为普通class，0x2（CLS_META）表示该类为metaclass 
    long instance_size; 	     //实例大小，即内存所占空间
    struct objc_ivar_list *ivars;    //指向成员变量列表的指针
    struct objc_method_list **methodLists; //根据info标志位的不同可能指向不同，比如可能指向实例方法列表，或者指向类方法列表 
    struct objc_cache *cache;        //因为Objective-C的消息转发需要查找dispatch table甚至可能需要遍历继承体系，所以缓存最近使用的方法。  
    struct objc_protocol_list *protocols;  //类需要遵守的协议
  }
</code></pre>

<p>isa&amp;superclass</p>

<p>每一个对象本质上都是一个类的实例。其中类定义了成员变量和成员方法的列表。对象通过对象的isa指针指向类。</p>

<p>每一个类本质上都是一个对象，类其实是元类（meteClass）的实例。元类定义了类方法的列表。类通过类的isa指针指向元类。</p>

<p>所有的元类最终继承一个根元类，根元类isa指针指向本身，形成一个封闭的内循环</p>

<p>superclass指向该类的父类, 如果该类已经是最顶层的根类(如 NSObject 或 NSProxy),那么 super_class 就为 NULL.</p>

<p><img src="http://ojx0q9o9x.bkt.clouddn.com/Runtime_00.png" alt="img" /></p>

<p>上图实线是 super_class 指针，虚线是isa指针。 有趣的是根元类的超类是NSObject，而isa指向了自己，而NSObject的超类为nil，也就是它没有超类。</p>

<p>需要深刻理解 [self class] 与 object_getClass(self) 甚至 object_getClass([self class]) 的关系，其实并不难，重点在于 self 的类型：</p>

<p>当 self 为实例对象时，[self class] 与 object_getClass(self) 等价，因为前者会调用后者。object_getClass([self class]) 得到元类。</p>

<p>当 self 为类对象时，[self class] 返回值为自身，还是 self。object_getClass(self) 与 object_getClass([self class]) 等价。</p>

<p>objc_ivar_list 成员变量的数组，成员变量生成后变不能修改</p>

<pre><code class="language-objective-c">struct objc_ivar_list {  
    int ivar_count;  /* variable length structure */  
    struct objc_ivar ivar_list[1]; 
} 
</code></pre>

<p>objc_method_list 方法列表指针，存储着objc_method列表，可以动态修改方法列表的值来添加成员方法</p>

<pre><code class="language-objective-c">struct objc_method_list {  
    struct objc_method_list *obsolete;  
    int method_count;  /* variable length structure */  
    struct objc_method method_list[1];  
}
</code></pre>

<p>objc_cache 指向最近使用的方法.用于方法调用的优化.</p>

<pre><code class="language-objective-c">struct objc_cache {  
    unsigned int mask /* total = mask + 1 */;  
    unsigned int occupied;  
    Method buckets[1];  
};  
</code></pre>

<p>protocols 协议的数组指针</p>

<pre><code class="language-objective-c">struct objc_protocol_list {  
    struct objc_protocol_list *next;  
    long count;  
    Protocol *list[1];  
}; 
</code></pre>

<h3 id="三selobjc_msgsendclass-receiversel-selector-arg1-arg2-之selector">三、SEL[objc_msgSend(Class receiver,SEL selector, arg1, arg2, …)之selector]</h3>

<p>Seloctor:方法选择器，其实它就是个映射到方法的C字符串，你可以用 Objc 编译器命令@selector()或者 Runtime 系统的sel_registerName函数来获得一个SEL类型的方法选择器。SEL类型的数据结构是SEL:typedef struct objc_selector *SEL;每个selector会对应一个IMP来实现函数(methodForSelector可以获取Selector对应的IMP)；</p>

<p>Method:一种代表类中的某个方法的类型。</p>

<p>在Class的objc_method_list里有一个objc_method列表</p>

<pre><code class="language-objective-c">struct objc_method {
    SEL method_name                           
    char *method_types     存储着方法的参数类型和返回值类型                                 
    IMP method_imp     指向了方法的实现，本质上是一个函数指针                                 
} 
</code></pre>

<p>IMP:具体的方法的地址，IMP 是一个函数指针，这个被指向的函数包含一个接收消息的对象id(self  指针), 调用方法的选标 SEL (方法名)，以及不定个数的方法参数，并返回一个id。也就是说 IMP 是消息最终调用的执行代码，是方法真正的实现代码 class_getMethodImplementation(class, SEL)。</p>

<h3 id="四消息发送机制">四、消息发送机制：</h3>

<p>伪代码：</p>

<pre><code class="language-objective-c">id objc_msgSend(id self, SEL _cmd, ...) {
  Class class = object_getClass(self);
  IMP imp = class_getMethodImplementation(class, _cmd);
  return imp ? imp(self, _cmd, ...) : 0;
}
</code></pre>

<ol>
  <li>
    <p>检测Target是否是nil对象，如果是nil就忽略，OC是nil不崩溃；</p>
  </li>
  <li>
    <p>查找这个类的IMP（先从cache里查找，然后再到方法列表里去找），找到后就到函数实现去执行；</p>
  </li>
  <li>
    <p>如果Class的方法列表里还找不到，就去SuperClass里找，一直到NSObject;</p>
  </li>
  <li>
    <p>再找不到就要到动态方法解析了,当 Runtime 系统在Cache和方法分发表中（包括超类）找不到要执行的方法时，Runtime会调用resolveInstanceMethod:或resolveClassMethod:来给程序员一次动态添加方法实现的机会</p>

    <p><img src="/img/Runtime/runtime_01.png" alt="" /></p>

    <p><img src="/img/Runtime/runtime_02.jpg" alt="" /></p>
  </li>
</ol>

<h3 id="五动态添加属性">五、动态添加属性</h3>

<p>category可以动态添加方法，借助Runtime还可以添加属性，但是不能添加成员变量，Category可以通过runtime.h中objc_getAssociatedObject / objc_setAssociatedObject来访问和生成关联对象。通过这种方法来模拟生成属性，但是与对象还是有点区别，因为对象属性会编译器自动生成setter和getter方法，会默认给你生成一个以下划线开头的成员变量,而category不手动去生成setter和getter的话，会报错。</p>

<p>1、不能添加成员变量，会报错</p>

<p><img src="/img/Runtime/runtime_03.png" alt="" /></p>

<p><img src="/img/Runtime/runtime_04.png" alt="" /></p>

<p>这个函数只能在“构建一个类的过程中”调用。一旦完成类定义，就不能再添加成员变量了</p>

<h3 id="六kvc与kvo">六、KVC与KVO</h3>

<h4 id="1kvc">1、KVC</h4>

<p>KVC运用了isa-swizzing技术。isa-swizzing就是类型混合指针机制。KVC通过isa-swizzing实现其内部查找定位。isa指针（is kind of 的意思）指向维护分发表的对象的类，该分发表实际上包含了指向实现类中的方法的指针和其他数据。</p>

<p>比如说如下的一行KVC代码：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>[site setValue:@"sitename" forKey:@"name"];
</code></pre>
</div>

<p>会被编译器处理成</p>

<div class="highlighter-rouge"><pre class="highlight"><code>SEL sel = sel_get_uid(setValue:forKey);
IMP method = objc_msg_loopup(site-&gt;isa,sel);
method(site,sel,@"sitename",@"name");
</code></pre>
</div>

<p>每个类都有一张方法表，是一个hash表，值是还书指针IMP，SEL的名称就是查表时所用的键。
SEL数据类型：查找方法表时所用的键。定义成char*，实质上可以理解成int值。
IMP数据类型：他其实就是一个编译器内部实现时候的函数指针。当Objective-C编译器去处理实现一个方法的时候，就会指向一个IMP对象，这个对象是C语言表述的类型。</p>

<h4 id="2kvo">2、KVO</h4>

<p>当某个类的对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的 setter 方法。</p>

<p>派生类在被重写的 setter 方法实现真正的通知机制，就如前面手动实现键值观察那样。这么做是基于设置属性会调用 setter 方法，而通过重写就获得了 KVO 需要的通知机制。当然前提是要通过遵循 KVO 的属性设置方式来变更属性值，如果仅是直接修改属性对应的成员变量，是无法实现 KVO 的。</p>

<p>同时派生类还重写了 class 方法以“欺骗”外部调用者它就是起初的那个类。然后系统将这个对象的 isa 指针指向这个新诞生的派生类，因此这个对象就成为该派生类的对象了，因而在该对象上对 setter 的调用就会调用重写的 setter，从而激活键值通知机制。此外，派生类还重写了 dealloc 方法来释放资源。</p>

<p>简单而言：在被观察时，生成派生类，对于观察属性重写setter方法，然后在valuewillchange方法和valuesdidchanged方法里发出通知</p>

<p>1、当一个object有观察者时，动态创建这个object的类的子类</p>

<p>2、对于每个被观察的property，重写其set方法</p>

<p>3、在重写的set方法中调用- willChangeValueForKey:和- didChangeValueForKey:通知观察者</p>

<p>4、当一个property没有观察者时，删除重写的方法</p>

<p>5、当没有observer观察任何一个property时，删除动态创建的子类</p>

<h3 id="七利用runtime可以作用的一些方法">七、利用Runtime可以作用的一些方法：</h3>

<p>class_getName：获取类名</p>

<p>class_getSuperclass：获取父类</p>

<p>class_getInstanceSize：获取实例大小</p>

<p>class_getInstanceVariable：获取实例成员变量</p>

<p>class_getClassVariable：获取类成员变量</p>

<p>class_getProperty：获得属性</p>

<p>class_getInstanceMethod：获得实例方法</p>

<p>class_getClassMethod：获得类方法class_getMethodImplementation：获得IMP</p>

<p>class_copyIvarList:获取成员变量列表</p>

<p>class_copyMethodList：获取方法列表</p>

<p>class_copyProtocolList：获取协议列表</p>

<p>class_addIvar：添加成员变量(添加成员变量只能在运行时创建的类，且不能为元类)</p>

<p>class_addProperty：添加属性</p>

<p>class_addMethod：添加方法</p>

<p>class_addProtocol：添加协议</p>

<p>class_replaceProperty：替换属性的信息(如果没有原属性会新建一个属性)</p>

<p>class_replaceMethod：替代方法的实现</p>

<p>class_respondsToSelector：查看类是否相应指定方法</p>

<p>class_isMetaClass：查看类是否为元类</p>

<p>class_conformsToProtocol：查看类是否遵循指定协议</p>

<p>object_getInstanceVariable：获取实例的成员变量</p>

<p>object_getIvar：获取成员变量的值</p>

<p>object_getClassName：获取指定对象的类名</p>

<p>object_getClass：获取指定对象的类</p>

<p>objc_getMetaClass：获取指定类的元类</p>

<p>object_copy：拷贝指定对象</p>

<p>objc_getProtocol：获取指定名字的协议</p>

<p>object_setInstanceVariable：设置指定实例指定名称的成员变量的值</p>

<p>object_setIvar：设置指定对象的指定的成员变量的值</p>

<p>objc_setAssociatedObject：设置关联对象的值</p>

<p>objc_getAssociatedObject：获取关联对象的值</p>

<p>objc_removeAssociatedObjects：移除关联对象</p>

<p>ivar_getName：获取成员变量名</p>

<p>ivar_getTypeEncoding：获取成员变量类型编码</p>

<p>ivar_getOffset：获取成员变量的偏移量</p>

<p>property_getName：获取属性名</p>

<p>property_copyAttributeValue：获取属性中指定的特性</p>

<p>method_invoke：调用指定方法的实现</p>

<p>method_getName：获取方法名</p>

<p>method_getImplementation：返回方法的实现</p>



                <hr>

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2015/10/10/network/" data-toggle="tooltip" data-placement="top" title="网络">&larr; 上一篇</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2016/05/22/ios-Thread/" data-toggle="tooltip" data-placement="top" title="iOS之多线程">下一篇 &rarr;</a>
                    </li>
                    
                </ul>

            </div>
        </div>
    </div>
</article>

<hr>


    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    <li>
                        <a href="/feed.xml">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    
                    <li>
                        <a href="https://github.com/helloted">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a href="mailto:helloted@live.com">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-envelope fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
                <p class="copyright text-muted">Copyright &copy; Helloted 2017</p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/clean-blog.min.js "></script>


    


</body>

</html>
