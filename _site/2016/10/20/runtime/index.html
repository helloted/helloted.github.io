<h3 id="一本质">一、本质</h3>

<p>[receiver message]不是一个简单地方法调用，而是在编译阶段被编译器转化为</p>

<p>objc_msgSend(Class receiver,SEL selector, arg1, arg2, …)</p>

<p>，只是在编译阶段确定了要向receiver发送message这条消息，而receiver如何响应这条消息，要看运行时来决定，消息的receiver能够找到对应的selector，那么就相当于直接执行了receiver这个对象的特定方法；否则，消息要么被转发，或是临时向receiver动态添加这个selector对应的实现内容，要么就干脆崩溃掉。</p>

<p>NSObject还有些方法能在运行时获得类的信息，并检查一些特性，比如class返回对象的类；isKindOfClass:和isMemberOfClass:则检查对象是否在指定的类继承体系中；respondsToSelector:检查对象能否响应指定的消息；conformsToProtocol:检查对象是否实现了指定协议类的方法；methodForSelector:则返回指定方法实现的地址。//</p>

<h3 id="二class结构objc_msgsendclass-receiversel-selector-arg1-arg2-之receiver">二、Class结构[objc_msgSend(Class receiver,SEL selector, arg1, arg2, …)之Receiver]</h3>

<p>1、@interface NSObject <NSObject> {</NSObject></p>

<p>​    Class isa;</p>

<p>}</p>

<p>有一个Class类型的isa属性，typedef struct objc_class *Class，所以Class是一个objc_class结构类型的指针；</p>

<p>struct objc_class {  </p>

<p>    struct objc_class *isa;  	     //指向该对象所属类型的类型对象（Class Object），而类的isa指针指向它的metaclass.</p>

<p>    struct objc_class *super_class;  //指向父类,如果该类已经是最顶层的根类(如 NSObject 或 NSProxy),那么 super_class 就为 NULL.</p>

<p>    const charchar *name;            //类名称</p>

<p>    long version; 		     //类的版本信息</p>

<p>    long info; 			     //运行期使用的标志位，比如0x1（CLS_CLASS）表示该类为普通class，0x2（CLS_META）表示该类为metaclass </p>

<p>    long instance_size; 	     //实例大小，即内存所占空间</p>

<p>    struct objc_ivar_list *ivars;    //指向成员变量列表的指针</p>

<p>    struct objc_method_list **methodLists; //根据info标志位的不同可能指向不同，比如可能指向实例方法列表，或者指向类方法列表 </p>

<p>    struct objc_cache *cache;        //因为Objective-C的消息转发需要查找dispatch table甚至可能需要遍历继承体系，所以缓存最近使用的方法。  </p>

<p>    struct objc_protocol_list *protocols;  //类需要遵守的协议</p>

<p>  }</p>

<p>isa&amp;superclass</p>

<p>每一个对象本质上都是一个类的实例。其中类定义了成员变量和成员方法的列表。对象通过对象的isa指针指向类。</p>

<p>每一个类本质上都是一个对象，类其实是元类（meteClass）的实例。元类定义了类方法的列表。类通过类的isa指针指向元类。</p>

<p>所有的元类最终继承一个根元类，根元类isa指针指向本身，形成一个封闭的内循环</p>

<p>superclass指向该类的父类, 如果该类已经是最顶层的根类(如 NSObject 或 NSProxy),那么 super_class 就为 NULL.</p>

<p><img src="http://ojx0q9o9x.bkt.clouddn.com/Runtime_00.png" alt="img" /></p>

<p>上图实线是 super_class 指针，虚线是isa指针。 有趣的是根元类的超类是NSObject，而isa指向了自己，而NSObject的超类为nil，也就是它没有超类。</p>

<p>需要深刻理解 [self class] 与 object_getClass(self) 甚至 object_getClass([self class]) 的关系，其实并不难，重点在于 self 的类型：</p>

<p>当 self 为实例对象时，[self class] 与 object_getClass(self) 等价，因为前者会调用后者。object_getClass([self class]) 得到元类。</p>

<p>当 self 为类对象时，[self class] 返回值为自身，还是 self。object_getClass(self) 与 object_getClass([self class]) 等价。</p>

<p>objc_ivar_list 成员变量的数组，成员变量生成后变不能修改</p>

<p>struct objc_ivar_list {  </p>

<p>    int ivar_count;  </p>

<p>    /<em> variable length structure </em>/  </p>

<p>    struct objc_ivar ivar_list[1]; </p>

<p>} </p>

<p>objc_method_list 方法列表指针，存储着objc_method列表，可以动态修改方法列表的值来添加成员方法</p>

<p>struct objc_method_list {  </p>

<p>    struct objc_method_list *obsolete;  </p>

<p>    int method_count;  </p>

<p>    /<em> variable length structure </em>/  </p>

<p>    struct objc_method method_list[1];  </p>

<p>}</p>

<p>objc_cache 指向最近使用的方法.用于方法调用的优化.</p>

<p>struct objc_cache {  </p>

<p>    unsigned int mask /<em> total = mask + 1 </em>/;  </p>

<p>    unsigned int occupied;  </p>

<p>    Method buckets[1];  </p>

<p>}; </p>

<p> </p>

<p>protocols 协议的数组指针</p>

<p>struct objc_protocol_list {  </p>

<p>    struct objc_protocol_list *next;  </p>

<p>    long count;  </p>

<p>    Protocol *list[1];  </p>

<p>}; </p>

<h3 id="三selobjc_msgsendclass-receiversel-selector-arg1-arg2-之selector">三、SEL[objc_msgSend(Class receiver,SEL selector, arg1, arg2, …)之selector]</h3>

<p>Seloctor:方法选择器，其实它就是个映射到方法的C字符串，你可以用 Objc 编译器命令@selector()或者 Runtime 系统的sel_registerName函数来获得一个SEL类型的方法选择器。SEL类型的数据结构是SEL:typedef struct objc_selector *SEL;每个selector会对应一个IMP来实现函数(methodForSelector可以获取Selector对应的IMP)；</p>

<p>Method:一种代表类中的某个方法的类型。</p>

<p>在Class的objc_method_list里有一个objc_method列表</p>

<p>struct objc_method {</p>

<p>​    SEL method_name</p>

<p>​    char *method_types     存储着方法的参数类型和返回值类型</p>

<p>​    IMP method_imp     指向了方法的实现，本质上是一个函数指针</p>

<p>}</p>

<p>IMP:具体的方法的地址，IMP 是一个函数指针，这个被指向的函数包含一个接收消息的对象id(self  指针), 调用方法的选标 SEL (方法名)，以及不定个数的方法参数，并返回一个id。也就是说 IMP 是消息最终调用的执行代码，是方法真正的实现代码 class_getMethodImplementation(class, SEL)。</p>

<h3 id="四消息发送机制">四、消息发送机制：</h3>

<p>伪代码：id objc_msgSend(id self, SEL _cmd, …) {</p>

<p>Class class = object_getClass(self);</p>

<p>IMP imp = class_getMethodImplementation(class, _cmd);</p>

<p>return imp ? imp(self, _cmd, …) : 0;</p>

<p>}</p>

<ol>
  <li>检测Target是否是nil对象，如果是nil就忽略，OC是nil不崩溃；</li>
  <li>查找这个类的IMP（先从cache里查找，然后再到方法列表里去找），找到后就到函数实现去执行；</li>
  <li>如果Class的方法列表里还找不到，就去SuperClass里找，一直到NSObject;</li>
  <li>再找不到就要到动态方法解析了,当 Runtime 系统在Cache和方法分发表中（包括超类）找不到要执行的方法时，Runtime会调用resolveInstanceMethod:或resolveClassMethod:来给程序员一次动态添加方法实现的机会</li>
</ol>

<p><img src="http://note.youdao.com/src/104C2F9573104D978863B1D2155B3F0F" alt="img" /></p>

<p><img src="http://note.youdao.com/src/AA32DDA93BB6433D923133045F0E2193" alt="img" /></p>

<h3 id="五动态添加属性">五、动态添加属性</h3>

<p>category可以动态添加方法，借助Runtime还可以添加属性，但是不能添加成员变量，Category可以通过runtime.h中objc_getAssociatedObject / objc_setAssociatedObject来访问和生成关联对象。通过这种方法来模拟生成属性，但是与对象还是有点区别，因为对象属性会编译器自动生成setter和getter方法，会默认给你生成一个以下划线开头的成员变量,而category不手动去生成setter和getter的话，会报错。</p>

<p>1、不能添加成员变量，会报错</p>

<p><img src="http://note.youdao.com/src/A875294D27394F659F6545F85E9898D1" alt="img" /></p>

<p><img src="http://note.youdao.com/src/EC207ADE9B3E47E484B2FE3C369777AC" alt="img" /></p>

<p>这个函数只能在“构建一个类的过程中”调用。一旦完成类定义，就不能再添加成员变量了</p>

<h3 id="六利用runtime可以作用的一些方法">六、利用Runtime可以作用的一些方法：</h3>

<p>class_getName：获取类名</p>

<p>class_getSuperclass：获取父类</p>

<p>class_getInstanceSize：获取实例大小</p>

<p>class_getInstanceVariable：获取实例成员变量</p>

<p>class_getClassVariable：获取类成员变量</p>

<p>class_getProperty：获得属性</p>

<p>class_getInstanceMethod：获得实例方法</p>

<p>class_getClassMethod：获得类方法class_getMethodImplementation：获得IMP</p>

<p>class_copyIvarList:获取成员变量列表</p>

<p>class_copyMethodList：获取方法列表</p>

<p>class_copyProtocolList：获取协议列表</p>

<p>class_addIvar：添加成员变量(添加成员变量只能在运行时创建的类，且不能为元类)</p>

<p>class_addProperty：添加属性</p>

<p>class_addMethod：添加方法</p>

<p>class_addProtocol：添加协议</p>

<p>class_replaceProperty：替换属性的信息(如果没有原属性会新建一个属性)</p>

<p>class_replaceMethod：替代方法的实现</p>

<p>class_respondsToSelector：查看类是否相应指定方法</p>

<p>class_isMetaClass：查看类是否为元类</p>

<p>class_conformsToProtocol：查看类是否遵循指定协议</p>

<p>object_getInstanceVariable：获取实例的成员变量</p>

<p>object_getIvar：获取成员变量的值</p>

<p>object_getClassName：获取指定对象的类名</p>

<p>object_getClass：获取指定对象的类</p>

<p>objc_getMetaClass：获取指定类的元类</p>

<p>object_copy：拷贝指定对象</p>

<p>objc_getProtocol：获取指定名字的协议</p>

<p>object_setInstanceVariable：设置指定实例指定名称的成员变量的值</p>

<p>object_setIvar：设置指定对象的指定的成员变量的值</p>

<p>objc_setAssociatedObject：设置关联对象的值</p>

<p>objc_getAssociatedObject：获取关联对象的值</p>

<p>objc_removeAssociatedObjects：移除关联对象</p>

<p>ivar_getName：获取成员变量名</p>

<p>ivar_getTypeEncoding：获取成员变量类型编码</p>

<p>ivar_getOffset：获取成员变量的偏移量</p>

<p>property_getName：获取属性名</p>

<p>property_copyAttributeValue：获取属性中指定的特性</p>

<p>method_invoke：调用指定方法的实现</p>

<p>method_getName：获取方法名</p>

<p>method_getImplementation：返回方法的实现</p>

