---
layout:     post
title:      "数据结构与算法(三):排序算法"
subtitle:   "八大常用排序算法"
date:       2015-02-01 12:00:00
author:     "Ted"
header-img: "img/Http/bg.jpg"
---

前言

排序有内部排序和外部排序之分，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。

![img](/img/data/08.jpg)



### 一、冒泡排序

解析：每一次遍历，从下往上排，如果有更大的就往下换一下，小的就会不断往上冒泡。

核心思想：每一轮内循环，都能使基准位置的数比后面的数更小。

**时间复杂度分析**：O(n^2)，冒泡排序是一种不稳定排序算法

```python
def bubbling_sor(orgin_list):
    length = len(orgin_list)
    temp = 0

    # 从list[0]开始遍历，进行外循环，list[i]作为基准位置比较数
    for i in range(length):
        # 用之后的数值与基准位置的数进行比较，进行内循环
        for j in range(i+1,length):
            # 如果基准位置之后的数，比基准位置更小，就进行替换，这样一轮内循环，都能保证基准位置的数比其后面的数值更大
            if orgin_list[i] > orgin_list[j]:
                orgin_list[i],orgin_list[j] = orgin_list[j],orgin_list[i]
    return orgin_list
```

### 二、快速排序(填坑排序)

快速排序是冒泡排序的一种优化，可称为填坑

由于已经将a[0]中的数保存到X中，可以理解成在数组a[0]上挖了个坑，可以将其它数据填充到这来。

从j开始向前找一个比X小或等于X的数。当j=8，符合条件，将a[8]挖出再填到上一个坑a[0]中。a[0]=a[8]; i++;  这样一个坑a[0]就被搞定了，但又形成了一个新坑a[8]，这怎么办了？简单，再找数字来填a[8]这个坑。这次从i开始向后找一个大于X的数，当i=3，符合条件，将a[3]挖出再填到上一个坑中a[8]=a[3]; j--;

```python
def sub_solt(orgin,l,high):
    key = orgin[l]
    while l < high:
        while l < high and orgin[high] >= key:
            high -= 1
        while l < high and orgin[high] < key:
            orgin[l] = orgin[high]
            l += 1
            orgin[high] = orgin[l]
    orgin[l] = key
    return l


def quick_solt(orgin,l,high):
    if l < high:
        # 分治法找到分治点，左边为小于分治数，右边为大于分治数
        key_index = sub_solt(orgin,l,high)
        # 分别进行排序
        quick_solt(orgin,l,key_index)
        quick_solt(orgin,key_index+1,high)


if __name__ == "__main__":
    orgin = [5, 3, 4, 2, 7, 4, 6, 8]
    quick_solt(orgin,0,len(orgin)-1)
```

