---
layout:     post
title:      "画线动画、平滑过渡曲线"
subtitle:   "通过UIBezierPath来动画画线，以及平滑地画线"
date:       2017-01-15 12:00:00
author:     "Ted"
header-img: "img/bg_02.jpg"
---

### 一、动画画线

#### 1、创建CAShaperLayer

```objc
    //创建出CAShapeLayer
    _shapeLayer = [CAShapeLayer layer];
    _shapeLayer.frame = self.view.bounds;//设置shapeLayer的尺寸和位置
    _shapeLayer.position = self.view.center;
    _shapeLayer.fillColor = [UIColor clearColor].CGColor;//填充颜色为ClearColor
```

#### 2、定义线条

```objc
    //设置线条的宽度和颜色
    _shapeLayer.lineWidth = 1.0f;
    _shapeLayer.strokeColor = [UIColor redColor].CGColor;
```

#### 3、设置线条路径

```objc
    CGPoint point_1 = CGPointMake(100, 100);
    CGPoint point_2 = CGPointMake(120, 150);
    CGPoint point_3 = CGPointMake(200, 200);
    NSMutableArray *array = [NSMutableArray arrayWithObjects:@(point_1),@(point_2),@(point_3), nil];
    UIBezierPath *path = [[UIBezierPath alloc] init];
    [path moveToPoint:[[array firstObject] CGPointValue]];
    
    NSIndexSet *indexSet = [NSIndexSet indexSetWithIndexesInRange:NSMakeRange(1, [array count] - 1)];
    [array enumerateObjectsAtIndexes:indexSet
                                      options:0
                                   usingBlock:^(NSValue *pointValue, NSUInteger idx, BOOL *stop) {
                                       [path addLineToPoint:[pointValue CGPointValue]];
                                   }];
    path.usesEvenOddFillRule = YES;
```

#### 4、添加动画

```objc
    //创建动画
    CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:NSStringFromSelector(@selector(strokeEnd))];
    animation.fromValue = @0.0;
    animation.toValue = @1.0;
    animation.duration = 2;//动画时间;
    [_shapeLayer addAnimation:animation forKey:NSStringFromSelector(@selector(strokeEnd))];
```

#### 5、效果

![img](/img/draw/04.gif)

### 二、平滑曲线

```objc
- (void)addBezierThroughPoints:(NSArray *)pointArray
{
    NSAssert(pointArray.count > 0, @"You must give at least 1 point for drawing the curve.");
    
    
    CGPoint previousPoint = CGPointZero;
    
    CGPoint previousCenterPoint = CGPointZero;
    CGPoint centerPoint = CGPointZero;
    CGFloat centerPointDistance = 0;
    
    CGFloat obliqueAngle = 0;
    
    CGPoint previousControlPoint1 = CGPointZero;
    CGPoint previousControlPoint2 = CGPointZero;
    CGPoint controlPoint1 = CGPointZero;

    previousPoint = self.currentPoint;
    
    for (int i = 0; i < pointArray.count; i++) {
        
        NSValue * pointIValue = pointArray[i];
        CGPoint pointI = [pointIValue CGPointValue];
        
        if (i > 0) {

            // 上一段线的中点
            previousCenterPoint = CenterPointOf(self.currentPoint, previousPoint);
            
            // 现在要画的连线的中点位置
            centerPoint = CenterPointOf(previousPoint, pointI);
            
            // 两个中点的距离
            centerPointDistance = DistanceBetweenPoint(previousCenterPoint, centerPoint);
            
            // 两个中点的角度
            obliqueAngle = ObliqueAngleOfStraightThrough(centerPoint, previousCenterPoint);
            
            previousControlPoint2 = CGPointMake(previousPoint.x - 0.5 * self.contractionFactor * centerPointDistance * cos(obliqueAngle), previousPoint.y - 0.5 * self.contractionFactor * centerPointDistance * sin(obliqueAngle));
            controlPoint1 = CGPointMake(previousPoint.x + 0.5 * self.contractionFactor * centerPointDistance * cos(obliqueAngle), previousPoint.y + 0.5 * self.contractionFactor * centerPointDistance * sin(obliqueAngle));
        }
        
        if (i == 1) {
            
            [self addQuadCurveToPoint:previousPoint controlPoint:previousControlPoint2];
        }
        else if (i > 1 && i < pointArray.count - 1) {
        
            [self addCurveToPoint:previousPoint controlPoint1:previousControlPoint1 controlPoint2:previousControlPoint2];
        }
        else if (i == pointArray.count - 1) {
        
            [self addCurveToPoint:previousPoint controlPoint1:previousControlPoint1 controlPoint2:previousControlPoint2];
            [self addQuadCurveToPoint:pointI controlPoint:controlPoint1];
        }
        else {
        
        }
        
        previousControlPoint1 = controlPoint1;
        previousPoint = pointI;
    }
    
}

CGFloat ObliqueAngleOfStraightThrough(CGPoint point1, CGPoint point2)   //  [-π/2, 3π/2)
{
    CGFloat obliqueRatio = 0;
    CGFloat obliqueAngle = 0;
    
    if (point1.x > point2.x) {
    
        obliqueRatio = (point2.y - point1.y) / (point2.x - point1.x);
        obliqueAngle = atan(obliqueRatio);
    }
    else if (point1.x < point2.x) {
    
        obliqueRatio = (point2.y - point1.y) / (point2.x - point1.x);
        obliqueAngle = M_PI + atan(obliqueRatio);
    }
    else if (point2.y - point1.y >= 0) {
    
        obliqueAngle = M_PI/2;
    }
    else {
        obliqueAngle = -M_PI/2;
    }
    
    return obliqueAngle;
}


CGFloat DistanceBetweenPoint(CGPoint point1, CGPoint point2)
{
    return sqrt((point1.x - point2.x) * (point1.x - point2.x) + (point1.y - point2.y) * (point1.y - point2.y));
}

CGPoint CenterPointOf(CGPoint point1, CGPoint point2)
{
    return CGPointMake((point1.x + point2.x) / 2, (point1.y + point2.y) / 2);
}
```

