---
layout:     post
category:   iOS
title:      "多线程(五):通信"
subtitle:   "iOS多线程之线程通信"
date:       2016-05-28 12:00:00
author:     "Ted"
header-img: "img/default.jpg"
---

苹果官方文档[通信](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/AboutThreads/AboutThreads.html#//apple_ref/doc/uid/10000057i-CH6-SW10)

虽然一个好的设计可以最大限度地减少所需的通信量，但是在某些时候，线程之间的通信变得非常必要 （一个线程的工作是为你的应用程序工作，但是如果这个工作的结果从未被使用过，那么它有什么用处？）线程可能需要处理新的工作请求或者向应用程序的主线程报告进度。 在这些情况下，您需要一种方法来从一个线程获取信息到另一个线程。 幸运的是，线程共享相同的进程空间的事实意味着你有很多选择进行通信。

线程之间有很多交流的方式，每种方式都有自己的优点和缺点。 配置线程本地存储列出了可以在OS X中使用的最常见的通信机制。（除了消息队列和Cocoa分布式对象，这些技术在iOS中也是可用的。）

| 机制                | 描述                                       |
| ----------------- | ---------------------------------------- |
| 直接消息传递            | Cocoa应用程序支持直接在其他线程上 perform selectors的功能。 这个能力意味着一个线程本质上可以在任何其他线程上执行一个方法。 由于它们是在目标线程的上下文中执行的，因此以这种方式发送的消息会自动在该线程上进行序列化 |
| 全局变量，共享内存和对象      | 在两个线程之间传递信息的另一个简单方法是使用全局变量，共享对象或共享内存块。 尽管共享变量快速而简单，但它们比直接消息更脆弱。 共享变量必须用锁或其他同步机制小心保护，以确保代码的正确性。 不这样做可能会导致竞争状况，数据损坏或崩溃。 |
| 条件                | 条件是一个同步工具，您可以用它来控制线程何时执行特定部分的代码。 你可以把条件看成守门员，让线程只有在符合规定的条件时才能运行 |
| Runloop源          | 自定义运行循环源是您设置为在线程上接收特定于应用程序的消息的源循环源。 因为它们是事件驱动的，运行循环来源会让你的线程在无所事事的时候自动进入休眠状态，从而提高线程的效率。 |
| Ports and sockets | 基于端口的通信是两个线程之间通信的更复杂的方式，但它也是一种非常可靠的技术。 更重要的是，端口和套接字可用于与外部实体（如其他进程和服务）进行通信。 为了提高效率，端口是使用运行循环源实现的，所以当没有数据在端口上等待时，线程会休眠。 |
| 消息队列(mac)         | 传统的多处理服务定义了用于管理传入和传出数据的先入先出（FIFO）队列抽象。 尽管消息队列简单方便，但并不像其他通信技术那样高效。 |
| 分布式对象(mac)        | 分布式对象是Cocoa技术，提供基于端口通信的高级实现。 虽然有可能使用这种技术进行线程间通信，但由于会产生大量的开销，所以这样做是非常令人沮丧的。 分布式对象更适合与其他进程通信，其中进程之间的开销已经很高。 |

