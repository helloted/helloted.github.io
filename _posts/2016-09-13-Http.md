---
layout:     post
title:      "Http与Https"
subtitle:   "Http与Https的一些知识点总结"
date:       2016-09-13 12:00:00
author:     "Ted"
header-img: "img/Http/bg.jpg"
---

### 1、TCP/IP定义

TCP/IP是互联网相关的各类协议族的名称

![](/img/Http/tcp.png)

### 2、TCP/IP四层模型

OSI七层模型太过繁琐，所以就对应有了TCP/IP四层模型，对应的将OSI中的应用层、表示层、会话层统一归为应用层。

![](/img/Http/OSI.png)

- 应用层：决定了向用户提供应用服务时通信的活动。HTTP协议。

- 传输层：提供处于网络连接中的两台计算机之间的数据传输，TCP和UDP协议就在这一层

- 网络层：用来处理在网络上流动的数据包，数据包是网络传输的最小数据单位。该层规定了通过怎样的路径到达对方计算机，并把数据包传送给对方。IP协议

- 链路层：用来处理连接网络的硬件部分。


![](/img/Http/model.png)

### 3、TCP三次握手，四次挥手

![](/img/Http/01.jpg)

### 4、一次完整的HTTP请求

一次完整的HTTP请求过程从TCP三次握手建立连接成功后开始，客户端按照指定的格式开始向服务端发送HTTP请求，服务端接收请求后，解析HTTP请求，处理完业务逻辑，最后返回一个HTTP的响应给客户端，HTTP的响应内容同样有标准的格式。

HTTP请求格式主要有四部分组成，分别是：请求行(请求方法（GET/POST/DELETE/PUT/HEAD）、URI路径、HTTP的版本号)、请求头(缓存、客户端信息等)、空行、消息体(请求数据)，每部分内容占一行。

HTTP响应消息的格式包括：状态行(有HTTP协议版本号，状态码和状态说明)、响应头、空行、消息体。每部分内容占一行。

### 5、HTTP请求报文

#### 5.1请求报文

一个HTTP请求报文由请求行（request line）、请求头部（header）、空行、请求数据4个部分组成

![](/img/Http/request.png)

![](/img/Http/02.png)

#### 5.2请求行

由方法、服务器内部URL(使用GET方法时，请求参数和对应的值附加在URL后面，利用一个问号（“?”）代表URL的结尾与请求参数的开始)、协议版本组成

#### 5.3请求方法

- GET：请求获取Request-URI所标识的资源。

- POST：在Request-URI所标识的资源后附加新的数据。

- HEAD：请求获取由Request-URI所标识的资源的响应消息报头。

- PUT：请求服务器存储一个资源，并用Request-URI作为其标识。

- Delete：请求服务器删除Request-URI所标识的资源。

- TRACE：请求服务器回送收到的请求信息，主要用于测试或诊断。

- CONNECT：保留将来使用。

- OPTIONS：请求查询服务器的性能，或者查询与资源相关的选项和需求。


#### 6、HTTP返回报文

状态行(有HTTP协议版本号，状态码和状态说明)、响应头、空行、消息体

![](/img/Http/response.png)

![](/img/Http/03.png)

#### 状态码

![](/img/Http/statusCode.png)

常见状态码

- 301被请求的资源已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。
- 302请求的资源临时从不同的URI响应请求，但请求者应继续使用原有位置来进行以后的请求

- 404 没有找到
- 405 方法不允许
- 408 请求超时
- 500 服务器内部错误

### 7、长连接

在报文中有一个字段：connnection:keep-alive;是长连接的意思，从Http1.1开始就是默认TCP保持长连接，只要任意一端没有提出断开连接，则会一直保持连接状态，一次长连接可以进行多次请求和响应，好处是可以减少建立连接和断开连接的开销，减少服务器的负载，另外也可以加快Http请求和响应；

![](/img/Http/connection.png)

### 8、Cookies

Http是无状态协议，但有的时候客户端与服务器又要保持某些状态，于是引入了Cookie技术。Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态

Cookie会根据从服务器端发送的响应报文中的一个Set-Cookie的头部信息，通知客户端来保持Cookie。当下次客户端再往服务器发送请求时，客户端会自动在请求报文中加入Cookie后发送出去。

服务器端发现客户端发送过来的Cookie后，会去检查究竟从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。

### 9、HTTPS

其实HTTPS从最终的数据解析的角度，与HTTP没有任何的区别，HTTPS就是将HTTP协议数据包放到SSL/TSL层(应用层)加密后，在TCP/IP层组成IP数据报去传输，以此保证传输数据的安全；而对于接收端，在SSL/TSL将接收的数据包解密之后，将数据传给HTTP协议层，就是普通的HTTP数据。HTTP和SSL/TSL都处于OSI模型的应用层。从HTTP切换到HTTPS是一个非常简单的过程

#### Http有以下不足

- 通信使用明文，内容可能被窃听
- 不验证通信双方的身份，因此有可能遭遇伪装
- 无法证明报文的完整性，所以有可能遭到篡改

#### 对称加密与非对称加密

对称加密算法在加密和解密时使用的是同一个秘钥；而非对称加密算法需要两个密钥来进行加密和解密，这两个秘钥是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）。
与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。

#### SSL/TSL

简单的来说，SSL/TSL通过四次握手，主要交换三个信息：

**1. 数字证书：**该证书包含了公钥等信息，一般是由服务器发给客户端，接收方通过验证这个证书是不是由信赖的CA签发，或者与本地的证书相对比，来判断证书是否可信；假如需要双向验证，则服务器和客户端都需要发送数字证书给对方验证；

**2. 三个随机数：**这三个随机数构成了后续通信过程中用来对数据进行对称加密解密的**“对话密钥”**。

首先客户端先发第一个随机数N1，然后服务器回了第二个随机数N2（这个过程同时把之前提到的证书发给客户端），这两个随机数都是明文的；而第三个随机数N3（这个随机数被称为Premaster secret），客户端用数字证书的公钥进行非对称加密，发给服务器；而服务器用只有自己知道的私钥来解密，获取第三个随机数。只有，服务端和客户端都有了三个随机数N1+N2+N3，然后两端就使用这三个随机数来生成“对话密钥”，在此之后的通信都是使用这个“对话密钥”来进行对称加密解密。因为这个过程中，服务端的私钥只用来解密第三个随机数，从来没有在网络中传输过，这样的话，只要私钥没有被泄露，那么数据就是安全的。

![](/img/Simple_4/07.jpeg)

**3. 加密通信协议：**就是双方商量使用哪一种加密方式，假如两者支持的加密方式不匹配，则无法进行通信；

有个常见的问题，关于随机数为什么要三个？只最后一个随机数N3不可以么？

这是由于SSL/TLS设计，就假设服务器不相信所有的客户端都能够提供完全随机数，假如某个客户端提供的随机数不随机的话，就大大增加了“对话密钥”被破解的风险，所以由三组随机数组成最后的随机数，保证了随机数的随机性，以此来保证每次生成的“对话密钥”安全性。

#### HTTPS抓包原理

1. Https抓包的原理就是抓包程序将服务器返回的证书截获
2. 然后给客户端返回一个抓包程序的证书，
3. 客户端发送的数据用抓包程序给的证书生成的密钥加密
4. 抓包程序得到客户端发送的数据抓包程序用自己的证书解密出来，再用服务器证书加密
5. 抓包程序再把数据发给服务器

