---
layout:     post
category:   基础
title:      "网络、Http与Https"
subtitle:   "网络模型、Http与Https的一些知识点总结"
date:       2015-09-13 12:00:00
author:     "Ted"
header-img: "img/Http/bg.jpg"
---

### 一、OSI七层模型

OSI（Open System Interconnection），由底层到高层分别为，物理层、数据链路层，网络层，传输层、会话层，表示层、应用层

物理层：负责将比特流与电子信号转换

数据链路层：定义了通过通信介质相互连接的设备之间，数据传输的规范。有两个重要的概念：MAC 地址和分组交换，数据链路层的意义在于，如果没有数据链路层，数据只能以流的形式存在与通信介质中，不知道该发送往哪里，过长的数据流可能无法在通信介质中传输。

网络层：主要作用是实现终端节点间的通信。IP协议是网络层的一个重要协议，网络层中还有ARP(获取MAC地址)和ICMP协议(数据发送异常通知)，数据链路层的作用在于实现同一种数据链路下的包传递，而网络层则可以实现跨越不同数据链路的包传递。比如主机A通过Wi-Fi连接到路由器B，路由器B通过以太网连接到路由器C，而路由器C又通过Wi-Fi与主机D保持连接。这时主机A向D发送的数据包就依赖于网络层进行传输。

传输层：传输层的主要作用是实现应用程序之间的通信。网络层主要是保证不同数据链路下数据的可达性，至于如何传输数据则是由传输层负责，TCP 协议和 UDP 协议。

会话层：会话的建立和结束

表示层：数据表示、压缩和加密presentation，表示层相当于一个东西的表示，表示的一些协议，比如图片、声音和视频MPEG。

应用层：直接为用户的应用程序提供服务,应用接口，TELNET、FTP、HTTP

### 二、TCP/UDP

TCP/IP是互联网相关的各类协议族的名称

![](/img/Simple_8/tcp.png)

OSI七层模型太过繁琐，所以就对应有了TCP/IP四层模型，对应的将OSI中的应用层、表示层、会话层统一归为应用层。

![](/img/Simple_8/OSI.png)

- 应用层：决定了向用户提供应用服务时通信的活动。HTTP协议。

- 传输层：提供处于网络连接中的两台计算机之间的数据传输，TCP和UDP协议就在这一层

- 网络层：用来处理在网络上流动的数据包，数据包是网络传输的最小数据单位。该层规定了通过怎样的路径到达对方计算机，并把数据包传送给对方。IP协议

- 链路层：用来处理连接网络的硬件部分。


![](/img/Simple_8/model.png)

#### TCP（Transmission Control Protocol）传输控制协议

TCP通过校验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。数据通信之前必须先做好连接工作，在TCP中连接的建立需要三次握手，同时在通信结束时会进行断开连接的处理（四次挥手）。一个连接的建立与断开，正常过程至少需要来回送7个包才能完成。

TCP的三次握手：是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。

1、客户端向服务器发送一个SYN（synchronous）,客户端进入SYN_SEND状态

2、服务器收到SYN包后，服务器进入SYN_RECV状态，发出SYN+ACK（Acknowledgement）

3、客户端收到SYN+ACK后发出ACK确认给服务器,客户端进入ESTABLISH状态。

4、服务器收到ACK后，服务器进入ESTABLISH状态。

连接建立，开始传输数据。

TCP的四次挥手：TCP的连接的拆除需要发送四个包

TCP连接是全双工的，所以它允许两个方向的数据传输被独立关闭，通信的一端可以发送结束报文段给对方，告诉它本端已经完成了数据的发送，但允许继续接收来自对方的数据，直到对方也发送结束报文段以关闭连接。

1、客户端发送发送一个FIN，等待服务器返回ACK和FIN，客户端进入FIN_WAIT_1状态；

2、服务器接收FIN，发出一个收到FIN的ACK确认，服务器进入Close Wait状态；

3、客户端收到ACK，继续等待服务器的FIN，客户端进入FIN_WAIT_2状态；

4、服务器发送FIN，服务器等待客户端收到FIN的ACK，服务器进入LAST_ACK状态；

5、客户端收到FIN，发出ACK，客户端进入TIME_WAIT状态（2MSL等待状态）；等到2MSL后，客户端进入CLOSE状态

6、服务器接收ACK,服务器进入CLOSE状态；

连接关闭。

![](/img/Simple_8/01.jpg)

TCP窗口：TCP中，发送端的数据包到达接收端时，接收端会返回一个带序号的ACK确认，当数据包丢失或者ACK丢失或者延误时，发送端就会重新发送数据包。当ACK延误时，会出现重复发送的状况。引入序号机制则可以避免重复发送实现可靠传输。如果每次发送都要等确认的话，这样包的往返时间，网络吞吐量就会差。所以引入窗口机制。窗口控制，允许收到ACK之前，多次发送数据组。

TCP流量控制：就是让发送方的发送速率不要太快，要让接收方来得及接收。原理这就是运用TCP报文段中的窗口大小字段来控制，发送方的发送窗口不可以大于接收方发回的窗口大小。

TCP拥塞控制：拥塞窗口cwnd**慢开始**，收到ACK时，拥塞窗口由1开始指数级增长，增长到慢开始门限值ssthresh时,执行**拥塞避免算法**，拥塞窗口按线性规律增长。

#### UDP（User Datagram Protocol）用户数据报协议

UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务。并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。

无需建立连接（减少延迟）

实现简单：无需维护连接状态

头部开销小

没有拥塞控制：应用可以更好的控制发送时间和发送速率

#### TCP与UDP区别：

1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接

2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付

3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的，没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）

4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信

5、TCP首部开销20字节;UDP的首部开销小，只有8个字节

6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道

#### Socket

Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。

在socket编程中，客户端执行connect()时,将触发三次握手。在socket编程中，任何一方执行close()操作即可产生挥手操作。

Socket连接与HTTP连接的不同

通常情况下Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际应用中，客户端到服务器之间的通信防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。

而HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。

**长连接：**在TCP连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持。连接→数据传输→保持连接(心跳)→数据传输→保持连接(心跳)→……→关闭连接；

长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况。

每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，

所以每个操作完后都不断开，下次次处理时直接发送数据包就OK了，不用建立TCP连接。

**短连接:** 指通信双方有数据交互时，就建立一个TCP连接，数据发送完成后，则断开此TCP连接;连接→数据传输→关闭连接；

### 三、HTTP

#### 一次完整的HTTP请求

一次完整的HTTP请求过程从TCP三次握手建立连接成功后开始，客户端按照指定的格式开始向服务端发送HTTP请求，服务端接收请求后，解析HTTP请求，处理完业务逻辑，最后返回一个HTTP的响应给客户端，HTTP的响应内容同样有标准的格式。

HTTP请求格式主要有四部分组成，分别是：请求行(请求方法（GET/POST/DELETE/PUT/HEAD）、URI路径、HTTP的版本号)、请求头(缓存、客户端信息等)、空行、消息体(请求数据)，每部分内容占一行。

HTTP响应消息的格式包括：状态行(有HTTP协议版本号，状态码和状态说明)、响应头、空行、消息体。每部分内容占一行。

#### HTTP请求报文

> 请求报文

一个HTTP请求报文由请求行（request line）、请求头部（header）、空行、请求数据4个部分组成

![](/img/Simple_8/request.png)

![](/img/Simple_8/02.png)

> 请求行

由方法、服务器内部URL(使用GET方法时，请求参数和对应的值附加在URL后面，利用一个问号（“?”）代表URL的结尾与请求参数的开始)、协议版本组成

> 请求方法

- GET：请求获取Request-URI所标识的资源。

- POST：在Request-URI所标识的资源后附加新的数据。

- HEAD：请求获取由Request-URI所标识的资源的响应消息报头。

- PUT：请求服务器存储一个资源，并用Request-URI作为其标识。

- Delete：请求服务器删除Request-URI所标识的资源。

- TRACE：请求服务器回送收到的请求信息，主要用于测试或诊断。

- CONNECT：保留将来使用。

- OPTIONS：请求查询服务器的性能，或者查询与资源相关的选项和需求。


#### HTTP返回报文

状态行(有HTTP协议版本号，状态码和状态说明)、响应头、空行、消息体

![](/img/Simple_8/response.png)

![](/img/Simple_8/03.png)

> 状态码

![](/img/Simple_8/statusCode.png)

常见状态码

- 301被请求的资源已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。
- 302请求的资源临时从不同的URI响应请求，但请求者应继续使用原有位置来进行以后的请求

- 404 没有找到
- 405 方法不允许
- 408 请求超时
- 500 服务器内部错误

> HTTP长连接

在报文中有一个字段：connnection:keep-alive;是长连接的意思，从Http1.1开始就是默认TCP保持长连接，只要任意一端没有提出断开连接，则会一直保持连接状态，一次长连接可以进行多次请求和响应，好处是可以减少建立连接和断开连接的开销，减少服务器的负载，另外也可以加快Http请求和响应；

![](/img/Simple_8/connection.png)

> Cookies

Http是无状态协议，但有的时候客户端与服务器又要保持某些状态，于是引入了Cookie技术。Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态

Cookie会根据从服务器端发送的响应报文中的一个Set-Cookie的头部信息，通知客户端来保持Cookie。当下次客户端再往服务器发送请求时，客户端会自动在请求报文中加入Cookie后发送出去。

服务器端发现客户端发送过来的Cookie后，会去检查究竟从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。

### 四、HTTPS

其实HTTPS从最终的数据解析的角度，与HTTP没有任何的区别，HTTPS就是将HTTP协议数据包放到SSL/TSL层(应用层)加密后，在TCP/IP层组成IP数据报去传输，以此保证传输数据的安全；而对于接收端，在SSL/TSL将接收的数据包解密之后，将数据传给HTTP协议层，就是普通的HTTP数据。HTTP和SSL/TSL都处于OSI模型的应用层。从HTTP切换到HTTPS是一个非常简单的过程

#### Http有以下不足

- 通信使用明文，内容可能被窃听
- 不验证通信双方的身份，因此有可能遭遇伪装
- 无法证明报文的完整性，所以有可能遭到篡改

#### 对称加密与非对称加密

对称加密算法在加密和解密时使用的是同一个秘钥；而非对称加密算法需要两个密钥来进行加密和解密，这两个秘钥是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）。
与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。

#### SSL/TSL

简单的来说，SSL/TSL通过四次握手，主要交换三个信息：

**1. 数字证书：**该证书包含了公钥等信息，一般是由服务器发给客户端，接收方通过验证这个证书是不是由信赖的CA签发，或者与本地的证书相对比，来判断证书是否可信；假如需要双向验证，则服务器和客户端都需要发送数字证书给对方验证；

**2. 三个随机数：**这三个随机数构成了后续通信过程中用来对数据进行对称加密解密的**“对话密钥”**。

首先客户端先发第一个随机数N1，然后服务器回了第二个随机数N2（这个过程同时把之前提到的证书发给客户端），这两个随机数都是明文的；而第三个随机数N3（这个随机数被称为Premaster secret），客户端用数字证书的公钥进行非对称加密，发给服务器；而服务器用只有自己知道的私钥来解密，获取第三个随机数。只有，服务端和客户端都有了三个随机数N1+N2+N3，然后两端就使用这三个随机数来生成“对话密钥”，在此之后的通信都是使用这个“对话密钥”来进行对称加密解密。因为这个过程中，服务端的私钥只用来解密第三个随机数，从来没有在网络中传输过，这样的话，只要私钥没有被泄露，那么数据就是安全的。

![](/img/Simple_4/07.jpeg)

**3. 加密通信协议：**就是双方商量使用哪一种加密方式，假如两者支持的加密方式不匹配，则无法进行通信；

有个常见的问题，关于随机数为什么要三个？只最后一个随机数N3不可以么？

这是由于SSL/TLS设计，就假设服务器不相信所有的客户端都能够提供完全随机数，假如某个客户端提供的随机数不随机的话，就大大增加了“对话密钥”被破解的风险，所以由三组随机数组成最后的随机数，保证了随机数的随机性，以此来保证每次生成的“对话密钥”安全性。

#### HTTPS抓包原理

1. Https抓包的原理就是抓包程序将服务器返回的证书截获
2. 然后给客户端返回一个抓包程序的证书，
3. 客户端发送的数据用抓包程序给的证书生成的密钥加密
4. 抓包程序得到客户端发送的数据抓包程序用自己的证书解密出来，再用服务器证书加密
5. 抓包程序再把数据发给服务器

