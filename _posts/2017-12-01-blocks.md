---
layout:     post
title:      "Block那些事"
subtitle:   "Block底层实现以及__Block原理"
date:       2017-11-29 12:00:00
author:     "Ted"
header-img: "img/default.jpg"
---

### 一、不含变量Block

```objc
int main(int argc, const char * argv[]) {
    void (^blk)(void) = ^{
        printf("hello world");
    };
    blk();
    return 0;
}
```

通过Clang命令，可以看到编译的C++文件：

```
clang -rewrite-objc main.m
```

```c++
struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {
    impl.isa = &_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};

static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
        printf("hello world");
    }

static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};

int main(int argc, const char * argv[]) {
    void (*blk)(void) = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA));
    ((void (*)(__block_impl *))((__block_impl *)blk)->FuncPtr)((__block_impl *)blk);
    return 0;
}
```

`__main_block_func_0`这个是block的执行函数，参数是`__main_block_impl_0`类型。

`__main_block_impl_0`这个结构体就是Block的底层实现了

- isa:指向的是NSConcreteStackBlock
- Flags:标志
- FuncPtr：实现函数指针
- Desc：block的一些信息

### 二、含变量的Block

加了一个变量int i;

```objc
int main(int argc, const char * argv[]) {
    int i = 100;
    void (^blk)(void) = ^{
        printf("hello world %d",i);
    };
    blk();
    return 0;
}
```

Clang之后变成

```c++
struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  int i;
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _i, int flags=0) : i(_i) {
    impl.isa = &_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};

static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  int i = __cself->i; // bound by copy

        printf("hello world %d",i);
    }

static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};

int main(int argc, const char * argv[]) {
    int i = 100;
    void (*blk)(void) = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, i));
    ((void (*)(__block_impl *))((__block_impl *)blk)->FuncPtr)((__block_impl *)blk);
    return 0;
}
```

通过对比可发现，多个几个i

![img](/img/Simple_2/03.png)

`_main_block_impl_0`结构体中多了一个i，成功将i变量的值捕获。因为main函数中的局部变量i和函数__main_block_func_0不在同一个作用域中，调用过程中只是进行了值传递。main函数的i是在栈中，block是在堆上，所以不能对值进行修改。

如果想要在block内修改i的值，会报错

![img](/img/Simple_2/04.png)

### 三、Block内修改外部变量



