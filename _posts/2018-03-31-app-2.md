---
layout:     post
category:   iOS
title:      "APP生成与运行(二)"
subtitle:   "APP启动过程"
date:       2018-03-31 12:00:00
author:     "Ted"
header-img: "img/bg_01.jpg"
---

### 一、启动过程

iOS开发中，main函数是我们熟知的程序启动入口，但实际上并非真正意义上的入口，因为在我们运行程序，再到main方法被调用之间，程序已经做了许许多多的事情，比如我们熟知的runtime的初始化就发生在main函数调用前，还有程序动态库的加载链接也发生在这阶段。

整个过程为：

1. 系统先读取App的可执行文件（Mach-O文件），从里面获得dyld的路径
2. 加载dyld，dyld去初始化运行环境，开启缓存策略，加载程序相关依赖库(其中也包含我们的可执行文件)，并对这些库进行链接
3. 调用每个依赖库的初始化方法
4. runtime被初始化
5. runtime对项目中所有类进行类结构初始化
6. 调用所有的load方法
7. dyld返回main函数地址，main函数被调用
8. main函数调用
9. 执行AppDelegate的代理方法，主要是`didFinishLaunchingWithOptions`
10. 初始化Window，初始化基础的ViewController结构
11. 获取数据(Local DB／Network)，展示给用户

总体可以分为main函数调用之前和main函数调用之后。

### 二、main函数启动之前

#### Mach-O可执行文件

Mach-O文件格式是 OS X 与 iOS 系统上的可执行文件格式，像我们编译过程产生的.O文件，以及程序的可执行文件，动态库等都是Mach-O文件。有以下几种Mach-O

- Executable 可执行文件
- Dylib 动态库
- Bundle 库：无法被连接的动态库，只能通过dlopen()加载
- Image ：指的是Executable，Dylib或者Bundle的一种，文中会多次使用Image这个名词。
- Framework 库：动态库和对应的头文件和资源文件的集合

Mach-O的结构如下：

![img](/img/Simple_7/11.png)

- Header 头部，包含可以执行的CPU架构，比如x86,arm64
- Load commands 加载命令，包含文件的组织架构和在虚拟内存中的布局方式
- Data，数据，包含load commands中需要的各个段(segment)的数据，每一个Segment都得大小是Page的整数倍。

更多Mach-O可查看《[Mac OS X ABI Mach-O File Format Reference](https://github.com/LeoMobileDeveloper/React-Native-Files/blob/master/Mac%20OS%20X%20ABI%20Mach-O%20File%20Format%20Reference.pdf)》

有两种方式可以查看一个APP动态调用的系统可执行文件

1、通过[machoview](https://sourceforge.net/projects/machoview/?source=navbar),选择APP的可执行文件，可以看到

![img](/img/Simple_7/12.png)

2、通过`otool -L`命令行查看

![img](/img/Simple_7/13.png)

#### dyld

全程the dynamic loade，Apple 的动态链接器，系统 kernel 做好启动程序的初始准备后，交给 dyld 负责。

2017年，苹果引入了Dyld 3.0，但是只有系统APP采用这个，第三方APP都是采用Dyld 2.0。

Dyld 2.0的加载过程是：

![img](/img/Simple_7/14.png)

1. 解析 mach-o 文件，找到其依赖的库，并且递归的找到所有依赖的库，形成一张动态库的依赖图。iOS 上的大部分 app 都依赖 300 到 600 个动态链接库，所以这个步骤包含了较大的工作量。
2. 匹配 mach-o 文件到自身的地址空间；
3. 进行符号查找：比如 app 中调用了 printf 方法，就需要去系统库中查找到 printf 的地址，然后将地址拷贝到 app 中的函数指针中；
4. 绑定和变基：由于 app 需要让地址空间配置随机加载，所以所有的指针都需要加上一个基地址；
5. 运行初始化程序（Runtime、+load、+initialize），之后运行 main() 函数。

### 三、优化启动时间

> main函数之后

这部分是主要的优化部分

#### Appdelegate

能延迟初始化的尽量延迟初始化，不能延迟初始化的尽量放到后台初始化。

- 三方SDK初始化，比如Crash统计; 像分享之类的，可以等到第一次调用再出初始化。
- 初始化某些基础服务，比如WatchDog，远程参数。
- 启动相关日志，日志往往涉及到DB操作，一定要放到后台去做
- 业务方初始化，这个交由每个业务自己去控制初始化时间。

#### ViewController

延迟初始化那些不必要的`UIViewController`。

#### 用Time Profiler找到元凶

Time Profiler在分析时间占用上非常强大。实用的时候注意三点

- 在打包模式下分析（一般是Release）,这样和线上环境一样。
- 记得开启dsym，不然无法查看到具体的函数调用堆栈
- 分析性能差的设备，对于支持iOS 8的，一般分析iphone 4s或者iphone 5。

> Main函数之前

Main函数之前是iOS系统的工作，所以这部分的优化往往更具有通用性。

#### dylibs

启动的第一步是加载动态库，加载系统的动态库使很快的，因为可以缓存，而加载内嵌的动态库速度较慢。所以，提高这一步的效率的关键是：**减少动态库的数量**。

- 合并动态库，比如公司内部由私有Pod建立了如下动态库：XXTableView, XXHUD, XXLabel，强烈建议合并成一个XXUIKit来提高加载速度。

#### Rebase & Bind & Objective C Runtime

Rebase和Bind都是为了解决指针引用的问题。对于Objective C开发来说，主要的时间消耗在Class/Method的符号加载上，所以常见的优化方案是：

- 减少`__DATA`段中的指针数量。
- 合并Category和功能类似的类。比如：UIView+Frame,UIView+AutoLayout…合并为一个
- 删除无用的方法和类。
- 多用Swift Structs，因为Swfit Structs是静态分发的。感兴趣的同学可以看看我之前这篇文章：《[Swift进阶之内存模型和方法调度](http://blog.csdn.net/hello_hwc/article/details/53147910)》

#### Initializers

通常，我们会在`+load`方法中进行method-swizzling，这也是[Nshipster](http://nshipster.com/method-swizzling/)推荐的方式。

- 用initialize替代load。不少同学喜欢用method-swizzling来实现AOP去做日志统计等内容，强烈建议改为在initialize进行初始化。
- 减少`__atribute__((constructor))`的使用，而是在第一次访问的时候才用dispatch_once等方式初始化。
- 不要创建线程
- 使用Swfit重写代码。



引用：

https://blog.csdn.net/hello_hwc/article/details/78317863

WWDC 2017: [App Startup Time: Past, Present, and Future](https://developer.apple.com/videos/play/wwdc2017/413/)







