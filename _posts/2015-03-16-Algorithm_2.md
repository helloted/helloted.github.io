---
layout:     post
category:   基础
title:      "算法题目（二）"
subtitle:   "一些算法题的解法"
date:       2015-03-16 12:00:00
author:     "Ted"
header-img: "img/Http/bg.jpg"
---



#### 11、旋转数组的最小数字

题目： 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为旋转。 输入一个递增的排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组｛3，4，5，1，2｝为{1,2,3,4,5}的一个旋转，该数组的最小元素为1.

> 解法一

直接遍历，找到比第0位小的数，就是最小数，时间复杂度为O(n);

```c
int find_min(int arr[],int len)
{
    int i = 0;
    for (i = 1; i < len; i++)
    {
        if (arr[i] < arr[0])
            return arr[i];
    }
    return arr[0];
}
```

> 解法二

解法一没有利用旋转数组的特性，旋转之后的数组实际上可以划分为两个排序的子数组，而且前面的子数组的元素都是大于或者等于后面子数组的元素。我们还注意到最小的元素刚好是这两个子数组的分界线。利用二分法来实现O(logn)的查找。

首先每次找到数组中中间的数字mid，如果mid大于最左端left，说明最小数在mid的右侧区间，则改变left，置left为mid；如果mid小于数组右侧right，说明最小数在mid的左侧区间，则改变right为mid….当left的数字小于等于right的数字时，说明已经找到最小数，这个也是循环结束的条件

![img](/img/Simple_1/29.png)

```c
int find_min(int arr[],int len)
{
    if(arr == 0 || len <= 0){
        return 0;
    }
    int begin = 0;
    int end = len - 1;
    int middle;
    while(arr[begin] >= arr[end]){
        if((end - begin) == 1){
            middle = end;
            break;
        }
        middle = (begin + end)/2;
        if(arr[middle] >= arr[begin]){
            begin = middle;
        }else if(arr[middle] <= arr[end]){
            end = middle;
        }
    }
    return arr[middle];
}
```

#### 12、斐波那契数列

题目：写一个函数，输入n，求斐波那契数列的第n项。斐波那契数列的定义：F(0)=1，F(1)=1, F(n)=F(n-1)+F(n-2)（n>=2，n∈N*）

> 解法一

矩阵法，时间复杂度O(log2^n)， 斐波那契的递推公式可以表示成如下矩阵形式，利用矩阵的分治法

![img](/img/Simple_1/29.png)

```c
typedef struct MTX{
    int m00;
    int m01;
    int m10;
    int m11;
}mtx;
mtx mtx0;


mtx m_multiply(mtx a, mtx b)
{
    mtx c;
    c.m00=a.m00*b.m00+a.m01*b.m10;
    c.m01=a.m00*b.m01+a.m01*b.m11;
    c.m10=a.m10*b.m00+a.m11*b.m10;
    c.m11=a.m10*b.m01+a.m11*b.m11;
    return c;
}

mtx m_power(int k)
{
    mtx m;

    if(1==k)
    {
        m=mtx0;
        return m;
    }
    else if(0==k%2)
    {
        m=m_multiply(m_power(k/2),m_power(k/2));
        return m;
    }
    else
    {
        m=m_multiply(m_power((k-1)/2),m_power((k-1)/2));
        m=m_multiply(m,mtx0);
        return m;
    }
}
int fibonacci(int n)
{
    int m;
    mtx mtx1;

    int t[2]={0, 1};
    if(n<3)
        return t[n];
    else
        mtx1=m_power(n-2);
    return mtx1.m00;
}

int main(void) {
    mtx0.m00 = 1;
    mtx0.m01 = 1;
    mtx0.m10 = 1;
    mtx0.m11 = 0;
    int n = 8;
    int m = fibonacci(n);
    printf("Fibonacci(%d)=%d", n, m);
    return 0;
}
```

> 解法二

递归，时间复杂度O(2^N)

```c
long fibonacci(int n){
    if (n==1||n==2){
        return 1;
    }
    return fibonacci(n-2) + fibonacci(n-1);
}
```

> 解法三

循环，时间复杂度O(N)

```C
long fibonacci(int n){
    if (n==1||n==2){
        return 1;
    }

    long prePre = 1;
    long pre = 1;
    long current = 2;
    for (int i = 3; i <= n ; i++) {
        current = prePre + pre;
        prePre = pre;
        pre = current;
    }
    return current;
}
```

#### 13、二进制中1的个数

题目：请实现一个函数，输入一个整数，输出该数二进制表示中1的个数，例如把9表示成二进制是1001，有2个1，因此如果输入9，则输出2。